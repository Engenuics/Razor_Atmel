###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        04/Mar/2016  10:02:53
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\ant_api.c
#    Command line =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\ant_api.c
#        -D MPGL2 -D MPG2 --preprocess=cl
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -lC
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -o
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\bsp\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\drivers\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\libraries\captouch\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\Debug\List\ant_api.lst
#    Object file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\Debug\Obj\ant_api.o
#
###############################################################################

D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\ant_api.c
      1          /***********************************************************************************************************************
      2          File: ant_api.c                                                               
      3          
      4          Description:
      5          ANT user interface.  No initialization or state machine requried.  This file exposes the source code
      6          for all public functions that work with ant.c.  Seperating it keep sit a little more manageable.
      7          
      8          Once the ANT radio has been configured, all messaging from the ANT device is handled through 
      9          the incoming queue G_sAntApplicationMsgList.  The application is responsible for checking this
     10          queue for messages that belong to it and must manage timing and handle appropriate updates per 
     11          the ANT messaging protocol.  This should be no problem on the regular 1ms loop timing of the main 
     12          system (assuming ANT message rate is less than 1kHz).  Faster systems or burst messaging will need 
     13          to be handled seperately as an add-on to this API.
     14          
     15          
     16          ------------------------------------------------------------------------------------------------------------------------
     17          API:
     18          
     19          Globals
     20          // Configuration struct
     21          extern AntSetupDataType G_stAntSetupData;                   // From ant.c
     22          
     23          // Globals for passing data from the ANT application to the API (import these to application)
     24          extern u32 G_u32AntApiCurrentDataTimeStamp;                       // From ant_api.c
     25          extern AntApplicationMessageType G_eAntApiCurrentMessageClass;    // From ant_api.c
     26          extern u8 G_au8AntApiCurrentData[ANT_APPLICATION_MESSAGE_BYTES];  // From ant_api.c
     27          
     28          Types
     29          typedef enum {ANT_UNCONFIGURED, ANT_CONFIGURED, ANT_OPEN, ANT_CLOSED} AntChannelStatusType;
     30          typedef enum {ANT_EMPTY, ANT_DATA, ANT_TICK} AntApplicationMessageType;
     31          
     32          
     33          ***ANT CONFIGURATION / STATUS FUNCTIONS***
     34          bool AntChannelConfig(bool)
     35          All channel configuration is sent to the ANT device and TRUE is returned if successful.
     36          This requires a global data structure to be set up in the task.  It is intended to run to completion inside
     37          the application's initialization section.  
     38          
     39          To do this, copy the following code block into the application's Initialize()
     40          function.
     41          
     42            G_stAntSetupData.AntChannel          = ANT_CHANNEL_USERAPP;
     43            G_stAntSetupData.AntSerialLo         = ANT_SERIAL_LO_USERAPP;
     44            G_stAntSetupData.AntSerialHi         = ANT_SERIAL_HI_USERAPP;
     45            G_stAntSetupData.AntDeviceType       = ANT_DEVICE_TYPE_USERAPP;
     46            G_stAntSetupData.AntTransmissionType = ANT_TRANSMISSION_TYPE_USERAPP;
     47            G_stAntSetupData.AntChannelPeriodLo  = ANT_CHANNEL_PERIOD_LO_USERAPP;
     48            G_stAntSetupData.AntChannelPeriodHi  = ANT_CHANNEL_PERIOD_HI_USERAPP;
     49            G_stAntSetupData.AntFrequency        = ANT_FREQUENCY_USERAPP;
     50            G_stAntSetupData.AntTxPower          = ANT_TX_POWER_USERAPP;
     51          
     52          Copy the following definitions into the application's header file:
     53          
     54          #define ANT_CHANNEL_USERAPP             (u8)                  // Channel 0 - 7
     55          #define ANT_SERIAL_LO_USERAPP           (u8)                  // Low byte of two-byte Device #
     56          #define ANT_SERIAL_HI_USERAPP           (u8)                  // High byte of two-byte Device #
     57          #define ANT_DEVICE_TYPE_USERAPP         (u8)                  // 1 - 255
     58          #define ANT_TRANSMISSION_TYPE_USERAPP   (u8)                  // 1-127 (MSB is pairing bit)
     59          #define ANT_CHANNEL_PERIOD_LO_USERAPP   (u8)0x00              // Low byte of two-byte channel period 0x0001 - 0x7fff
     60          #define ANT_CHANNEL_PERIOD_HI_USERAPP   (u8)0x20              // High byte of two-byte channel period 
     61          #define ANT_FREQUENCY_USERAPP           (u8)50                // 2400MHz + this number 0 - 99
     62          #define ANT_TX_POWER_USERAPP            RADIO_TX_POWER_0DBM   // RADIO_TX_POWER_0DBM, RADIO_TX_POWER_MINUS5DBM, RADIO_TX_POWER_MINUS10DBM, RADIO_TX_POWER_MINUS20DBM
     63          
     64          
     65          AntChannelStatus AntRadioStatus(void)
     66          Query the ANT radio channel status.  Returns ANT_UNCONFIGURED, ANT_CLOSING, ANT_OPEN, or ANT_CLOSED
     67          
     68          
     69          bool AntOpenChannel(void)
     70          Queues a request to open the configured channel.
     71          Returns TRUE if message is successfully queued - this can be ignored or checked.  
     72          Application should monitor AntRadioStatus() for actual channel status.
     73          e.g.
     74          AntChannelStatusType eAntCurrentState;
     75          
     76          // Request to open channel only on an already closed channel.
     77          eAntCurrentState = AntRadioStatus();
     78          
     79          if(eAntCurrentState == ANT_CLOSED )
     80          {
     81             AntOpenChannel();
     82          }
     83          
     84          
     85          bool AntCloseChannel(void)
     86          Queues a request to close the configured channel.
     87          Returns TRUE if message is successfully queued - this can be ignored or checked.  
     88          Application should monitor AntRadioStatus() for channel status.
     89          e.g.
     90          AntChannelStatusType eAntCurrentState;
     91          
     92          // Request to close channel only on an open channel.
     93          eAntCurrentState = AntRadioStatus();
     94          
     95          if(eAntCurrentState == ANT_OPEN )
     96          {
     97             AntCloseChannel();
     98          }
     99          
    100          
    101          bool AntUnassignChannel(void)
    102          Quees a request to unassign the ANT channel.  Returns TRUE if message is successfully queued.  Application should monitor AntRadioStatus()
    103          for channel status.
    104          e.g.
    105          AntChannelStatusType eAntCurrentState;
    106          
    107          eAntCurrentState = AntRadioStatus();
    108          
    109          if(eAntCurrentState == ANT_CLOSED )
    110          {
    111             // Request to unassign channel (allowed only on a closed channel).
    112             AntUnassignChannel();
    113          }
    114          
    115          
    116          ***ANT DATA FUNCTIONS***
    117          bool AntQueueBroadcastMessage(u8 *pu8Data_)
    118          Queue a broadcast data message.
    119          e.g.
    120          u8 u8DataToSend[ANT_DATA_BYTES] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    121          AntQueueBroadcastMessage(&u8DataToSend[0]);
    122          
    123          
    124          bool AntQueueAcknowledgedMessage(u8 *pu8Data_)
    125          Queue an acknowledged data message.
    126          e.g.
    127          u8 u8DataToSend[ANT_DATA_BYTES] = {0x07, 0x06, 0x05, 0x04, 0x03, 0xdd, 0xee, 0xff};
    128          AntQueueAcknowledgedMessage(u8DataToSend);
    129          
    130          
    131          bool AntReadData(void)
    132          Check the incoming message buffer for any message from the ANT system (either an event or data).  
    133          If no messages are present, returns FALSE.  If a message is there, returns TRUE and application can read:
    134          - G_eAntApiCurrentMessageClass to see what kind of message is present
    135          - G_asAntApiCurrentData to get message info.
    136          
    137          
    138          ***********************************************************************************************************************/
    139          
    140          #include "configuration.h"
    141          
    142          
    143          /***********************************************************************************************************************
    144          Global variable definitions with scope across entire project.
    145          All Global variable names shall start with "G_<type>AntApi"
    146          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
    147          u32 G_u32AntApiCurrentDataTimeStamp = 0;                                /* Current read message's G_u32SystemTime1ms */
   \                     G_u32AntApiCurrentDataTimeStamp:
   \   00000000                      DS8 4
    148          

   \                                 In section .bss, align 1
    149          AntApplicationMessageType G_eAntApiCurrentMessageClass = ANT_EMPTY;     /* Type of data */
   \                     G_eAntApiCurrentMessageClass:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    150          u8 G_au8AntApiCurrentData[ANT_APPLICATION_MESSAGE_BYTES];               /* Array for message data */
   \                     G_au8AntApiCurrentData:
   \   00000000                      DS8 8
    151          
    152          /*----------------------------------------------------------------------------*/
    153          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
    154          and indicate what file the variable is defined in. */
    155          extern u32 G_u32SystemFlags;                              /* From main.c */
    156          extern u32 G_u32ApplicationFlags;                         /* From main.c */
    157          
    158          extern volatile u32 G_u32SystemTime1ms;                   /* From board-specific source file */
    159          extern volatile u32 G_u32SystemTime1s;                    /* From board-specific source file */
    160          
    161          extern volatile u32 ANT_SSP_FLAGS;                        /* From configuration.h */
    162          
    163          extern u32 G_u32AntFlags;                                     /* From ant.c */
    164          extern AntApplicationMsgListType *G_sAntApplicationMsgList;   /* From ant.c */
    165          extern AntSetupDataType G_stAntSetupData;                     /* From ant.c */
    166          
    167          extern u8 G_au8AntMessageOk[];                                /* From ant.c */
    168          extern u8 G_au8AntMessageFail[];                              /* From ant.c */
    169          extern u8 G_au8AntMessageAssign[];                            /* From ant.c */
    170          extern u8 G_au8AntMessageUnassign[];                          /* From ant.c */
    171          extern u8 G_au8AntMessageUnhandled[];                         /* From ant.c */
    172          extern u8 G_au8AntMessageSetup[];                             /* From ant.c */
    173          extern u8 G_au8AntMessageClose[];                             /* From ant.c */
    174          extern u8 G_au8AntMessageOpen[];                              /* From ant.c */
    175          extern u8 G_au8AntMessageInit[];                              /* From ant.c */
    176          extern u8 G_au8AntMessageInitFail[];                          /* From ant.c */
    177          extern u8 G_au8AntMessageNoAnt[];                             /* From ant.c */
    178          
    179          
    180          /***********************************************************************************************************************
    181          Global variable definitions with scope limited to this local application.
    182          Variable names shall start with "AntApi_<type>Name" and be declared as static.
    183          ***********************************************************************************************************************/
    184          
    185          
    186          /***********************************************************************************************************************
    187          Function Definitions
    188          ***********************************************************************************************************************/
    189          
    190          /*------------------------------------------------------------------------------
    191          Function: AntChannelConfig
    192          
    193          Description:
    194          Completely configures the ANT channel with an application's required parameters 
    195          for communication.
    196          
    197          *** This function violates 1ms system timing and should only be used during initialization ***
    198          
    199          Requires:
    200            - All Global ANT configuration variables have been assigned to the application's
    201              required values.
    202            - An ANT channel is not currently opened.
    203          
    204          Promises:
    205            - Channel, Channel ID, message period, radio frequency and radio power are configured.
    206            - Returns TRUE if configuration is successful
    207          */

   \                                 In section .text, align 2, keep-with-next
    208          bool AntChannelConfig(bool bMaster_)
    209          {
   \                     AntChannelConfig: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
    210            u8 au8ANTAssignChannel0[]    = {MESG_ASSIGN_CHANNEL_SIZE, MESG_ASSIGN_CHANNEL_ID, G_stAntSetupData.AntChannel, CHANNEL_TYPE_MASTER, G_stAntSetupData.AntNetwork, CS};
   \   00000006   0xA804             ADD      R0,SP,#+16
   \   00000008   0x....             LDR.N    R1,??DataTable7
   \   0000000A   0xC90C             LDM      R1!,{R2,R3}
   \   0000000C   0xC00C             STM      R0!,{R2,R3}
   \   0000000E   0x3908             SUBS     R1,R1,#+8
   \   00000010   0x3808             SUBS     R0,R0,#+8
   \   00000012   0x....             LDR.N    R0,??DataTable7_1
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xF88D 0x0012      STRB     R0,[SP, #+18]
   \   0000001A   0x....             LDR.N    R0,??DataTable7_1
   \   0000001C   0x7880             LDRB     R0,[R0, #+2]
   \   0000001E   0xF88D 0x0014      STRB     R0,[SP, #+20]
    211            u8 au8ANTSetChannelID0[]     = {MESG_CHANNEL_ID_SIZE, MESG_CHANNEL_ID_ID, G_stAntSetupData.AntChannel, G_stAntSetupData.AntSerialLo, G_stAntSetupData.AntSerialHi, G_stAntSetupData.AntDeviceType, G_stAntSetupData.AntTransmissionType, CS};
   \   00000022   0xA800             ADD      R0,SP,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable7_2
   \   00000026   0xC90C             LDM      R1!,{R2,R3}
   \   00000028   0xC00C             STM      R0!,{R2,R3}
   \   0000002A   0x3908             SUBS     R1,R1,#+8
   \   0000002C   0x3808             SUBS     R0,R0,#+8
   \   0000002E   0x....             LDR.N    R0,??DataTable7_1
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000036   0x....             LDR.N    R0,??DataTable7_1
   \   00000038   0x78C0             LDRB     R0,[R0, #+3]
   \   0000003A   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000003E   0x....             LDR.N    R0,??DataTable7_1
   \   00000040   0x7900             LDRB     R0,[R0, #+4]
   \   00000042   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000046   0x....             LDR.N    R0,??DataTable7_1
   \   00000048   0x7940             LDRB     R0,[R0, #+5]
   \   0000004A   0xF88D 0x0005      STRB     R0,[SP, #+5]
   \   0000004E   0x....             LDR.N    R0,??DataTable7_1
   \   00000050   0x7980             LDRB     R0,[R0, #+6]
   \   00000052   0xF88D 0x0006      STRB     R0,[SP, #+6]
    212            u8 au8ANTSetChannelPeriod0[] = {MESG_CHANNEL_MESG_PERIOD_SIZE, MESG_CHANNEL_MESG_PERIOD_ID, G_stAntSetupData.AntChannel, G_stAntSetupData.AntChannelPeriodLo, G_stAntSetupData.AntChannelPeriodHi, CS};
   \   00000056   0xA802             ADD      R0,SP,#+8
   \   00000058   0x....             LDR.N    R1,??DataTable7_3
   \   0000005A   0xC90C             LDM      R1!,{R2,R3}
   \   0000005C   0xC00C             STM      R0!,{R2,R3}
   \   0000005E   0x3908             SUBS     R1,R1,#+8
   \   00000060   0x3808             SUBS     R0,R0,#+8
   \   00000062   0x....             LDR.N    R0,??DataTable7_1
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0xF88D 0x000A      STRB     R0,[SP, #+10]
   \   0000006A   0x....             LDR.N    R0,??DataTable7_1
   \   0000006C   0x79C0             LDRB     R0,[R0, #+7]
   \   0000006E   0xF88D 0x000B      STRB     R0,[SP, #+11]
   \   00000072   0x....             LDR.N    R0,??DataTable7_1
   \   00000074   0x7A00             LDRB     R0,[R0, #+8]
   \   00000076   0xF88D 0x000C      STRB     R0,[SP, #+12]
    213            u8 au8ANTSetChannelRFFreq0[] = {MESG_CHANNEL_RADIO_FREQ_SIZE, MESG_CHANNEL_RADIO_FREQ_ID, G_stAntSetupData.AntChannel, G_stAntSetupData.AntFrequency, CS};           
   \   0000007A   0xA808             ADD      R0,SP,#+32
   \   0000007C   0x....             LDR.N    R1,??DataTable7_4
   \   0000007E   0xC90C             LDM      R1!,{R2,R3}
   \   00000080   0xC00C             STM      R0!,{R2,R3}
   \   00000082   0x3908             SUBS     R1,R1,#+8
   \   00000084   0x3808             SUBS     R0,R0,#+8
   \   00000086   0x....             LDR.N    R0,??DataTable7_1
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0xF88D 0x0022      STRB     R0,[SP, #+34]
   \   0000008E   0x....             LDR.N    R0,??DataTable7_1
   \   00000090   0x7A40             LDRB     R0,[R0, #+9]
   \   00000092   0xF88D 0x0023      STRB     R0,[SP, #+35]
    214            u8 au8ANTSetChannelPower0[]  = {MESG_RADIO_TX_POWER_SIZE, MESG_RADIO_TX_POWER_ID, G_stAntSetupData.AntChannel, G_stAntSetupData.AntTxPower, CS};        
   \   00000096   0xA806             ADD      R0,SP,#+24
   \   00000098   0x....             LDR.N    R1,??DataTable7_5
   \   0000009A   0xC90C             LDM      R1!,{R2,R3}
   \   0000009C   0xC00C             STM      R0!,{R2,R3}
   \   0000009E   0x3908             SUBS     R1,R1,#+8
   \   000000A0   0x3808             SUBS     R0,R0,#+8
   \   000000A2   0x....             LDR.N    R0,??DataTable7_1
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0xF88D 0x001A      STRB     R0,[SP, #+26]
   \   000000AA   0x....             LDR.N    R0,??DataTable7_1
   \   000000AC   0x7A80             LDRB     R0,[R0, #+10]
   \   000000AE   0xF88D 0x001B      STRB     R0,[SP, #+27]
    215           
    216            u8 u8ErrorCount = 0;	
   \   000000B2   0x2500             MOVS     R5,#+0
    217          
    218            G_u32AntFlags &= ~_ANT_FLAGS_CMD_ERROR;
   \   000000B4   0x....             LDR.N    R0,??DataTable7_6
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF030 0x0002      BICS     R0,R0,#0x2
   \   000000BC   0x....             LDR.N    R1,??DataTable7_6
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    219          
    220            /* Adjust the channel type if configuration for a slave device */
    221            if(!bMaster_)
   \   000000C0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C2   0x2C00             CMP      R4,#+0
   \   000000C4   0xD105             BNE.N    ??AntChannelConfig_0
    222            {
    223              au8ANTAssignChannel0[3] = CHANNEL_TYPE_SLAVE;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF88D 0x0013      STRB     R0,[SP, #+19]
    224              G_stAntSetupData.AntChannelType = CHANNEL_TYPE_SLAVE;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x....             LDR.N    R1,??DataTable7_1
   \   000000D0   0x7048             STRB     R0,[R1, #+1]
    225            }
    226            
    227            /* Assign the channel */
    228            au8ANTAssignChannel0[5] = AntCalculateTxChecksum(au8ANTAssignChannel0);
   \                     ??AntChannelConfig_0: (+1)
   \   000000D2   0xA804             ADD      R0,SP,#+16
   \   000000D4   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000D8   0xF88D 0x0015      STRB     R0,[SP, #+21]
    229            AntTxMessage(au8ANTAssignChannel0);
   \   000000DC   0xA804             ADD      R0,SP,#+16
   \   000000DE   0x.... 0x....      BL       AntTxMessage
    230            u8ErrorCount += AntExpectResponse(MESG_ASSIGN_CHANNEL_ID, ANT_MSG_TIMEOUT_MS);
   \   000000E2   0xF44F 0x717A      MOV      R1,#+1000
   \   000000E6   0x2042             MOVS     R0,#+66
   \   000000E8   0x.... 0x....      BL       AntExpectResponse
   \   000000EC   0x1940             ADDS     R0,R0,R5
   \   000000EE   0x0005             MOVS     R5,R0
    231          
    232            /* Assign the channel ID */
    233            au8ANTSetChannelID0[7] = AntCalculateTxChecksum(au8ANTSetChannelID0);
   \   000000F0   0xA800             ADD      R0,SP,#+0
   \   000000F2   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000F6   0xF88D 0x0007      STRB     R0,[SP, #+7]
    234            AntTxMessage(au8ANTSetChannelID0);
   \   000000FA   0xA800             ADD      R0,SP,#+0
   \   000000FC   0x.... 0x....      BL       AntTxMessage
    235            u8ErrorCount += AntExpectResponse(MESG_CHANNEL_ID_ID, ANT_MSG_TIMEOUT_MS);
   \   00000100   0xF44F 0x717A      MOV      R1,#+1000
   \   00000104   0x2051             MOVS     R0,#+81
   \   00000106   0x.... 0x....      BL       AntExpectResponse
   \   0000010A   0x1940             ADDS     R0,R0,R5
   \   0000010C   0x0005             MOVS     R5,R0
    236              
    237            /* Assign the channel period */
    238            au8ANTSetChannelPeriod0[5] = AntCalculateTxChecksum(au8ANTSetChannelPeriod0);
   \   0000010E   0xA802             ADD      R0,SP,#+8
   \   00000110   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000114   0xF88D 0x000D      STRB     R0,[SP, #+13]
    239            AntTxMessage(au8ANTSetChannelPeriod0);
   \   00000118   0xA802             ADD      R0,SP,#+8
   \   0000011A   0x.... 0x....      BL       AntTxMessage
    240            u8ErrorCount += AntExpectResponse(MESG_CHANNEL_MESG_PERIOD_ID, ANT_MSG_TIMEOUT_MS);
   \   0000011E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000122   0x2043             MOVS     R0,#+67
   \   00000124   0x.... 0x....      BL       AntExpectResponse
   \   00000128   0x1940             ADDS     R0,R0,R5
   \   0000012A   0x0005             MOVS     R5,R0
    241              
    242            /* Assign the channel frequency */
    243            au8ANTSetChannelRFFreq0[4] = AntCalculateTxChecksum(au8ANTSetChannelRFFreq0);
   \   0000012C   0xA808             ADD      R0,SP,#+32
   \   0000012E   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000132   0xF88D 0x0024      STRB     R0,[SP, #+36]
    244            AntTxMessage(au8ANTSetChannelRFFreq0);
   \   00000136   0xA808             ADD      R0,SP,#+32
   \   00000138   0x.... 0x....      BL       AntTxMessage
    245            u8ErrorCount += AntExpectResponse(MESG_CHANNEL_RADIO_FREQ_ID, ANT_MSG_TIMEOUT_MS);
   \   0000013C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000140   0x2045             MOVS     R0,#+69
   \   00000142   0x.... 0x....      BL       AntExpectResponse
   \   00000146   0x1940             ADDS     R0,R0,R5
   \   00000148   0x0005             MOVS     R5,R0
    246          
    247            /* Assign the channel power */
    248            au8ANTSetChannelPower0[4] = AntCalculateTxChecksum(au8ANTSetChannelPower0);
   \   0000014A   0xA806             ADD      R0,SP,#+24
   \   0000014C   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000150   0xF88D 0x001C      STRB     R0,[SP, #+28]
    249            AntTxMessage(au8ANTSetChannelPower0);
   \   00000154   0xA806             ADD      R0,SP,#+24
   \   00000156   0x.... 0x....      BL       AntTxMessage
    250            u8ErrorCount += AntExpectResponse(MESG_RADIO_TX_POWER_ID, ANT_MSG_TIMEOUT_MS);
   \   0000015A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000015E   0x2047             MOVS     R0,#+71
   \   00000160   0x.... 0x....      BL       AntExpectResponse
   \   00000164   0x1940             ADDS     R0,R0,R5
   \   00000166   0x0005             MOVS     R5,R0
    251            
    252            /* If any errors were collected, clear the ANT_GOOD flag */ 
    253            /* Announce channel status on the debug port */
    254            DebugPrintf(G_au8AntMessageSetup);
   \   00000168   0x....             LDR.N    R0,??DataTable7_7
   \   0000016A   0x.... 0x....      BL       DebugPrintf
    255            if(u8ErrorCount)
   \   0000016E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000170   0x2D00             CMP      R5,#+0
   \   00000172   0xD00A             BEQ.N    ??AntChannelConfig_1
    256            {
    257              G_u32SystemFlags &= ~_APPLICATION_FLAGS_ANT;  
   \   00000174   0x....             LDR.N    R0,??DataTable7_8
   \   00000176   0x6800             LDR      R0,[R0, #+0]
   \   00000178   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000017C   0x....             LDR.N    R1,??DataTable7_8
   \   0000017E   0x6008             STR      R0,[R1, #+0]
    258              DebugPrintf(G_au8AntMessageFail);
   \   00000180   0x....             LDR.N    R0,??DataTable7_9
   \   00000182   0x.... 0x....      BL       DebugPrintf
    259              return(FALSE);
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0xE009             B.N      ??AntChannelConfig_2
    260            }
    261            else
    262            {
    263              DebugPrintf(G_au8AntMessageOk);
   \                     ??AntChannelConfig_1: (+1)
   \   0000018A   0x....             LDR.N    R0,??DataTable7_10
   \   0000018C   0x.... 0x....      BL       DebugPrintf
    264              G_u32AntFlags |= _ANT_FLAGS_CHANNEL_CONFIGURED;
   \   00000190   0x....             LDR.N    R0,??DataTable7_6
   \   00000192   0x6800             LDR      R0,[R0, #+0]
   \   00000194   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   00000198   0x....             LDR.N    R1,??DataTable7_6
   \   0000019A   0x6008             STR      R0,[R1, #+0]
    265              return(TRUE);
   \   0000019C   0x2001             MOVS     R0,#+1
   \                     ??AntChannelConfig_2: (+1)
   \   0000019E   0xB00B             ADD      SP,SP,#+44
   \   000001A0   0xBD30             POP      {R4,R5,PC}       ;; return
    266            }
    267          
    268          } /* end AntChannelConfig() */
    269          
    270          
    271          /*------------------------------------------------------------------------------
    272          Function: AntOpenChannel
    273          
    274          Description:
    275          Queues the Open Channel message on the configured ANT channel.  This does not actually indicate
    276          that the channel has been opened successfully -- the calling task must monitor _ANT_FLAGS_CHANNEL_OPEN
    277          to determine if channel opens successfully.
    278            
    279          Requires:
    280            - ANT channel is correctly configured.
    281          
    282          Promises:
    283            - If channel open message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    284            - Otherwise returns FALSE
    285           
    286          */

   \                                 In section .text, align 2, keep-with-next
    287          bool AntOpenChannel(void)
    288          {
   \                     AntOpenChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    289            u8 au8AntOpenChannel[] = {MESG_OPEN_CHANNEL_SIZE, MESG_OPEN_CHANNEL_ID, G_stAntSetupData.AntChannel, CS};
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable7_11
   \   00000006   0x680A             LDR      R2,[R1, #0]
   \   00000008   0x6002             STR      R2,[R0, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable7_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    290          
    291            /* Update the checksum value and queue the open channel message */
    292            au8AntOpenChannel[3] = AntCalculateTxChecksum(au8AntOpenChannel);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    293            G_u32AntFlags |= _ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   0000001C   0x....             LDR.N    R0,??DataTable7_6
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   00000024   0x....             LDR.N    R1,??DataTable7_6
   \   00000026   0x6008             STR      R0,[R1, #+0]
    294           
    295            return( AntQueueOutgoingMessage(au8AntOpenChannel) );
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   0000002E   0xBD02             POP      {R1,PC}          ;; return
    296            
    297          } /* end AntOpenChannel() */
    298          
    299          
    300          /*------------------------------------------------------------------------------
    301          Function: AntCloseChannel
    302          
    303          Description:
    304          Requests that an ANT channel is closed.  Issuing MESG_CLOSE_CHANNEL_ID does not
    305          guarantee that the channel closes, and ANT response to this message does not
    306          indicate that the channel is closed (a seperate message will be sent when the 
    307          channel actually closes which usually happens on the next ANT message period).
    308            
    309          Requires:
    310            - ANT channel is correctly configured and should be open.
    311          
    312          Promises:
    313            - If channel close message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    314            - Otherwise returns FALSE
    315          */

   \                                 In section .text, align 2, keep-with-next
    316          bool AntCloseChannel(void)
    317          {
   \                     AntCloseChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    318            u8 au8AntCloseChannel[] = {MESG_CLOSE_CHANNEL_SIZE, MESG_CLOSE_CHANNEL_ID, G_stAntSetupData.AntChannel, CS};
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable7_12
   \   00000006   0x680A             LDR      R2,[R1, #0]
   \   00000008   0x6002             STR      R2,[R0, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable7_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    319          
    320            /* Update the checksum value and queue the close channel message*/
    321            au8AntCloseChannel[3] = AntCalculateTxChecksum(au8AntCloseChannel);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    322            G_u32AntFlags |= _ANT_FLAGS_CHANNEL_CLOSE_PENDING;
   \   0000001C   0x....             LDR.N    R0,??DataTable7_6
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   00000024   0x....             LDR.N    R1,??DataTable7_6
   \   00000026   0x6008             STR      R0,[R1, #+0]
    323            
    324            return( AntQueueOutgoingMessage(au8AntCloseChannel) );
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   0000002E   0xBD02             POP      {R1,PC}          ;; return
    325          
    326          } /* end AntCloseChannel() */
    327          
    328          
    329          /*------------------------------------------------------------------------------
    330          Function: AntUnassignChannel
    331          
    332          Description:
    333          Queues message to unassigns the current ANT channel so it can be reconfigured.
    334            
    335          Requires:
    336            - ANT channel is closed
    337          
    338          Promises:
    339            - ANT channel unassign message is queued; application should monitor AntRadioStatus()
    340          */

   \                                 In section .text, align 2, keep-with-next
    341          bool AntUnassignChannel(void)
    342          {
   \                     AntUnassignChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    343            u8 au8AntUnassignChannel[] = {MESG_UNASSIGN_CHANNEL_SIZE, MESG_UNASSIGN_CHANNEL_ID, G_stAntSetupData.AntChannel, CS};
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable7_13
   \   00000006   0x680A             LDR      R2,[R1, #0]
   \   00000008   0x6002             STR      R2,[R0, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable7_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    344          
    345            /* Update checksum and queue the unassign channel message */
    346            au8AntUnassignChannel[3] = AntCalculateTxChecksum(au8AntUnassignChannel);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    347            G_u32AntFlags &= ~_ANT_FLAGS_CHANNEL_CONFIGURED;
   \   0000001C   0x....             LDR.N    R0,??DataTable7_6
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   00000024   0x....             LDR.N    R1,??DataTable7_6
   \   00000026   0x6008             STR      R0,[R1, #+0]
    348            return( AntQueueOutgoingMessage(au8AntUnassignChannel) );
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   0000002E   0xBD02             POP      {R1,PC}          ;; return
    349          
    350          } /* end AntUnassignChannel() */
    351          
    352          
    353          /*------------------------------------------------------------------------------
    354          Function: AntRadioStatus
    355          
    356          Description:
    357          Returns the current radio status to the application.
    358            
    359          Requires:
    360            - G_u32AntFlags are up to date
    361          
    362          Promises:
    363            - Returns one of {ANT_UNCONFIGURED, ANT_CLOSING, ANT_OPEN, ANT_CLOSED}
    364          
    365          */

   \                                 In section .text, align 2, keep-with-next
    366          AntChannelStatusType AntRadioStatus(void)
    367          {
    368            if(G_u32AntFlags & _ANT_FLAGS_CHANNEL_CONFIGURED)
   \                     AntRadioStatus: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7_6
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0380             LSLS     R0,R0,#+14
   \   00000006   0xD50D             BPL.N    ??AntRadioStatus_0
    369            {
    370              if(G_u32AntFlags & _ANT_FLAGS_CHANNEL_CLOSE_PENDING)
   \   00000008   0x....             LDR.N    R0,??DataTable7_6
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x02C0             LSLS     R0,R0,#+11
   \   0000000E   0xD501             BPL.N    ??AntRadioStatus_1
    371              {
    372                return ANT_CLOSING;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0xE008             B.N      ??AntRadioStatus_2
    373              }
    374              else if(G_u32AntFlags & _ANT_FLAGS_CHANNEL_OPEN)
   \                     ??AntRadioStatus_1: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable7_6
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0300             LSLS     R0,R0,#+12
   \   0000001A   0xD501             BPL.N    ??AntRadioStatus_3
    375              {
    376                return ANT_OPEN;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xE002             B.N      ??AntRadioStatus_2
    377              }
    378              else
    379              {
    380                return ANT_CLOSED;
   \                     ??AntRadioStatus_3: (+1)
   \   00000020   0x2005             MOVS     R0,#+5
   \   00000022   0xE000             B.N      ??AntRadioStatus_2
    381              }
    382            }
    383            else
    384            {
    385              return ANT_UNCONFIGURED;
   \                     ??AntRadioStatus_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??AntRadioStatus_2: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    386            }
    387            
    388            
    389          } /* end AntRadioStatus () */
    390          
    391          
    392          /***ANT DATA FUNCTIONS***/
    393          
    394          /*-----------------------------------------------------------------------------/
    395          Function: AntQueueBroadcastMessage
    396          
    397          Description:
    398          Adds an ANT broadcast message to the outgoing messages list.  
    399          
    400          Requires:
    401            - pu8Data_ is a pointer to the first element of an array of 8 data bytes
    402          
    403          Promises:
    404            - Returns TRUE if the entry is added successfully.
    405          */

   \                                 In section .text, align 2, keep-with-next
    406          bool AntQueueBroadcastMessage(u8 *pu8Data_)
    407          {
   \                     AntQueueBroadcastMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    408            static u8 au8AntBroadcastDataMessage[] = {MESG_DATA_SIZE, MESG_BROADCAST_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
    409          
    410            /* Update the dynamic message data */
    411            au8AntBroadcastDataMessage[2] = G_stAntSetupData.AntChannel;
   \   00000004   0x....             LDR.N    R0,??DataTable7_1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable7_14
   \   0000000A   0x7088             STRB     R0,[R1, #+2]
    412            for(u8 i = 0; i < ANT_DATA_BYTES; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??AntQueueBroadcastMessage_0: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xDA07             BGE.N    ??AntQueueBroadcastMessage_1
    413            {
    414              au8AntBroadcastDataMessage[3 + i] = *(pu8Data_ + i);
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x5D01             LDRB     R1,[R0, R4]
   \   00000018   0x....             LDR.N    R2,??DataTable7_14
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x1882             ADDS     R2,R0,R2
   \   0000001E   0x70D1             STRB     R1,[R2, #+3]
    415            }
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE7F4             B.N      ??AntQueueBroadcastMessage_0
    416           
    417            au8AntBroadcastDataMessage[11] = AntCalculateTxChecksum(au8AntBroadcastDataMessage);
   \                     ??AntQueueBroadcastMessage_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable7_14
   \   00000026   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000002A   0x....             LDR.N    R1,??DataTable7_14
   \   0000002C   0x72C8             STRB     R0,[R1, #+11]
    418            return( AntQueueOutgoingMessage(au8AntBroadcastDataMessage) );
   \   0000002E   0x....             LDR.N    R0,??DataTable7_14
   \   00000030   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    419          
    420          } /* end AntQueueBroadcastMessage */

   \                                 In section .data, align 4
   \                     ??au8AntBroadcastDataMessage:
   \   00000000   0x09 0x4E          DC8 9, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    421          
    422          
    423          /*-----------------------------------------------------------------------------/
    424          Function: AntQueueAcknowledgedMessage
    425          
    426          Description:
    427          Adds an ANT Acknowledged message to the outgoing messages list.  
    428          
    429          Requires:
    430            - pu8Data_ is a pointer to the first element of an array of 8 data bytes
    431          
    432          Promises:
    433            - Returns TRUE if the entry is added successfully.
    434          */

   \                                 In section .text, align 2, keep-with-next
    435          bool AntQueueAcknowledgedMessage(u8 *pu8Data_)
    436          {
   \                     AntQueueAcknowledgedMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    437            static u8 au8AntAckDataMessage[] = {MESG_DATA_SIZE, MESG_ACKNOWLEDGED_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
    438          
    439            /* Update the dynamic message data */
    440            au8AntAckDataMessage[2] = G_stAntSetupData.AntChannel;
   \   00000004   0x....             LDR.N    R0,??DataTable7_1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable7_15
   \   0000000A   0x7088             STRB     R0,[R1, #+2]
    441            for(u8 i = 0; i < ANT_DATA_BYTES; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??AntQueueAcknowledgedMessage_0: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xDA07             BGE.N    ??AntQueueAcknowledgedMessage_1
    442            {
    443              au8AntAckDataMessage[3 + i] = *(pu8Data_ + i);
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x5D01             LDRB     R1,[R0, R4]
   \   00000018   0x....             LDR.N    R2,??DataTable7_15
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x1882             ADDS     R2,R0,R2
   \   0000001E   0x70D1             STRB     R1,[R2, #+3]
    444            }
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE7F4             B.N      ??AntQueueAcknowledgedMessage_0
    445           
    446            au8AntAckDataMessage[11] = AntCalculateTxChecksum(au8AntAckDataMessage);
   \                     ??AntQueueAcknowledgedMessage_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable7_15
   \   00000026   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000002A   0x....             LDR.N    R1,??DataTable7_15
   \   0000002C   0x72C8             STRB     R0,[R1, #+11]
    447            return( AntQueueOutgoingMessage(au8AntAckDataMessage) );
   \   0000002E   0x....             LDR.N    R0,??DataTable7_15
   \   00000030   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    448           
    449          } /* end AntQueueAcknowledgedMessage */

   \                                 In section .data, align 4
   \                     ??au8AntAckDataMessage:
   \   00000000   0x09 0x4F          DC8 9, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    450          
    451          /*-----------------------------------------------------------------------------/
    452          Function: AntReadData
    453          
    454          Description:
    455          Checks for any new messages from ANT. The messages are of type AntLocalMessageType
    456          so the application must decide what the data means.
    457          
    458          Requires:
    459            - 
    460          
    461          Promises:
    462            - Returns TRUE if there is new data; G_asAntApiCurrentData holds the message type and data message
    463            - Returns FALSE if no new data is present (G_asAntApiCurrentData unchanged)
    464          */

   \                                 In section .text, align 2, keep-with-next
    465          bool AntReadData(void)
    466          {
   \                     AntReadData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    467            u8 *pu8Parser;
    468            
    469            if(G_sAntApplicationMsgList != NULL)
   \   00000002   0x....             LDR.N    R0,??DataTable7_16
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD01D             BEQ.N    ??AntReadData_0
    470            {
    471              G_u32AntApiCurrentDataTimeStamp = G_sAntApplicationMsgList->u32TimeStamp;
   \   0000000A   0x....             LDR.N    R0,??DataTable7_16
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x....             LDR.N    R1,??DataTable7_17
   \   00000012   0x6008             STR      R0,[R1, #+0]
    472              G_eAntApiCurrentMessageClass = G_sAntApplicationMsgList->eMessageType;
   \   00000014   0x....             LDR.N    R0,??DataTable7_16
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x7900             LDRB     R0,[R0, #+4]
   \   0000001A   0x....             LDR.N    R1,??DataTable7_18
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    473              pu8Parser = &(G_sAntApplicationMsgList->au8MessageData[0]);
   \   0000001E   0x....             LDR.N    R0,??DataTable7_16
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF200 0x0005      ADDW     R0,R0,#+5
   \   00000026   0x0004             MOVS     R4,R0
    474              for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??AntReadData_1: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x2808             CMP      R0,#+8
   \   0000002E   0xDA06             BGE.N    ??AntReadData_2
    475              {
    476                G_au8AntApiCurrentData[i] = *(pu8Parser + i);
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x5D01             LDRB     R1,[R0, R4]
   \   00000034   0x....             LDR.N    R2,??DataTable7_19
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x5481             STRB     R1,[R0, R2]
    477              }
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0xE7F5             B.N      ??AntReadData_1
    478              AntDeQueueApplicationMessage();
   \                     ??AntReadData_2: (+1)
   \   0000003E   0x.... 0x....      BL       AntDeQueueApplicationMessage
    479              
    480              return TRUE;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE000             B.N      ??AntReadData_3
    481            }
    482            
    483            /* Otherwise return FALSE and do not touch the current data array */
    484            return FALSE;
   \                     ??AntReadData_0: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??AntReadData_3: (+1)
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    485            
    486          } /* end AntReadData() */

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     G_stAntSetupData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     G_au8AntMessageSetup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     G_au8AntMessageFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x........         DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x........         DC32     ??au8AntBroadcastDataMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x........         DC32     ??au8AntAckDataMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_16:
   \   00000000   0x........         DC32     G_sAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_17:
   \   00000000   0x........         DC32     G_u32AntApiCurrentDataTimeStamp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_18:
   \   00000000   0x........         DC32     G_eAntApiCurrentMessageClass

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_19:
   \   00000000   0x........         DC32     G_au8AntApiCurrentData

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x03 0x42          DC8 3, 66, 0, 16, 0, 0, 0, 0
   \              0x00 0x10    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x05 0x51          DC8 5, 81, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x03 0x43          DC8 3, 67, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x02 0x45          DC8 2, 69, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x02 0x47          DC8 2, 71, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x01 0x4B          DC8 1, 75, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x01 0x4C          DC8 1, 76, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x01 0x41          DC8 1, 65, 0, 0
   \              0x00 0x00    
    487          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   AntChannelConfig
        56   -> AntCalculateTxChecksum
        56   -> AntExpectResponse
        56   -> AntTxMessage
        56   -> DebugPrintf
       8   AntCloseChannel
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
       8   AntOpenChannel
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
       8   AntQueueAcknowledgedMessage
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
       8   AntQueueBroadcastMessage
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
       0   AntRadioStatus
       8   AntReadData
         8   -> AntDeQueueApplicationMessage
       8   AntUnassignChannel
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_19
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       8  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
       8  ?_4
       4  ?_5
       4  ?_6
       4  ?_7
     418  AntChannelConfig
      48  AntCloseChannel
      48  AntOpenChannel
      54  AntQueueAcknowledgedMessage
      54  AntQueueBroadcastMessage
      40  AntRadioStatus
      74  AntReadData
      48  AntUnassignChannel
       8  G_au8AntApiCurrentData
       1  G_eAntApiCurrentMessageClass
       4  G_u32AntApiCurrentDataTimeStamp
      12  au8AntAckDataMessage
      12  au8AntBroadcastDataMessage

 
  13 bytes in section .bss
  24 bytes in section .data
  52 bytes in section .rodata
 864 bytes in section .text
 
 864 bytes of CODE  memory
  52 bytes of CONST memory
  37 bytes of DATA  memory

Errors: none
Warnings: none
