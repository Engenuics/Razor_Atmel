###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        04/Mar/2016  10:02:55
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\leds.c
#    Command line =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\leds.c
#        -D MPGL2 -D MPG2 --preprocess=cl
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -lC
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -o
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\bsp\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\drivers\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\libraries\captouch\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\Debug\List\leds.lst
#    Object file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl2\iar_7_20_1\Debug\Obj\leds.o
#
###############################################################################

D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\leds.c
      1          /***********************************************************************************************************************
      2          File: leds.c                                                                
      3          
      4          Description:
      5          LED driver that provides on, off, toggle, blink and PWM functionality.
      6          The basic on/off/toggle functionality is applied directly to the LEDs.
      7          Blinking and PWMing of LEDs rely on the MPG operating system to provide timing at
      8          regular 1ms calls to LedUpdate().
      9          
     10          ------------------------------------------------------------------------------------------------------------------------
     11          API:
     12          LedNumberType: 
     13            MPGL1     - WHITE, PURPLE, BLUE, CYAN, GREEN, YELLOW, ORANGE, RED, LCD_RED, LCD_GREEN, LCD_BLUE
     14            MPGL2_R01 - BLUE, GREEN, YELLOW, RED, LCD_BL
     15            MPGL2     - BLUE0, BLUE1, BLUE2, BLUE3, GREEN0, GREEN1, GREEN2, GREEN3, RED0, RED1, RED2, RED3, LCD_BL
     16          
     17          LedRateType: LED_0_5HZ, LED_1HZ, LED_2HZ, LED_4HZ, LED_8HZ, 
     18                       LED_PWM_0, LED_PWM_5, ..., LED_PWM_100
     19          *Note that PWM values in LedRateType are continuous, thus stepping a variable of LedRateType by one will select the next 
     20          PWM level. However, decrementing past LED_PWM_0 or incrementing past LED_PWM_100 is undefined.
     21          
     22          
     23          Public:
     24          void LedOn(LedNumberType eLED_)
     25          Turn the specified LED on. LED response is immediate.
     26          e.g. LedOn(BLUE);
     27          
     28          void LedOff(LedNumberType eLED_)
     29          Turn the specified LED off. LED response is immediate.
     30          e.g. LedOff(BLUE);
     31          
     32          void LedToggle(LedNumberType eLED_)
     33          Toggle the specified LED.  LED response is immediate. LED must be in NORMAL mode.
     34          e.g. LedToggle(BLUE);
     35          
     36          void LedPWM(LedNumberType eLED_, LedRateType ePwmRate_)
     37          Sets up an LED for PWM mode.  PWM mode requires the main loop to be running at 1ms period.
     38          e.g. LedPWM(BLUE, LED_PWM_5);
     39          
     40          void LedBlink(LedNumberType eLED_, LedRateType eBlinkRate_)
     41          Sets an LED to BLINK mode.  BLINK mode requires the main loop to be running at 1ms period.
     42          e.g. LedBlink(BLUE, LED_1HZ);
     43          
     44          Protected:
     45          void LedInitialize(void)
     46          Test all LEDs and initialize to OFF state.
     47          
     48          DISCLAIMER: THIS CODE IS PROVIDED WITHOUT ANY WARRANTY OR GUARANTEES.  USERS MAY
     49          USE THIS CODE FOR DEVELOPMENT AND EXAMPLE PURPOSES ONLY.  ENGENUICS TECHNOLOGIES
     50          INCORPORATED IS NOT RESPONSIBLE FOR ANY ERRORS, OMISSIONS, OR DAMAGES THAT COULD
     51          RESULT FROM USING THIS FIRMWARE IN WHOLE OR IN PART.
     52          ***********************************************************************************************************************/
     53          
     54          #include "configuration.h"
     55          
     56          
     57          /***********************************************************************************************************************
     58          Global variable definitions with scope across entire project.
     59          All Global variable names shall start with "G_xxLed"
     60          ***********************************************************************************************************************/
     61          /*--------------------------------------------------------------------------------------------------------------------*/
     62          /* New variables (all shall start with G_xxLed*/
     63          
     64          
     65          /*--------------------------------------------------------------------------------------------------------------------*/
     66          /* External global variables defined in other files (must indicate which file they are defined in) */
     67          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     68          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     69          
     70          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     71          
     72          
     73          /***********************************************************************************************************************
     74          Global variable definitions with scope limited to this local application.
     75          Variable names shall start with "Led_" and be declared as static.
     76          ***********************************************************************************************************************/
     77          
     78          /************ %LED% EDIT BOARD-SPECIFIC GPIO DEFINITIONS BELOW ***************/
     79          
     80          #ifdef MPGL1
     81          /* LED locations: order must correspond to the order set in LedNumberType in the header file. */
     82          static u32 Led_au32BitPositions[] = {PB_13_LED_WHT, PB_14_LED_PRP, PB_18_LED_BLU, PB_16_LED_CYN,
     83                                               PB_19_LED_GRN, PB_17_LED_YLW, PB_15_LED_ORG, PB_20_LED_RED,
     84                                               PB_10_LCD_BL_RED, PB_11_LCD_BL_GRN, PB_12_LCD_BL_BLU};
     85          
     86          /* Control array for all LEDs in system initialized for LedInitialize().  Array values correspond to LedConfigType fields: 
     87               eMode         eRate      u16Count       eCurrentDuty     eActiveState     ePort      LedNumberType */
     88          static LedConfigType Leds_asLedArray[TOTAL_LEDS] = 
     89          {{LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* WHITE      */
     90           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* PURPLE     */
     91           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* BLUE       */
     92           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* CYAN       */
     93           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* GREEN      */
     94           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* YELLOW     */
     95           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* ORANGE     */
     96           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED        */
     97           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* LCD_RED    */
     98           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* LCD_GREEN  */
     99           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}  /* LCD_BLUE   */
    100          };   
    101          #endif /* MPGL1 */
    102          
    103          #ifdef MPGL2
    104          
    105          #ifdef MPGL2_R01
    106          /* LED locations: order must correspond to the order set in LedNumberType in the header file. */
    107          static u32 Led_au32BitPositions[] = {PB_18_LED_BLU, PB_19_LED_GRN, PB_17_LED_YLW, PB_20_LED_RED, PB_11_LCD_BL};
    108          
    109          /* Control array for all LEDs in system initialized for LedInitialize().  Array values correspond to LedConfigType fields: 
    110               eMode         eRate      u16Count       eCurrentDuty     eActiveState     ePort      LedNumberType */
    111          static LedConfigType Leds_asLedArray[TOTAL_LEDS] = 
    112          {{LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* BLUE       */
    113           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* GREEN      */
    114           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* YELLOW     */
    115           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED        */
    116           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* LCD_BL     */
    117          };   
    118          #else
    119          /* LED locations: order must correspond to the order set in LedNumberType in the header file. */

   \                                 In section .data, align 4
    120          static u32 Led_au32BitPositions[] = {PB_20_LED0_RED, PB_17_LED1_RED, PB_19_LED2_RED, PB_18_LED3_RED,
   \                     Led_au32BitPositions:
   \   00000000   0x00100000         DC32 1048576, 131072, 524288, 262144, 536870912, 4, 67108864, 128, 2
   \              0x00020000   
   \              0x00080000   
   \              0x00040000   
   \              0x20000000   
   \              0x00000004   
   \              0x04000000   
   \              0x00000080   
   \              0x00000002   
   \   00000024   0x00002000         DC32 8192, 64, 256, 32
   \              0x00000040   
   \              0x00000100   
   \              0x00000020   
    121                                               PA_29_LED0_GRN, PB_02_LED1_GRN, PA_26_LED2_GRN, PA_07_LED3_GRN,
    122                                               PB_01_LED0_BLU, PB_13_LED1_BLU, PA_06_LED2_BLU, PA_08_LED3_BLU,
    123                                               PB_05_LCD_BL};
    124          
    125          /* Control array for all LEDs in system initialized for LedInitialize().  Array values correspond to LedConfigType fields: 
    126               eMode         eRate      u16Count       eCurrentDuty     eActiveState     ePort      LedNumberType */

   \                                 In section .data, align 4
    127          static LedConfigType Leds_asLedArray[TOTAL_LEDS] = 
   \                     Leds_asLedArray:
   \   00000000   0x01 0x00          DC8 1, 0
   \   00000002   0x0014 0x0014      DC16 20, 20
   \   00000006   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   0000000C   0x0014 0x0014      DC16 20, 20
   \   00000010   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   00000016   0x0014 0x0014      DC16 20, 20
   \   0000001A   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   00000020   0x0014 0x0014      DC16 20, 20
   \   00000024   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   0000002A   0x0014 0x0014      DC16 20, 20
   \   0000002E   0x01 0x01          DC8 1, 1, 0, 0, 1, 0
   \              0x00 0x00    
   \              0x01 0x00    
   \   00000034   0x0014 0x0014      DC16 20, 20
   \   00000038   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   0000003E   0x0014 0x0014      DC16 20, 20
   \   00000042   0x01 0x01          DC8 1, 1, 0, 0, 1, 0
   \              0x00 0x00    
   \              0x01 0x00    
   \   00000048   0x0014 0x0014      DC16 20, 20
   \   0000004C   0x01 0x01          DC8 1, 1, 0, 0, 1, 0
   \              0x00 0x00    
   \              0x01 0x00    
   \   00000052   0x0014 0x0014      DC16 20, 20
   \   00000056   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   0000005C   0x0014 0x0014      DC16 20, 20
   \   00000060   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   00000066   0x0014 0x0014      DC16 20, 20
   \   0000006A   0x01 0x01          DC8 1, 1, 0, 0, 1, 0
   \              0x00 0x00    
   \              0x01 0x00    
   \   00000070   0x0014 0x0014      DC16 20, 20
   \   00000074   0x01 0x01          DC8 1, 1, 0, 0, 1, 0
   \              0x00 0x00    
   \              0x01 0x00    
   \   0000007A   0x0014 0x0014      DC16 20, 20
   \   0000007E   0x01 0x01          DC8 1, 1, 128, 0, 0, 0
   \              0x80 0x00    
   \              0x00 0x00    
    128          {{LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED0       */
    129           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED1       */
    130           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED2       */
    131           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED3       */
    132           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTA}, /* GREEN0     */
    133           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* GREEN1     */
    134           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTA}, /* GREEN2     */
    135           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTA}, /* GREEN3     */
    136           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* BLUE0      */
    137           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* BLUE1      */
    138           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTA}, /* BLUE2      */
    139           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTA}, /* BLUE3      */
    140           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* LCD_BL     */
    141          };  
    142          #endif /* MPGL2_R01 */
    143          
    144          #endif /* MPGL2 */
    145          
    146          /************ EDIT BOARD-SPECIFIC GPIO DEFINITIONS ABOVE ***************/
    147           
    148          
    149          /***********************************************************************************************************************
    150          * Function Definitions
    151          ***********************************************************************************************************************/
    152          
    153          /*--------------------------------------------------------------------------------------------------------------------*/
    154          /* Public functions */
    155          /*--------------------------------------------------------------------------------------------------------------------*/
    156          
    157          /*----------------------------------------------------------------------------------------------------------------------
    158          Function: LedOn
    159          
    160          Description:
    161          Turn the specified LED on.  Automatically takes care of the active low vs. active
    162          high LEDs.  
    163          
    164          Requires:
    165            - eLED_ is a valid LED index
    166            - Definitions in Leds_asLedArray[eLED_] are correct
    167          
    168          Promises:
    169            - Requested LED is configured to be turned on next LedUpdate()
    170            - Requested LED is always set to LED_NORMAL_MODE mode
    171          */

   \                                 In section .text, align 2, keep-with-next
    172          void LedOn(LedNumberType eLED_)
    173          {
   \                     LedOn: (+1)
   \   00000000   0xB410             PUSH     {R4}
    174            u32 *pu32SetAddress;
    175          
    176            /* Configure set and clear addresses */
    177            if(Leds_asLedArray[eLED_].eActiveState == LED_ACTIVE_HIGH)
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable6
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x230A             MOVS     R3,#+10
   \   0000000A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000000E   0x79D2             LDRB     R2,[R2, #+7]
   \   00000010   0x2A01             CMP      R2,#+1
   \   00000012   0xD10B             BNE.N    ??LedOn_0
    178            {
    179              /* Active high LEDs use SODR to turn on */
    180              pu32SetAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_SODR) + Leds_asLedArray[eLED_].ePort);
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x400e0c30
   \   00000018   0x....             LDR.N    R3,??DataTable6
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x240A             MOVS     R4,#+10
   \   0000001E   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000022   0x7A1B             LDRB     R3,[R3, #+8]
   \   00000024   0xEB12 0x0283      ADDS     R2,R2,R3, LSL #+2
   \   00000028   0x0011             MOVS     R1,R2
   \   0000002A   0xE009             B.N      ??LedOn_1
    181            }
    182            else
    183            {
    184              /* Active low LEDs use CODR to turn on */
    185              pu32SetAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_CODR) + Leds_asLedArray[eLED_].ePort);
   \                     ??LedOn_0: (+1)
   \   0000002C   0x....             LDR.N    R2,??DataTable6_2  ;; 0x400e0c34
   \   0000002E   0x....             LDR.N    R3,??DataTable6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x240A             MOVS     R4,#+10
   \   00000034   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000038   0x7A1B             LDRB     R3,[R3, #+8]
   \   0000003A   0xEB12 0x0283      ADDS     R2,R2,R3, LSL #+2
   \   0000003E   0x0011             MOVS     R1,R2
    186            }
    187            
    188            /* Turn on the LED */
    189            *pu32SetAddress = Led_au32BitPositions[(u8)eLED_];
   \                     ??LedOn_1: (+1)
   \   00000040   0x....             LDR.N    R2,??DataTable6_3
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000048   0x600A             STR      R2,[R1, #+0]
    190            
    191            /* Always set the LED back to LED_NORMAL_MODE mode */
    192          	Leds_asLedArray[(u8)eLED_].eMode = LED_NORMAL_MODE;
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x....             LDR.N    R3,??DataTable6
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x240A             MOVS     R4,#+10
   \   00000052   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000056   0x701A             STRB     R2,[R3, #+0]
    193          
    194          } /* end LedOn() */
   \   00000058   0xBC10             POP      {R4}
   \   0000005A   0x4770             BX       LR               ;; return
    195          
    196          
    197          /*----------------------------------------------------------------------------------------------------------------------
    198          Function: LedOff
    199          
    200          Description:
    201          Turn the specified LED off.  Automatically takes care of the active low vs. active
    202          high LEDs.  
    203          
    204          Requires:
    205            - eLED_ is a valid LED index
    206            - Definitions in Leds_asLedArray[eLED_] are correct
    207          
    208          Promises:
    209            - Requested LED is turned off
    210            - Requested LED is always set to LED_NORMAL_MODE mode
    211          */

   \                                 In section .text, align 2, keep-with-next
    212          void LedOff(LedNumberType eLED_)
    213          {
   \                     LedOff: (+1)
   \   00000000   0xB410             PUSH     {R4}
    214            u32 *pu32ClearAddress;
    215          
    216            /* Configure set and clear addresses */
    217            if(Leds_asLedArray[eLED_].eActiveState == LED_ACTIVE_HIGH)
   \   00000002   0x....             LDR.N    R2,??DataTable6
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x230A             MOVS     R3,#+10
   \   00000008   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000000C   0x79D2             LDRB     R2,[R2, #+7]
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xD10A             BNE.N    ??LedOff_0
    218            {
    219              /* Active high LEDs use CODR to turn off */
    220              pu32ClearAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_CODR) + Leds_asLedArray[eLED_].ePort);
   \   00000012   0x....             LDR.N    R2,??DataTable6_2  ;; 0x400e0c34
   \   00000014   0x....             LDR.N    R3,??DataTable6
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x240A             MOVS     R4,#+10
   \   0000001A   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   0000001E   0x7A1B             LDRB     R3,[R3, #+8]
   \   00000020   0xEB12 0x0283      ADDS     R2,R2,R3, LSL #+2
   \   00000024   0x0011             MOVS     R1,R2
   \   00000026   0xE009             B.N      ??LedOff_1
    221            }
    222            else
    223            {
    224              /* Active low LEDs use SODR to turn off */
    225              pu32ClearAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_SODR) + Leds_asLedArray[eLED_].ePort);
   \                     ??LedOff_0: (+1)
   \   00000028   0x....             LDR.N    R2,??DataTable6_1  ;; 0x400e0c30
   \   0000002A   0x....             LDR.N    R3,??DataTable6
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x240A             MOVS     R4,#+10
   \   00000030   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000034   0x7A1B             LDRB     R3,[R3, #+8]
   \   00000036   0xEB12 0x0283      ADDS     R2,R2,R3, LSL #+2
   \   0000003A   0x0011             MOVS     R1,R2
    226            }
    227            
    228            /* Clear the bit corresponding to eLED_ */
    229          	*pu32ClearAddress = Led_au32BitPositions[(u8)eLED_];
   \                     ??LedOff_1: (+1)
   \   0000003C   0x....             LDR.N    R2,??DataTable6_3
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000044   0x600A             STR      R2,[R1, #+0]
    230          
    231            /* Always set the LED back to LED_NORMAL_MODE mode */
    232          	Leds_asLedArray[(u8)eLED_].eMode = LED_NORMAL_MODE;
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0x....             LDR.N    R3,??DataTable6
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x240A             MOVS     R4,#+10
   \   0000004E   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000052   0x701A             STRB     R2,[R3, #+0]
    233            
    234          } /* end LedOff() */
   \   00000054   0xBC10             POP      {R4}
   \   00000056   0x4770             BX       LR               ;; return
    235          
    236          
    237          /*----------------------------------------------------------------------------------------------------------------------
    238          Function: LedToggle
    239          
    240          Description:
    241          Toggle the specified LED.
    242          
    243          Requires:
    244            - eLED_ is a valid LED index
    245            - eLED_ *should* be in LED_NORMAL_MODE
    246            - Write access to PIOx_ODSR is enabled
    247          
    248          Promises:
    249            - Requested LED is toggled if the LED is in LED_NORMAL_MODE mode
    250          */

   \                                 In section .text, align 2, keep-with-next
    251          void LedToggle(LedNumberType eLED_)
    252          {
    253            u32 *pu32Address = (u32*)(&(AT91C_BASE_PIOA->PIO_ODSR) + Leds_asLedArray[eLED_].ePort);
   \                     LedToggle: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6_4  ;; 0x400e0c38
   \   00000002   0x....             LDR.N    R2,??DataTable6
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x230A             MOVS     R3,#+10
   \   00000008   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000000C   0x7A12             LDRB     R2,[R2, #+8]
   \   0000000E   0xEB11 0x0182      ADDS     R1,R1,R2, LSL #+2
    254          
    255            *pu32Address ^= Led_au32BitPositions[ (u8)eLED_ ];
   \   00000012   0x680A             LDR      R2,[R1, #+0]
   \   00000014   0x....             LDR.N    R3,??DataTable6_3
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xF853 0x3020      LDR      R3,[R3, R0, LSL #+2]
   \   0000001C   0x405A             EORS     R2,R3,R2
   \   0000001E   0x600A             STR      R2,[R1, #+0]
    256            
    257          } /* end LedToggle() */
   \   00000020   0x4770             BX       LR               ;; return
    258          
    259          
    260          /*----------------------------------------------------------------------------------------------------------------------
    261          Function: LedPWM
    262          
    263          Description:
    264          Sets an LED to PWM mode
    265          
    266          Requires:
    267            - eLED_ is a valid LED index
    268            - ePwmRate_ is an allowed duty cycle:
    269              LED_PWM_0, LED_PWM_5, LED_PWM_10, ..., LED_PWM_95, LED_PWM_100
    270          
    271          Promises:
    272            - Requested LED is set to PWM mode at the duty cycle specified
    273          */

   \                                 In section .text, align 2, keep-with-next
    274          void LedPWM(LedNumberType eLED_, LedRateType ePwmRate_)
    275          {
   \                     LedPWM: (+1)
   \   00000000   0xB410             PUSH     {R4}
    276          	Leds_asLedArray[(u8)eLED_].eMode = LED_PWM_MODE;
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x....             LDR.N    R3,??DataTable6
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x240A             MOVS     R4,#+10
   \   0000000A   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   0000000E   0x701A             STRB     R2,[R3, #+0]
    277          	Leds_asLedArray[(u8)eLED_].eRate = ePwmRate_;
   \   00000010   0x....             LDR.N    R2,??DataTable6
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x230A             MOVS     R3,#+10
   \   00000016   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000001A   0x8051             STRH     R1,[R2, #+2]
    278          	Leds_asLedArray[(u8)eLED_].u16Count = (u16)ePwmRate_;
   \   0000001C   0x....             LDR.N    R2,??DataTable6
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x230A             MOVS     R3,#+10
   \   00000022   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000026   0x8091             STRH     R1,[R2, #+4]
    279            Leds_asLedArray[(u8)eLED_].eCurrentDuty = LED_PWM_DUTY_HIGH;
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x....             LDR.N    R3,??DataTable6
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x240A             MOVS     R4,#+10
   \   00000030   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000034   0x719A             STRB     R2,[R3, #+6]
    280          
    281          } /* end LedPWM() */
   \   00000036   0xBC10             POP      {R4}
   \   00000038   0x4770             BX       LR               ;; return
    282          
    283          
    284          /*----------------------------------------------------------------------------------------------------------------------
    285          Function: LedBlink
    286          
    287          Description:
    288          Sets an LED to BLINK mode.
    289          
    290          Requires:
    291            - eLED_ is a valid LED index
    292            - eBlinkRate_ is an allowed frequency:
    293              LED_0_5HZ, LED_1HZ, LED_2HZ, LED_4HZ, LED_8HZ
    294          
    295          Promises:
    296            - Requested LED is set to BLINK mode at the rate specified
    297          */

   \                                 In section .text, align 2, keep-with-next
    298          void LedBlink(LedNumberType eLED_, LedRateType eBlinkRate_)
    299          {
   \                     LedBlink: (+1)
   \   00000000   0xB410             PUSH     {R4}
    300          	Leds_asLedArray[(u8)eLED_].eMode = LED_BLINK_MODE;
   \   00000002   0x2202             MOVS     R2,#+2
   \   00000004   0x....             LDR.N    R3,??DataTable6
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x240A             MOVS     R4,#+10
   \   0000000A   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   0000000E   0x701A             STRB     R2,[R3, #+0]
    301          	Leds_asLedArray[(u8)eLED_].eRate = eBlinkRate_;
   \   00000010   0x....             LDR.N    R2,??DataTable6
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x230A             MOVS     R3,#+10
   \   00000016   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000001A   0x8051             STRH     R1,[R2, #+2]
    302          	Leds_asLedArray[(u8)eLED_].u16Count = eBlinkRate_;
   \   0000001C   0x....             LDR.N    R2,??DataTable6
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x230A             MOVS     R3,#+10
   \   00000022   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000026   0x8091             STRH     R1,[R2, #+4]
    303          
    304          } /* end LedBlink() */
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
    305          
    306          
    307          /*--------------------------------------------------------------------------------------------------------------------*/
    308          /* Protected functions */
    309          /*--------------------------------------------------------------------------------------------------------------------*/
    310          
    311          /*----------------------------------------------------------------------------------------------------------------------
    312          Function: LedInitialize
    313          
    314          Description:
    315          Initialization of LED system paramters and visual LED check.
    316          
    317          Requires:
    318            - G_u32SystemTime1ms ticking
    319            - All LEDs already initialized to LED_NORMAL_MODE mode ON
    320          
    321          Promises:
    322            - All LEDs in LED_NORMAL_MODE mode with OFF
    323          */

   \                                 In section .text, align 2, keep-with-next
    324          void LedInitialize(void)
    325          {
   \                     LedInitialize: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
    326            u32 u32Timer;
    327          //  u8* pu8Parser;
    328          
    329            u32 u32Buzzer1Frequency = 4000;
   \   00000006   0xF44F 0x647A      MOV      R4,#+4000
    330            u32 u32Buzzer2Frequency = 500;
   \   0000000A   0xF44F 0x75FA      MOV      R5,#+500
    331            u32 u32StepSize = (u32Buzzer1Frequency - u32Buzzer2Frequency) / 20;
   \   0000000E   0x1B60             SUBS     R0,R4,R5
   \   00000010   0x2114             MOVS     R1,#+20
   \   00000012   0xFBB0 0xF6F1      UDIV     R6,R0,R1
    332          
    333            static u8 au8LedStartupMsg[] = "LED functions ready\n\r";
    334          
    335          #if MPGL2
    336            /* Test code for checking LEDs */
    337          #if 0
    338            LedOn(RED0);
    339            LedOn(RED1);
    340            LedOn(RED2);
    341            LedOn(RED3);
    342            LedOn(BLUE0);
    343            LedOn(BLUE1);
    344            LedOn(BLUE2);
    345            LedOn(BLUE3);
    346            LedOn(GREEN0);
    347            LedOn(GREEN1);
    348            LedOn(GREEN2);
    349            LedOn(GREEN3);
    350          #endif
    351          
    352          #endif /* MPGL2 */
    353            
    354            /* Turn all LEDs on full, then fade them out over a few seconds */
    355            for(u8 i = 20; i > 0; i--)
   \   00000016   0x2714             MOVS     R7,#+20
   \                     ??LedInitialize_0: (+1)
   \   00000018   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD030             BEQ.N    ??LedInitialize_1
    356            {
    357          #if STARTUP_SOUND
    358              /* Configure Buzzers to provide some audio during start up */
    359              PWMAudioSetFrequency(BUZZER1, u32Buzzer1Frequency);
    360              PWMAudioOn(BUZZER1);
    361          #ifdef  MPGL1
    362              PWMAudioSetFrequency(BUZZER2, u32Buzzer2Frequency);
    363              PWMAudioOn(BUZZER2);
    364          #endif /* MPGL1 */
    365          #endif /* STARTUP_SOUND */
    366              
    367              /* Spend 40ms in each level of intensity */
    368              for(u16 j = 40; j > 0; j--)
   \   0000001E   0xF05F 0x0828      MOVS     R8,#+40
   \                     ??LedInitialize_2: (+1)
   \   00000022   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000026   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002A   0xD00D             BEQ.N    ??LedInitialize_3
    369              {
    370                u32Timer = G_u32SystemTime1ms;
   \   0000002C   0x....             LDR.N    R0,??DataTable6_5
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x9000             STR      R0,[SP, #+0]
    371                while( !IsTimeUp(&u32Timer, 1) );
   \                     ??LedInitialize_4: (+1)
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       IsTimeUp
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0F9             BEQ.N    ??LedInitialize_4
    372                LedUpdate();
   \   0000003E   0x.... 0x....      BL       LedUpdate
    373              }
   \   00000042   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000046   0xE7EC             B.N      ??LedInitialize_2
    374              /* Pause for a bit on the first iteration to show the LEDs on for little while */
    375              if(i == 20)
   \                     ??LedInitialize_3: (+1)
   \   00000048   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004A   0x2F14             CMP      R7,#+20
   \   0000004C   0xD106             BNE.N    ??LedInitialize_5
    376              {
    377                while( !IsTimeUp(&u32Timer, 1500) );
   \                     ??LedInitialize_6: (+1)
   \   0000004E   0xF240 0x51DC      MOVW     R1,#+1500
   \   00000052   0xA800             ADD      R0,SP,#+0
   \   00000054   0x.... 0x....      BL       IsTimeUp
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD0F8             BEQ.N    ??LedInitialize_6
    378              }
    379              
    380              /* Set the LED intensity for the next iteration */
    381              for(u8 j = 0; j < TOTAL_LEDS; j++)
   \                     ??LedInitialize_5: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??LedInitialize_7: (+1)
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x280D             CMP      R0,#+13
   \   00000062   0xDA09             BGE.N    ??LedInitialize_8
    382              {
    383                Leds_asLedArray[j].eRate = (LedRateType)(i - 1);
   \   00000064   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   0x1E79             SUBS     R1,R7,#+1
   \   00000068   0x....             LDR.N    R2,??DataTable6
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x230A             MOVS     R3,#+10
   \   0000006E   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000072   0x8051             STRH     R1,[R2, #+2]
    384              }
   \   00000074   0x1C40             ADDS     R0,R0,#+1
   \   00000076   0xE7F2             B.N      ??LedInitialize_7
    385              
    386              /* Set the buzzer frequency for the next iteration */
    387              u32Buzzer1Frequency -= u32StepSize;
   \                     ??LedInitialize_8: (+1)
   \   00000078   0x1BA4             SUBS     R4,R4,R6
    388              u32Buzzer2Frequency += u32StepSize;
   \   0000007A   0x1975             ADDS     R5,R6,R5
    389            }
   \   0000007C   0x1E7F             SUBS     R7,R7,#+1
   \   0000007E   0xE7CB             B.N      ??LedInitialize_0
    390          
    391            /* Final update to set last state, hold for a short period */
    392            LedUpdate();
   \                     ??LedInitialize_1: (+1)
   \   00000080   0x.... 0x....      BL       LedUpdate
    393            while( !IsTimeUp(&u32Timer, 200) );
   \                     ??LedInitialize_9: (+1)
   \   00000084   0x21C8             MOVS     R1,#+200
   \   00000086   0xA800             ADD      R0,SP,#+0
   \   00000088   0x.... 0x....      BL       IsTimeUp
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD0F9             BEQ.N    ??LedInitialize_9
    394            
    395          #if STARTUP_SOUND
    396            /* Turn off the buzzers */
    397            PWMAudioOff(BUZZER1);
    398          #ifdef  MPGL1
    399            PWMAudioOff(BUZZER2);
    400          #endif /* MPGL1 */
    401            
    402          #endif /* STARTUP_SOUND */
    403          
    404           
    405            /* Exit with Leds off, NORMAL mode, and the backlight on (white) */
    406            for(u8 i = 0; i < TOTAL_LEDS; i++)
   \   00000090   0x2000             MOVS     R0,#+0
   \                     ??LedInitialize_10: (+1)
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0x280D             CMP      R0,#+13
   \   00000096   0xDA04             BGE.N    ??LedInitialize_11
    407            {
    408              Leds_asLedArray[0].eMode = LED_NORMAL_MODE;
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x....             LDR.N    R2,??DataTable6
   \   0000009C   0x7011             STRB     R1,[R2, #+0]
    409            }
   \   0000009E   0x1C40             ADDS     R0,R0,#+1
   \   000000A0   0xE7F7             B.N      ??LedInitialize_10
    410          
    411          #ifdef MPGL1
    412            LedOn(LCD_RED);
    413            LedOn(LCD_GREEN);
    414            LedOn(LCD_BLUE);
    415          #endif
    416            
    417          #ifdef MPGL2
    418            LedOn(LCD_BL);
   \                     ??LedInitialize_11: (+1)
   \   000000A2   0x200C             MOVS     R0,#+12
   \   000000A4   0x.... 0x....      BL       LedOn
    419          #endif
    420          
    421            /* Final setup and report that LED system is ready */
    422            G_u32ApplicationFlags |= _APPLICATION_FLAGS_LED;
   \   000000A8   0x....             LDR.N    R0,??DataTable6_6
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000B0   0x....             LDR.N    R1,??DataTable6_6
   \   000000B2   0x6008             STR      R0,[R1, #+0]
    423            DebugPrintf(au8LedStartupMsg);
   \   000000B4   0x....             LDR.N    R0,??DataTable6_7
   \   000000B6   0x.... 0x....      BL       DebugPrintf
    424            
    425          } /* end LedInitialize() */
   \   000000BA   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return

   \                                 In section .data, align 4
   \                     ??au8LedStartupMsg:
   \   00000000   0x4C 0x45          DC8 "LED functions ready\012\015"
   \              0x44 0x20    
   \              0x66 0x75    
   \              0x6E 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
   \   00000016   0x00 0x00          DC8 0, 0
    426          
    427          
    428          /*--------------------------------------------------------------------------------------------------------------------*/
    429          /* Private functions */
    430          /*--------------------------------------------------------------------------------------------------------------------*/
    431          
    432          /*----------------------------------------------------------------------------------------------------------------------
    433          Function: LedUpdate
    434          
    435          Description:
    436          Update all LEDs for the current cycle.
    437          
    438          Requires:
    439           - G_u32SystemTime1ms is counting
    440          
    441          Promises:
    442             - All LEDs updated based on their counters
    443          */

   \                                 In section .text, align 2, keep-with-next
    444          void LedUpdate(void)
    445          {
   \                     LedUpdate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    446          	/* Loop through each LED */
    447            for(u8 i = 0; i < TOTAL_LEDS; i++)
   \   00000002   0x2400             MOVS     R4,#+0
   \                     ??LedUpdate_0: (+1)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C0D             CMP      R4,#+13
   \   00000008   0xF280 0x80AA      BGE.W    ??LedUpdate_1
    448            {
    449              /* Check if LED is PWMing */
    450              if(Leds_asLedArray[(LedNumberType)i].eMode == LED_PWM_MODE)
   \   0000000C   0x....             LDR.N    R0,??DataTable6
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x210A             MOVS     R1,#+10
   \   00000012   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD172             BNE.N    ??LedUpdate_2
    451              {
    452                /* Handle special case of 0% duty cycle */
    453                if( Leds_asLedArray[i].eRate == LED_PWM_0 )
   \   0000001C   0x....             LDR.N    R0,??DataTable6
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x210A             MOVS     R1,#+10
   \   00000022   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000026   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD104             BNE.N    ??LedUpdate_3
    454                {
    455                  LedOff( (LedNumberType)i );
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       LedOff
   \   00000036   0xE05C             B.N      ??LedUpdate_4
    456                }
    457                
    458                /* Handle special case of 100% duty cycle */
    459                else if( Leds_asLedArray[i].eRate == LED_PWM_100 )
   \                     ??LedUpdate_3: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable6
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x210A             MOVS     R1,#+10
   \   0000003E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000042   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000046   0x2814             CMP      R0,#+20
   \   00000048   0xD104             BNE.N    ??LedUpdate_5
    460                {
    461                  LedOn( (LedNumberType)i );
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x.... 0x....      BL       LedOn
   \   00000052   0xE04E             B.N      ??LedUpdate_4
    462                }
    463            
    464                /* Otherwise, regular PWM: decrement counter; toggle and reload if counter reaches 0 */
    465                else
    466                {
    467                  if(--Leds_asLedArray[(LedNumberType)i].u16Count == 0)
   \                     ??LedUpdate_5: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable6
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x210A             MOVS     R1,#+10
   \   0000005A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000005E   0x8880             LDRH     R0,[R0, #+4]
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable6
   \   00000064   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000066   0x220A             MOVS     R2,#+10
   \   00000068   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000006C   0x8088             STRH     R0,[R1, #+4]
   \   0000006E   0x....             LDR.N    R0,??DataTable6
   \   00000070   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000072   0x210A             MOVS     R1,#+10
   \   00000074   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000078   0x8880             LDRH     R0,[R0, #+4]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD139             BNE.N    ??LedUpdate_4
    468                  {
    469                    if(Leds_asLedArray[(LedNumberType)i].eCurrentDuty == LED_PWM_DUTY_HIGH)
   \   0000007E   0x....             LDR.N    R0,??DataTable6
   \   00000080   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   0x210A             MOVS     R1,#+10
   \   00000084   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000088   0x7980             LDRB     R0,[R0, #+6]
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD11A             BNE.N    ??LedUpdate_6
    470                    {
    471                      /* Turn the LED off and update the counters for the next cycle */
    472                      LedOff( (LedNumberType)i );
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x.... 0x....      BL       LedOff
    473                      Leds_asLedArray[(LedNumberType)i].u16Count = LED_PWM_PERIOD - Leds_asLedArray[(LedNumberType)i].eRate;
   \   00000096   0x....             LDR.N    R0,??DataTable6
   \   00000098   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009A   0x210A             MOVS     R1,#+10
   \   0000009C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000A0   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   000000A4   0xF1D0 0x0014      RSBS     R0,R0,#+20
   \   000000A8   0x....             LDR.N    R1,??DataTable6
   \   000000AA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AC   0x220A             MOVS     R2,#+10
   \   000000AE   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000B2   0x8088             STRH     R0,[R1, #+4]
    474                      Leds_asLedArray[(LedNumberType)i].eCurrentDuty = LED_PWM_DUTY_LOW;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x....             LDR.N    R1,??DataTable6
   \   000000B8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BA   0x220A             MOVS     R2,#+10
   \   000000BC   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000C0   0x7188             STRB     R0,[R1, #+6]
   \   000000C2   0xE016             B.N      ??LedUpdate_4
    475                    }
    476                    else
    477                    {
    478                      /* Turn the LED on and update the counters for the next cycle */
    479                      LedOn( (LedNumberType)i );
   \                     ??LedUpdate_6: (+1)
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x.... 0x....      BL       LedOn
    480                      Leds_asLedArray[i].u16Count = Leds_asLedArray[i].eRate;
   \   000000CC   0x....             LDR.N    R0,??DataTable6
   \   000000CE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D0   0x210A             MOVS     R1,#+10
   \   000000D2   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000D6   0x8840             LDRH     R0,[R0, #+2]
   \   000000D8   0x....             LDR.N    R1,??DataTable6
   \   000000DA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DC   0x220A             MOVS     R2,#+10
   \   000000DE   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000E2   0x8088             STRH     R0,[R1, #+4]
    481                      Leds_asLedArray[i].eCurrentDuty = LED_PWM_DUTY_HIGH;
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x....             LDR.N    R1,??DataTable6
   \   000000E8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EA   0x220A             MOVS     R2,#+10
   \   000000EC   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000F0   0x7188             STRB     R0,[R1, #+6]
    482                    }
    483                  }
    484                }
    485          
    486                /* Set the LED back to PWM mode since LedOff and LedOn set it to normal mode */
    487               	Leds_asLedArray[(LedNumberType)i].eMode = LED_PWM_MODE;
   \                     ??LedUpdate_4: (+1)
   \   000000F2   0x2001             MOVS     R0,#+1
   \   000000F4   0x....             LDR.N    R1,??DataTable6
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0x220A             MOVS     R2,#+10
   \   000000FA   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000FE   0x7008             STRB     R0,[R1, #+0]
   \   00000100   0xE02C             B.N      ??LedUpdate_7
    488                
    489              } /* end if PWM mode */
    490              
    491              /* LED is in LED_BLINK_MODE mode */
    492              else if(Leds_asLedArray[(LedNumberType)i].eMode == LED_BLINK_MODE)
   \                     ??LedUpdate_2: (+1)
   \   00000102   0x....             LDR.N    R0,??DataTable6
   \   00000104   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000106   0x210A             MOVS     R1,#+10
   \   00000108   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000010C   0x7800             LDRB     R0,[R0, #+0]
   \   0000010E   0x2802             CMP      R0,#+2
   \   00000110   0xD124             BNE.N    ??LedUpdate_7
    493              {
    494                /* Decrement counter; toggle and reload if counter reaches 0 */
    495                if( --Leds_asLedArray[(LedNumberType)i].u16Count == 0)
   \   00000112   0x....             LDR.N    R0,??DataTable6
   \   00000114   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000116   0x210A             MOVS     R1,#+10
   \   00000118   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000011C   0x8880             LDRH     R0,[R0, #+4]
   \   0000011E   0x1E40             SUBS     R0,R0,#+1
   \   00000120   0x....             LDR.N    R1,??DataTable6
   \   00000122   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000124   0x220A             MOVS     R2,#+10
   \   00000126   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000012A   0x8088             STRH     R0,[R1, #+4]
   \   0000012C   0x....             LDR.N    R0,??DataTable6
   \   0000012E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000130   0x210A             MOVS     R1,#+10
   \   00000132   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000136   0x8880             LDRH     R0,[R0, #+4]
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD10F             BNE.N    ??LedUpdate_7
    496                {
    497                  LedToggle( (LedNumberType)i );
   \   0000013C   0x0020             MOVS     R0,R4
   \   0000013E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000140   0x.... 0x....      BL       LedToggle
    498                  Leds_asLedArray[(LedNumberType)i].u16Count = Leds_asLedArray[(LedNumberType)i].eRate;
   \   00000144   0x....             LDR.N    R0,??DataTable6
   \   00000146   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000148   0x210A             MOVS     R1,#+10
   \   0000014A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000014E   0x8840             LDRH     R0,[R0, #+2]
   \   00000150   0x....             LDR.N    R1,??DataTable6
   \   00000152   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000154   0x220A             MOVS     R2,#+10
   \   00000156   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000015A   0x8088             STRH     R0,[R1, #+4]
    499                }
    500              }
    501            } /* end for */
   \                     ??LedUpdate_7: (+1)
   \   0000015C   0x1C64             ADDS     R4,R4,#+1
   \   0000015E   0xE751             B.N      ??LedUpdate_0
    502          } /* end LedUpdate() */
   \                     ??LedUpdate_1: (+1)
   \   00000160   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     Leds_asLedArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x400E0C30         DC32     0x400e0c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x400E0C34         DC32     0x400e0c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     Led_au32BitPositions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x400E0C38         DC32     0x400e0c38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     ??au8LedStartupMsg
    503          
    504          
    505          /*--------------------------------------------------------------------------------------------------------------------*/
    506          /* End of File */
    507          /*--------------------------------------------------------------------------------------------------------------------*/
    508          
    509          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   LedBlink
      32   LedInitialize
        32   -> DebugPrintf
        32   -> IsTimeUp
        32   -> LedOn
        32   -> LedUpdate
       4   LedOff
       4   LedOn
       4   LedPWM
       0   LedToggle
       8   LedUpdate
         8   -> LedOff
         8   -> LedOn
         8   -> LedToggle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
      44  LedBlink
     190  LedInitialize
      88  LedOff
      92  LedOn
      58  LedPWM
      34  LedToggle
     354  LedUpdate
      52  Led_au32BitPositions
     132  Leds_asLedArray
      24  au8LedStartupMsg

 
 208 bytes in section .data
 892 bytes in section .text
 
 892 bytes of CODE memory
 208 bytes of DATA memory

Errors: none
Warnings: none
