###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        14/Oct/2015  14:35:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\drivers\lcd_nhd-c0220biz.c
#    Command line =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\drivers\lcd_nhd-c0220biz.c
#        --preprocess=cl
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\bsp\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline -I "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\lcd_nhd-c0220biz.lst
#    Object file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\lcd_nhd-c0220biz.o
#
###############################################################################

D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\drivers\lcd_nhd-c0220biz.c
      1          /***********************************************************************************************************************
      2          File: lcd_nhd-c0220biz.c.c                                                                
      3          
      4          Description:
      5          Driver for Newhaven Display NHD-C0220BiZ ASCII LCD.
      6          
      7          This application requires an I²C resource to output data.
      8          
      9          The displayable area of the screen is 20 character x 2 lines, though the LCD RAM will accomodate
     10          40 characters per line (so can be used for scrolling text applications).
     11          Each character has a 1-byte address. Nmemonics are defined for the main locations
     12          
     13          Line #      Left most address             Last printed char           Right most address
     14            1       0x00 (LINE1_START_ADDR)         0x13 (LINE1_END)          0x27 (LINE1_END_ABSOLUTE)      
     15            2       0x40 (LINE2_START_ADDR)         0x53 (LINE2_END)          0x67 (LINE2_END_ABSOLUTE)      
     16          
     17          API
     18          void LcdInitialize(void)
     19          Initializes the LCD task and manually sends a message to the LCD.
     20          This function must be run during the startup section of main.
     21          e.g.
     22          LcdInitialize();
     23          
     24          void LCDCommand(u8 u8Command_)
     25          Queues a command code to be sent to the LCD.  See the full command list in the header file.
     26          Some common commands are shown below.
     27          LCD_CLEAR_CMD				Writes spaces to all chars
     28          LCD_HOME_CMD				Puts cursor at 0x00
     29          
     30          LCD_DISPLAY_CMD			Root literal for managing display
     31          LCD_DISPLAY_ON				OR with LCD_DISPLAY_CMD to turn display on
     32          LCD_DISPLAY_CURSOR		OR with LCD_DISPLAY_CMD to turn cursor on
     33          LCD_DISPLAY_BLINK			OR with LCD_DISPLAY_CMD to turn cursor blink on
     34          
     35          e.g. Turn display on with a solid (non-blinking) cursor
     36          LCDCommand(LCD_DISPLAY_CMD | LCD_DISPLAY_ON | LCD_DISPLAY_CURSOR);
     37          
     38          void LCDMessage(u8 u8Address_, u8 *u8Message_)
     39          Sends a text message to the LCD to be printed at the address specified.  
     40          
     41          
     42          
     43          ***********************************************************************************************************************/
     44          
     45          #include "configuration.h"
     46          
     47          /***********************************************************************************************************************
     48          Global variable definitions with scope across entire project.
     49          All Global variable names shall start with "G_<type>Lcd"
     50          ***********************************************************************************************************************/
     51          /* New variables */
     52          
     53          
     54          /*--------------------------------------------------------------------------------------------------------------------*/
     55          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     56          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     57          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     58          
     59          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     60          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     61          
     62          
     63          /***********************************************************************************************************************
     64          Global variable definitions with scope limited to this local application.
     65          Variable names shall start with "Lcd_" and be declared as static.
     66          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     67          static fnCode_type Lcd_StateMachine;
   \                     Lcd_StateMachine:
   \   00000000                      DS8 4
     68          

   \                                 In section .bss, align 4
     69          static u32 Lcd_u32Timer;
   \                     Lcd_u32Timer:
   \   00000000                      DS8 4
     70          
     71          
     72          /***********************************************************************************************************************
     73          * Function Definitions
     74          ***********************************************************************************************************************/
     75          
     76          /*--------------------------------------------------------------------------------------------------------------------*/
     77          /* Public Functions */
     78          /*--------------------------------------------------------------------------------------------------------------------*/
     79          
     80          /*----------------------------------------------------------------------------------------------------------------------
     81          Function LCDCommand
     82          
     83          Description:
     84          Queues a command char to be sent to the LCD using the TWI messaging function. 
     85          
     86          Requires:
     87          	- u8Command_ is an acceptable command value for the LCD as taken from the
     88              "LCD Commands" list in lcd_nhd_c0220biz.h header file.  The command must
     89              be complete and include any optional bits.
     90          
     91          Promises:
     92            - The command is queued and will be sent to the LCD at the next
     93              available time.
     94          */

   \                                 In section .text, align 2, keep-with-next
     95          void LCDCommand(u8 u8Command_)
     96          {
   \                     LCDCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     97            static u8 au8LCDWriteCommand[] = {LCD_CONTROL_COMMAND, 0x00};
     98          
     99            /* $$$$ Update the command paramter into the command array */
    100            au8LCDWriteCommand[1] = u8Command_;
   \   00000004   0x....             LDR.N    R0,??DataTable4
   \   00000006   0x7044             STRB     R4,[R0, #+1]
    101              
    102            /* $$$$ Queue the command to the I²C application */
    103            TWI0WriteData(LCD_ADDRESS, sizeof(au8LCDWriteCommand), &au8LCDWriteCommand[0], STOP);
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x....             LDR.N    R2,??DataTable4
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x203C             MOVS     R0,#+60
   \   00000010   0x.... 0x....      BL       TWI0WriteData
    104          
    105            
    106          } /* end LCDCommand() */
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .bss, align 2
   \                     ??au8LCDWriteCommand:
   \   00000000                      DS8 2
    107          
    108          /*------------------------------------------------------------------------------
    109          Function: LCDMessage
    110          
    111          Description:
    112          Sends a text message to the LCD to be printed at the address specified.  
    113          
    114          Requires:
    115            - LCD is initialized
    116            - u8Message_ is a pointer to a NULL-terminated C-string
    117          	- The message to display is no more than (40 - the selected display location) 
    118              characters in length
    119            - Any characters not desired on screen that will not be overwritten need to 
    120              be erased first
    121          
    122          Promises:
    123            - Message to set cursor address in the LCD is queued, then message data 
    124              is queued to the LCD to be displayed. 
    125          */

   \                                 In section .text, align 2, keep-with-next
    126          void LCDMessage(u8 u8Address_, u8 *u8Message_)
    127          { 
   \                     LCDMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    128            u8 u8Index; 
    129            static u8 au8LCDMessage[LCD_MESSAGE_OVERHEAD_SIZE + LCD_MAX_MESSAGE_SIZE] = 
    130                                     {LCD_CONTROL_DATA};
    131            
    132            /* Set the cursor to the correct address */
    133            LCDCommand(LCD_ADDRESS_CMD | u8Address_);
   \   00000006   0xF054 0x0080      ORRS     R0,R4,#0x80
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       LCDCommand
    134            
    135            /* Fill the message */
    136            u8Index = 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x0006             MOVS     R6,R0
    137            while(*u8Message_ != '\0')
   \                     ??LCDMessage_0: (+1)
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD006             BEQ.N    ??LCDMessage_1
    138            {
    139              au8LCDMessage[u8Index++] = *u8Message_++;
   \   0000001A   0x7828             LDRB     R0,[R5, #+0]
   \   0000001C   0x....             LDR.N    R1,??DataTable4_1
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0x5470             STRB     R0,[R6, R1]
   \   00000022   0x1C6D             ADDS     R5,R5,#+1
   \   00000024   0x1C76             ADDS     R6,R6,#+1
   \   00000026   0xE7F5             B.N      ??LCDMessage_0
    140            }
    141              
    142            /* Queue the message */
    143            TWI0WriteData(LCD_ADDRESS, u8Index, au8LCDMessage, STOP);
   \                     ??LCDMessage_1: (+1)
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x....             LDR.N    R2,??DataTable4_1
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0x0031             MOVS     R1,R6
   \   00000030   0x203C             MOVS     R0,#+60
   \   00000032   0x.... 0x....      BL       TWI0WriteData
    144          
    145          } /* end LCDMessage() */
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8LCDMessage:
   \   00000000   0x40 0x00          DC8 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000016   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    146          
    147          
    148          /*------------------------------------------------------------------------------
    149          Function: LCDClearChars
    150          
    151          Description:
    152          Clears a number of chars starting from the address specified.  This function is
    153          not meant to span rows.
    154          
    155          Requires:
    156            - LCD is initialized
    157            - u8Address_ is the starting address where the first character will be cleared
    158          	- u8CharactersToClear_ is the number of characters to clear and does not cause 
    159              the cursor to go past the available data RAM.
    160          
    161          Promises:
    162            - Message to set cursor address in the LCD is queued, then message data 
    163              consisting of all ' ' characters is queued to the LCD to be displayed. 
    164          */

   \                                 In section .text, align 2, keep-with-next
    165          void LCDClearChars(u8 u8Address_, u8 u8CharactersToClear_)
    166          { 
   \                     LCDClearChars: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    167            u8 u8Index; 
    168            static u8 au8LCDMessage[LCD_MESSAGE_OVERHEAD_SIZE + LCD_MAX_MESSAGE_SIZE] =  {LCD_CONTROL_DATA};
    169            
    170            /* Set the cursor to the correct address */
    171            LCDCommand(LCD_ADDRESS_CMD | u8Address_);
   \   00000006   0xF054 0x0080      ORRS     R0,R4,#0x80
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       LCDCommand
    172            
    173            /* Fill the message characters with ' ' */
    174            for(u8Index = 0; u8Index < u8CharactersToClear_; u8Index++)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0006             MOVS     R6,R0
   \                     ??LCDClearChars_0: (+1)
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x42AE             CMP      R6,R5
   \   0000001A   0xD206             BCS.N    ??LCDClearChars_1
    175            {
    176              au8LCDMessage[u8Index + 1] = ' ';
   \   0000001C   0x2020             MOVS     R0,#+32
   \   0000001E   0x....             LDR.N    R1,??DataTable4_2
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0x1871             ADDS     R1,R6,R1
   \   00000024   0x7048             STRB     R0,[R1, #+1]
    177            }
   \   00000026   0x1C76             ADDS     R6,R6,#+1
   \   00000028   0xE7F4             B.N      ??LCDClearChars_0
    178                
    179            /* Queue the message */
    180            TWI0WriteData(LCD_ADDRESS, u8Index, au8LCDMessage, STOP);
   \                     ??LCDClearChars_1: (+1)
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x....             LDR.N    R2,??DataTable4_2
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x0031             MOVS     R1,R6
   \   00000032   0x203C             MOVS     R0,#+60
   \   00000034   0x.... 0x....      BL       TWI0WriteData
    181                	
    182          } /* end LCDClearChars() */
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8LCDMessage_1:
   \   00000000   0x40 0x00          DC8 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000016   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    183          
    184          
    185          /*--------------------------------------------------------------------------------------------------------------------*/
    186          /* Protected Functions */
    187          /*--------------------------------------------------------------------------------------------------------------------*/
    188          
    189          /*------------------------------------------------------------------------------
    190          Function: LcdInitialize
    191          
    192          Description:
    193          Initializes the LCD task and manually sends a message to the LCD
    194          
    195          Requires:
    196            - 
    197          
    198          Promises:
    199            - LCD task Setup and LCD functions can now be called
    200          */

   \                                 In section .text, align 2, keep-with-next
    201          void LcdInitialize(void)
    202          {
   \                     LcdInitialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    203            u8 au8Commands[] = 
    204            {
    205              LCD_FUNCTION_CMD, LCD_FUNCTION2_CMD, LCD_BIAS_CMD, 
    206              LCD_CONTRAST_CMD, LCD_DISPLAY_SET_CMD, LCD_FOLLOWER_CMD 
    207            };
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable4_3
   \   00000008   0xC90C             LDM      R1!,{R2,R3}
   \   0000000A   0xC00C             STM      R0!,{R2,R3}
   \   0000000C   0x3908             SUBS     R1,R1,#+8
   \   0000000E   0x3808             SUBS     R0,R0,#+8
    208                           /* "012345567890123456789" */
    209            u8 au8Welcome[] = "WELCOME!             ";
   \   00000010   0xA802             ADD      R0,SP,#+8
   \   00000012   0x....             LDR.N    R1,??DataTable4_4
   \   00000014   0x2216             MOVS     R2,#+22
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
    210            
    211            /* State to Idle */
    212            Lcd_StateMachine = LcdSM_Idle;
   \   0000001A   0x.... 0x....      ADR.W    R0,LcdSM_Idle
   \   0000001E   0x....             LDR.N    R1,??DataTable4_5
   \   00000020   0x6008             STR      R0,[R1, #+0]
    213            
    214            /* Turn on LCD wait 40 ms for it to setup */
    215            AT91C_BASE_PIOB->PIO_SODR = PB_09_LCD_RST;
   \   00000022   0xF44F 0x7000      MOV      R0,#+512
   \   00000026   0x....             LDR.N    R1,??DataTable4_6  ;; 0x400e0e30
   \   00000028   0x6008             STR      R0,[R1, #+0]
    216            Lcd_u32Timer = G_u32SystemTime1ms;
   \   0000002A   0x....             LDR.N    R0,??DataTable4_7
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x....             LDR.N    R1,??DataTable4_8
   \   00000030   0x6008             STR      R0,[R1, #+0]
    217            while( !IsTimeUp(&Lcd_u32Timer, LCD_STARTUP_DELAY) );
   \                     ??LcdInitialize_0: (+1)
   \   00000032   0x2128             MOVS     R1,#+40
   \   00000034   0x....             LDR.N    R0,??DataTable4_8
   \   00000036   0x.... 0x....      BL       IsTimeUp
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0F9             BEQ.N    ??LcdInitialize_0
    218            
    219            /* Send Control Command */
    220            TWI0WriteByte(LCD_ADDRESS, LCD_CONTROL_COMMAND, NO_STOP);
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x203C             MOVS     R0,#+60
   \   00000044   0x.... 0x....      BL       TWI0WriteByte
    221            
    222            /* Send Control Commands */
    223            TWI0WriteData(LCD_ADDRESS, NUM_CONTROL_CMD, &au8Commands[0], NO_STOP);
   \   00000048   0x2301             MOVS     R3,#+1
   \   0000004A   0xAA00             ADD      R2,SP,#+0
   \   0000004C   0x2106             MOVS     R1,#+6
   \   0000004E   0x203C             MOVS     R0,#+60
   \   00000050   0x.... 0x....      BL       TWI0WriteData
    224            
    225            /* Wait for 200 ms */
    226            Lcd_u32Timer = G_u32SystemTime1ms;
   \   00000054   0x....             LDR.N    R0,??DataTable4_7
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x....             LDR.N    R1,??DataTable4_8
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    227            while( !IsTimeUp(&Lcd_u32Timer, LCD_CONTROL_COMMAND_DELAY) );
   \                     ??LcdInitialize_1: (+1)
   \   0000005C   0x21C8             MOVS     R1,#+200
   \   0000005E   0x....             LDR.N    R0,??DataTable4_8
   \   00000060   0x.... 0x....      BL       IsTimeUp
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD0F9             BEQ.N    ??LcdInitialize_1
    228            
    229            /* Send Final Command to turn it on */
    230            TWI0WriteByte(LCD_ADDRESS, LCD_DISPLAY_CMD | LCD_DISPLAY_ON, STOP);
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x210C             MOVS     R1,#+12
   \   0000006C   0x203C             MOVS     R0,#+60
   \   0000006E   0x.... 0x....      BL       TWI0WriteByte
    231          
    232            /* Blacklight - White */
    233            LedOn(LCD_RED);
   \   00000072   0x2008             MOVS     R0,#+8
   \   00000074   0x.... 0x....      BL       LedOn
    234            LedOn(LCD_GREEN);
   \   00000078   0x2009             MOVS     R0,#+9
   \   0000007A   0x.... 0x....      BL       LedOn
    235            LedOn(LCD_BLUE);
   \   0000007E   0x200A             MOVS     R0,#+10
   \   00000080   0x.... 0x....      BL       LedOn
    236            
    237            TWI0WriteByte(LCD_ADDRESS, LCD_CONTROL_DATA, NO_STOP);
   \   00000084   0x2201             MOVS     R2,#+1
   \   00000086   0x2140             MOVS     R1,#+64
   \   00000088   0x203C             MOVS     R0,#+60
   \   0000008A   0x.... 0x....      BL       TWI0WriteByte
    238            TWI0WriteData(LCD_ADDRESS, 20, &au8Welcome[0], STOP);
   \   0000008E   0x2300             MOVS     R3,#+0
   \   00000090   0xAA02             ADD      R2,SP,#+8
   \   00000092   0x2114             MOVS     R1,#+20
   \   00000094   0x203C             MOVS     R0,#+60
   \   00000096   0x.... 0x....      BL       TWI0WriteData
    239             
    240            Lcd_u32Timer = G_u32SystemTime1ms;
   \   0000009A   0x....             LDR.N    R0,??DataTable4_7
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x....             LDR.N    R1,??DataTable4_8
   \   000000A0   0x6008             STR      R0,[R1, #+0]
    241            G_u32ApplicationFlags |= _APPLICATION_FLAGS_LCD;
   \   000000A2   0x....             LDR.N    R0,??DataTable4_9
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000AA   0x....             LDR.N    R1,??DataTable4_9
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    242          
    243          } /* end LcdInitialize */
   \   000000AE   0xB009             ADD      SP,SP,#+36
   \   000000B0   0xBD00             POP      {PC}             ;; return
    244          
    245          
    246          /*----------------------------------------------------------------------------------------------------------------------
    247          Function LcdRunActiveState()
    248          
    249          Description:
    250          Selects and runs one iteration of the current state in the state machine.
    251          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    252          may take 1ms / n to execute.
    253          
    254          Requires:
    255            - State machine function pointer points at current state
    256          
    257          Promises:
    258            - Calls the function to pointed by the state machine function pointer
    259          */

   \                                 In section .text, align 2, keep-with-next
    260          void LcdRunActiveState(void)
    261          {
   \                     LcdRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    262            Lcd_StateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable4_5
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    263          
    264          } /* end LcdRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    265          
    266          
    267          /***********************************************************************************************************************
    268          State Machine Function Declarations
    269          ***********************************************************************************************************************/
    270          
    271          /*------------------------------------------------------------------------------
    272          Function: LcdSM_Idle
    273          
    274          Description:
    275          Placeholder for some fancier functionality to come later.
    276          
    277          Requires:
    278            - LCD is initialized
    279          
    280          Promises:
    281            - 
    282          */

   \                                 In section .text, align 4, keep-with-next
    283          void LcdSM_Idle(void)
    284          {
    285            
    286          }
   \                     LcdSM_Idle: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     ??au8LCDWriteCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     ??au8LCDMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     ??au8LCDMessage_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     Lcd_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x400E0E30         DC32     0x400e0e30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     Lcd_u32Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x38 0x39          DC8 56, 57, 20, 114, 94, 109, 0, 0
   \              0x14 0x72    
   \              0x5E 0x6D    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x57 0x45          DC8 "WELCOME!             "
   \              0x4C 0x43    
   \              0x4F 0x4D    
   \              0x45 0x21    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   LCDClearChars
        16   -> LCDCommand
        16   -> TWI0WriteData
       8   LCDCommand
         8   -> TWI0WriteData
      16   LCDMessage
        16   -> LCDCommand
        16   -> TWI0WriteData
      40   LcdInitialize
        40   -> IsTimeUp
        40   -> LedOn
        40   -> TWI0WriteByte
        40   -> TWI0WriteData
        40   -> __aeabi_memcpy
       8   LcdRunActiveState
         8   -- Indirect call
       0   LcdSM_Idle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       8  ?_0
      24  ?_1
      58  LCDClearChars
      22  LCDCommand
      56  LCDMessage
     178  LcdInitialize
      10  LcdRunActiveState
       2  LcdSM_Idle
       4  Lcd_StateMachine
       4  Lcd_u32Timer
      44  au8LCDMessage
      44  au8LCDMessage
       2  au8LCDWriteCommand

 
  10 bytes in section .bss
  88 bytes in section .data
  32 bytes in section .rodata
 366 bytes in section .text
 
 366 bytes of CODE  memory
  32 bytes of CONST memory
  98 bytes of DATA  memory

Errors: none
Warnings: none
