###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        21/Oct/2015  14:29:08
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\sam3u_uart.c
#    Command line =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\sam3u_uart.c
#        --preprocess=cl
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\bsp\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline -I "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\sam3u_uart.lst
#    Object file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\sam3u_uart.o
#
###############################################################################

D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\sam3u_uart.c
      1          /**********************************************************************************************************************
      2          File: sam3u_uart.c                                                                
      3          
      4          Description:
      5          Provides a driver to use UART peripherals to send and receive data using interrupts. 
      6          This driver covers both the dedicated UART peripheral and the three USART peripherals (assuming they are
      7          running in asynchronous (UART) mode).
      8          
      9          UART0 (38,400 8-N-1) gets special treatment to allow it to run very simply since it is only a debug interface.  The transmit buffer is
     10          owned by this source file and is accessed through the API.
     11          
     12          
     13          ------------------------------------------------------------------------------------------------------------------------
     14          API:
     15          Simple Public Debug UART functions:
     16          void Uart_putc(u8 u8Char_)
     17          bool UartCheckForNewChar(void)
     18          u8 Uart_getc(void)
     19          
     20          Generic Public UART functions
     21          UartPeripheralType* UartRequest(UartConfigurationType* psUartConfig_);
     22          Request a UART peripheral for your task.  No other tasks in the system will be able to access 
     23          the specific UART peripheral you request.
     24          e.g. MyTaskUart = UartRequest(&MyTaskUartConfig);
     25          
     26          void UartRelease(UartPeripheralType* psUartPeripheral_);
     27          If your task is done using the UART it requested, call this function to "give it back" to the system.
     28          e.g. UartRelease(&MyTaskUart);
     29          
     30          u32 UartWriteByte(UartPeripheralType* psUartPeripheral_, u8 u8Byte_);
     31          Write a single byte to the UART.  A token corresponding to the message is returned if you want to monitor
     32          if the byte sends correctly.
     33          e.g u32CurrentMessageToken = UartWriteByte(&MyTaskUart, 'A');
     34          
     35          u32 UartWriteData(UartPeripheralType* psUartPeripheral_, u32 u32Size_, u8* u8Data_);
     36          Write an array of bytes to the UART.  Returns the message token for monitoring the status of the message.
     37          e.g. 
     38          u8 au8Sting[] = "Send this string!\n\r";
     39          u32CurrentMessageToken = UartWriteData(&MyTaskUart, strlen(au8Sting), au8Sting);
     40          
     41          All receive functionality is automatic. Incoming bytes are deposited to the 
     42          buffer specified in psUartConfig_
     43          
     44          Both Tx and Rx use the peripheral DMA controller, though received bytes
     45          are always received one at a time to allow use of a circular buffer by the
     46          client task.
     47          
     48          INITIALIZATION (should take place in application's initialization function):
     49          1. Create a variable of UartConfigurationType in your application and initialize it to the desired UART peripheral,
     50          the address of the receive buffer for the application and the size in bytes of the receive buffer.
     51          
     52          2. Call UartRequest() with pointer to the configuration variable created in step 1.  The returned pointer is the
     53          UartPeripheralType object created that will be used by your application and should be assigned to a variable
     54          accessible to your application.
     55          
     56          3. If the application no longer needs the UART resource, call UartRelease().  
     57          
     58          DATA TRANSFER:
     59          1. Received bytes on the allocated peripheral will be dropped into the application's designated receive
     60          buffer.  The buffer is written circularly, with no provision to monitor bytes that are overwritten.  The 
     61          application is responsible for processing all received data.  The application must provide its own parsing
     62          pointer to read the receive buffer and properly wrap around.  This pointer will not be impacted by the interrupt
     63          service routine that may add additional characters at any time.
     64          
     65          2. Transmitted data is queued using one of two functions, UartWriteByte() and UartWriteData().  Once the data
     66          is queued, it is sent as soon as possible.  Each UART resource has a transmit queue, but only one UART resource
     67          will send data at any given time from this state machine.  However, all UART resources may receive data simultaneously
     68          through their respective interrupt handlers based on interrupt priority.
     69          
     70          **********************************************************************************************************************/
     71          
     72          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15_2  ;; 0xe000e280
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     73          
     74          
     75          /***********************************************************************************************************************
     76          Global variable definitions with scope across entire project.
     77          All Global variable names shall start with "G_<type>Uart"
     78          ***********************************************************************************************************************/
     79          /* New variables */

   \                                 In section .bss, align 4
     80          u32 G_u32UartApplicationFlags;                    /* Status flags meant for application using this UART peripheral */
   \                     G_u32UartApplicationFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     81          u32 G_u32Uart0ApplicationFlags;                   /* Status flags meant for application using this UART peripheral */
   \                     G_u32Uart0ApplicationFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     82          u32 G_u32Uart1ApplicationFlags;                   /* Status flags meant for application using this UART peripheral */
   \                     G_u32Uart1ApplicationFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     83          u32 G_u32Uart2ApplicationFlags;                   /* Status flags meant for application using this UART peripheral */
   \                     G_u32Uart2ApplicationFlags:
   \   00000000                      DS8 4
     84          
     85          
     86          /*--------------------------------------------------------------------------------------------------------------------*/
     87          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     88          extern volatile u32 G_u32SystemTime1ms;        /* From board-specific source file */
     89          extern volatile u32 G_u32SystemTime1s;         /* From board-specific source file */
     90          
     91          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     92          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     93          
     94          
     95          /***********************************************************************************************************************
     96          Global variable definitions with scope limited to this local application.
     97          Variable names shall start with "UART_" and be declared as static.
     98          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     99          static fnCode_type Uart_pfnStateMachine;        /* The UART application state machine function pointer */
   \                     Uart_pfnStateMachine:
   \   00000000                      DS8 4
    100          
    101          static u32 UART_u32Timer;                       /* Counter used across states */
                            ^
Warning[Pe177]: variable "UART_u32Timer" was declared but never referenced

   \                                 In section .bss, align 4
    102          static u32 UART_u32Flags;                       /* Application flags for UART */
   \                     UART_u32Flags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    103          static u8 UART_u8ActiveUarts = 0;               /* Counting semaphore for # of active UARTs */
   \                     UART_u8ActiveUarts:
   \   00000000                      DS8 1
    104          

   \                                 In section .bss, align 4
    105          static UartPeripheralType UART_Peripheral;      /* UART peripheral object */
   \                     UART_Peripheral:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
    106          static UartPeripheralType UART_Peripheral0;     /* USART0 peripheral object (used as UART) */
   \                     UART_Peripheral0:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
    107          static UartPeripheralType UART_Peripheral1;     /* USART1 peripheral object (used as UART) */
   \                     UART_Peripheral1:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
    108          static UartPeripheralType UART_Peripheral2;     /* USART2 peripheral object (used as UART) */
   \                     UART_Peripheral2:
   \   00000000                      DS8 36
    109          

   \                                 In section .bss, align 4
    110          static UartPeripheralType* UART_psCurrentUart;   /* Current UART peripheral being processed */
   \                     UART_psCurrentUart:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    111          static UartPeripheralType* UART_psCurrentISR;    /* Current UART peripheral being processed in ISR */
   \                     UART_psCurrentISR:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    112          static u32* UART_pu32ApplicationFlagsISR;        /* Current UART application status flags in ISR */
   \                     UART_pu32ApplicationFlagsISR:
   \   00000000                      DS8 4
    113          
    114          /* Buffers for simple UART implementation */
    115          #if USE_SIMPLE_USART0
    116          static u8  UART_au8U0RxBuffer[U0RX_BUFFER_SIZE];/* Receive buffer for basic UART0 */
    117          static u8* UART_pu8U0RxBufferNextChar;          /* Pointer to location where next incoming char should be written */
    118          static u8* UART_pu8U0RxBufferUnreadChar;        /* Pointer to location of next char that has not yet been read */
    119          
    120          static u8  UART_au8U0TxBuffer[U0TX_BUFFER_SIZE];/* Transmit buffer for basic UART0 */
    121          static u8* UART_pu8U0TxBufferNextChar;          /* Pointer to location where next outgoing char should be written */
    122          static u8* UART_pu8U0TxBufferUnsentChar;        /* Pointer to location of next char that has not yet been sent */
    123          #endif /* USE_SIMPLE_USART0 */
    124          

   \                                 In section .bss, align 4
    125          static u32 UART_u32IntCount = 0;                /* Debug counter for UART interrupts */
   \                     UART_u32IntCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    126          static u32 UART_u32Int0Count = 0;               /* Debug counter for USART0 interrupts */
   \                     UART_u32Int0Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    127          static u32 UART_u32Int1Count = 0;               /* Debug counter for USART1 interrupts */
   \                     UART_u32Int1Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    128          static u32 UART_u32Int2Count = 0;               /* Debug counter for USART2 interrupts */
   \                     UART_u32Int2Count:
   \   00000000                      DS8 4
    129          
    130          
    131          /***********************************************************************************************************************
    132          Function Definitions
    133          ***********************************************************************************************************************/
    134          /*--------------------------------------------------------------------------------------------------------------------*/
    135          /* Public Functions */
    136          /*--------------------------------------------------------------------------------------------------------------------*/
    137          
    138          #if USE_SIMPLE_USART0
    139          
    140          /*----------------------------------------------------------------------------------------------------------------------
    141          Function: Uart_putc
    142          
    143          Description:
    144          Writes a char directly to the debug UART transmit buffer.
    145          
    146          Requires:
    147            - Debug UART is set up
    148          
    149          Promises:
    150            - Character is written directly to the UART buffer if transmitter is ready
    151            - Returns TRUE if character queued to transmit buffer; else returns FALSE
    152          */
    153          bool Uart_putc(u8 u8Char_)
    154          {
    155            /* Check if the transmitter is available */
    156            if(AT91C_BASE_US0->US_CSR & AT91C_US_TXRDY)
    157            {
    158              /* Load the character to send it */
    159              AT91C_BASE_US0->US_THR = u8Char_;    
    160              return TRUE;
    161            }
    162            else
    163            {
    164              /* Transmitter not ready: return FALSE */
    165              return FALSE;
    166            }
    167            
    168          } /* end Uart_putc() */
    169          
    170          
    171          /*----------------------------------------------------------------------------------------------------------------------
    172          Function: Uart_getc
    173          
    174          Description:
    175          Reads a char directly to the debug UART transmit buffer.
    176          Recommended that user first calls UartCheckForNewChar to ensure there is a valid character ready.
    177          
    178          Requires:
    179            - Debug UART is set up
    180          
    181          Promises:
    182            - If there is at least 1 new character, the oldest character from the UART is loaded to pu8Byte and function returns TRUE
    183            - If there are no new characters, pu8Byte_ is untouched and function returns FALSE.
    184          */
    185          bool Uart_getc(u8* pu8Byte_)
    186          {
    187            /* Check if there is at least one new character in the buffer */
    188            if( UartCheckForNewChar() )
    189            {
    190              /* Read the oldest unread character */
    191              *pu8Byte_ = *UART_pu8U0RxBufferUnreadChar;
    192          
    193              /* Safely advance the pointer */
    194              UART_pu8U0RxBufferUnreadChar++;
    195              if(UART_pu8U0RxBufferUnreadChar == &UART_au8U0RxBuffer[U0RX_BUFFER_SIZE])
    196              {
    197                UART_pu8U0RxBufferUnreadChar = &UART_au8U0RxBuffer[0];
    198              }
    199            }
    200            else
    201            {
    202              return FALSE;
    203            }
    204            
    205            return TRUE;
    206            
    207          } /* end Uart_getc() */
    208          
    209          
    210          /*----------------------------------------------------------------------------------------------------------------------
    211          Function: UartCheckForNewChar
    212          
    213          Description:
    214          Checks to see if any new characters are present in the UART debug receive buffer.
    215          
    216          Requires:
    217            - Debug UART is set up
    218          
    219          Promises:
    220            - Returns TRUE if there are new chars ready in the debug UART rx buffer; otherwise
    221              returns FALSE
    222          */
    223          bool UartCheckForNewChar(void)
    224          {
    225            if(UART_pu8U0RxBufferNextChar == UART_pu8U0RxBufferUnreadChar)
    226            {
    227              return(FALSE);
    228            }
    229            else
    230            {
    231              return(TRUE);
    232            }
    233            
    234          } /* end UartCheckForNewChar() */
    235          
    236          #endif /* USE_SIMPLE_USART0 */
    237          
    238          /*----------------------------------------------------------------------------------------------------------------------
    239          Function: UartRequest
    240          
    241          Description:
    242          Requests access to a UART resource.  If the resource is available, the transmit and receive parameters are set up
    243          and the peripheral is made ready to use in the application.  
    244          
    245          Requires:
    246            - UART_Peripheralx perihperal objects have been initialized
    247            - USART Peripheralx registers are not write-protected (WPEN)
    248            - UART peripheral register initialization values in configuration.h must be set correctly
    249            - psUartConfig_ has the UART peripheral number, address of the RxBuffer, and the RxBuffer size and the calling
    250              application is ready to start using the peripheral.
    251            - UART/USART peripheral registers configured here are available and at the same address offset regardless of the peripheral. 
    252          
    253          Promises:
    254            - Returns NULL if a resource cannot be assigned; OR
    255            - Returns a pointer to the requested UART peripheral object if the resource is available
    256            - Peripheral is configured and enabled 
    257            - Peripheral interrupts are enabled.
    258          */

   \                                 In section .text, align 2, keep-with-next
    259          UartPeripheralType* UartRequest(UartConfigurationType* psUartConfig_)
    260          {
   \                     UartRequest: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    261            UartPeripheralType* psRequestedUart;
    262            u32 u32TargetCR, u32TargetMR, u32TargetIER, u32TargetIDR, u32TargetBRGR;
    263            
    264            switch(psUartConfig_->UartPeripheral)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD006             BEQ.N    ??UartRequest_0
   \   0000000C   0xD346             BCC.N    ??UartRequest_1
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD023             BEQ.N    ??UartRequest_2
   \   00000012   0xD312             BCC.N    ??UartRequest_3
   \   00000014   0x2804             CMP      R0,#+4
   \   00000016   0xD030             BEQ.N    ??UartRequest_4
   \   00000018   0xE040             B.N      ??UartRequest_1
    265            {
    266              case UART:
    267              {
    268                psRequestedUart = &UART_Peripheral; 
   \                     ??UartRequest_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000001E   0x0005             MOVS     R5,R0
    269          
    270                u32TargetCR   = UART_US_CR_INIT;
   \   00000020   0x2050             MOVS     R0,#+80
   \   00000022   0x0006             MOVS     R6,R0
    271                u32TargetMR   = UART_US_MR_INIT; 
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x4008c0
   \   00000028   0x0007             MOVS     R7,R0
    272                u32TargetIER  = UART_US_IER_INIT; 
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4680             MOV      R8,R0
    273                u32TargetIDR  = UART_US_IDR_INIT;
   \   0000002E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000032   0x4681             MOV      R9,R0
    274                u32TargetBRGR = UART_US_BRGR_INIT;
   \   00000034   0x201A             MOVS     R0,#+26
   \   00000036   0x4682             MOV      R10,R0
    275                break;
   \   00000038   0xE032             B.N      ??UartRequest_5
    276              } 
    277          
    278              case USART0:
    279              {
    280                psRequestedUart = &UART_Peripheral0; 
   \                     ??UartRequest_3: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \   0000003E   0x0005             MOVS     R5,R0
    281          
    282                u32TargetCR   = USART0_US_CR_INIT;
   \   00000040   0x2050             MOVS     R0,#+80
   \   00000042   0x0006             MOVS     R6,R0
    283                u32TargetMR   = USART0_US_MR_INIT; 
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x4008c0
   \   00000048   0x0007             MOVS     R7,R0
    284                u32TargetIER  = USART0_US_IER_INIT; 
   \   0000004A   0x2008             MOVS     R0,#+8
   \   0000004C   0x4680             MOV      R8,R0
    285                u32TargetIDR  = USART0_US_IDR_INIT;
   \   0000004E   0xF07F 0x0008      MVNS     R0,#+8
   \   00000052   0x4681             MOV      R9,R0
    286                u32TargetBRGR = USART0_US_BRGR_INIT;
   \   00000054   0x201A             MOVS     R0,#+26
   \   00000056   0x4682             MOV      R10,R0
    287                break;
   \   00000058   0xE022             B.N      ??UartRequest_5
    288              } 
    289          
    290              case USART1:
    291              {
    292                psRequestedUart = &UART_Peripheral1; 
   \                     ??UartRequest_2: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable15_6
   \   0000005E   0x0005             MOVS     R5,R0
    293          
    294                u32TargetCR   = USART1_US_CR_INIT;
   \   00000060   0x2060             MOVS     R0,#+96
   \   00000062   0x0006             MOVS     R6,R0
    295                u32TargetMR   = USART1_US_MR_INIT; 
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x4518ce
   \   00000068   0x0007             MOVS     R7,R0
    296                u32TargetIER  = USART1_US_IER_INIT; 
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x4680             MOV      R8,R0
    297                u32TargetIDR  = USART1_US_IDR_INIT;
   \   0000006E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000072   0x4681             MOV      R9,R0
    298                u32TargetBRGR = USART1_US_BRGR_INIT;
   \   00000074   0x2030             MOVS     R0,#+48
   \   00000076   0x4682             MOV      R10,R0
    299                break;
   \   00000078   0xE012             B.N      ??UartRequest_5
    300              } 
    301              
    302              case USART2:
    303              {
    304                psRequestedUart = &UART_Peripheral2; 
   \                     ??UartRequest_4: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \   0000007E   0x0005             MOVS     R5,R0
    305                
    306                u32TargetCR   = USART2_US_CR_INIT;
   \   00000080   0x2050             MOVS     R0,#+80
   \   00000082   0x0006             MOVS     R6,R0
    307                u32TargetMR   = USART2_US_MR_INIT; 
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable15_9  ;; 0x4118ff
   \   00000088   0x0007             MOVS     R7,R0
    308                u32TargetIER  = USART2_US_IER_INIT; 
   \   0000008A   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000008E   0x4680             MOV      R8,R0
    309                u32TargetIDR  = USART2_US_IDR_INIT;
   \   00000090   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000094   0x4681             MOV      R9,R0
    310                u32TargetBRGR = USART2_US_BRGR_INIT;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x4682             MOV      R10,R0
    311                break;
   \   0000009A   0xE001             B.N      ??UartRequest_5
    312              } 
    313          
    314              default:
    315              {
    316                return(NULL);
   \                     ??UartRequest_1: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE049             B.N      ??UartRequest_6
    317                break;
    318              } 
    319            } /* end switch */
    320          
    321            /* If the requested peripheral is already assigned, return NULL now */
    322            if(psRequestedUart->u32PrivateFlags & _UART_PERIPHERAL_ASSIGNED)
   \                     ??UartRequest_5: (+1)
   \   000000A0   0x7928             LDRB     R0,[R5, #+4]
   \   000000A2   0x07C0             LSLS     R0,R0,#+31
   \   000000A4   0xD501             BPL.N    ??UartRequest_7
    323            {
    324              return(NULL);
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xE044             B.N      ??UartRequest_6
    325            }
    326            
    327            /* Activate and configure the peripheral */
    328            AT91C_BASE_PMC->PMC_PCER |= (1 << psRequestedUart->u8PeripheralId);
   \                     ??UartRequest_7: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable15_10  ;; 0x400e0410
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0xF995 0x2022      LDRSB    R2,[R5, #+34]
   \   000000B6   0x4091             LSLS     R1,R1,R2
   \   000000B8   0x4308             ORRS     R0,R1,R0
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable15_10  ;; 0x400e0410
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    329          
    330            psRequestedUart->pu8RxBuffer     = psUartConfig_->pu8RxBufferAddress;
   \   000000C0   0x6860             LDR      R0,[R4, #+4]
   \   000000C2   0x6168             STR      R0,[R5, #+20]
    331            psRequestedUart->u16RxBufferSize = psUartConfig_->u16RxBufferSize;
   \   000000C4   0x8860             LDRH     R0,[R4, #+2]
   \   000000C6   0x8428             STRH     R0,[R5, #+32]
    332            psRequestedUart->pu8RxNextByte   = psUartConfig_->pu8RxNextByte;
   \   000000C8   0x68A0             LDR      R0,[R4, #+8]
   \   000000CA   0x61A8             STR      R0,[R5, #+24]
    333            psRequestedUart->fnRxCallback    = psUartConfig_->fnRxCallback;
   \   000000CC   0x68E0             LDR      R0,[R4, #+12]
   \   000000CE   0x61E8             STR      R0,[R5, #+28]
    334            psRequestedUart->u32PrivateFlags |= _UART_PERIPHERAL_ASSIGNED;
   \   000000D0   0x6868             LDR      R0,[R5, #+4]
   \   000000D2   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000D6   0x6068             STR      R0,[R5, #+4]
    335            
    336            psRequestedUart->pBaseAddress->US_CR   = u32TargetCR;
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x6006             STR      R6,[R0, #+0]
    337            psRequestedUart->pBaseAddress->US_MR   = u32TargetMR;
   \   000000DC   0x6828             LDR      R0,[R5, #+0]
   \   000000DE   0x6047             STR      R7,[R0, #+4]
    338            psRequestedUart->pBaseAddress->US_IER  = u32TargetIER;
   \   000000E0   0x6828             LDR      R0,[R5, #+0]
   \   000000E2   0xF8C0 0x8008      STR      R8,[R0, #+8]
    339            psRequestedUart->pBaseAddress->US_IDR  = u32TargetIDR;
   \   000000E6   0x6828             LDR      R0,[R5, #+0]
   \   000000E8   0xF8C0 0x900C      STR      R9,[R0, #+12]
    340            psRequestedUart->pBaseAddress->US_BRGR = u32TargetBRGR;
   \   000000EC   0x6828             LDR      R0,[R5, #+0]
   \   000000EE   0xF8C0 0xA020      STR      R10,[R0, #+32]
    341          
    342            /* Preset the receive PDC pointers and counters; the receive buffer must be starting from [0] and be at least 2 bytes long)*/
    343            psRequestedUart->pBaseAddress->US_RPR  = (unsigned int)psUartConfig_->pu8RxBufferAddress;
   \   000000F2   0x6860             LDR      R0,[R4, #+4]
   \   000000F4   0x6829             LDR      R1,[R5, #+0]
   \   000000F6   0xF8C1 0x0100      STR      R0,[R1, #+256]
    344            psRequestedUart->pBaseAddress->US_RNPR = (unsigned int)((psUartConfig_->pu8RxBufferAddress) + 1);
   \   000000FA   0x6860             LDR      R0,[R4, #+4]
   \   000000FC   0x1C40             ADDS     R0,R0,#+1
   \   000000FE   0x6829             LDR      R1,[R5, #+0]
   \   00000100   0xF8C1 0x0110      STR      R0,[R1, #+272]
    345            psRequestedUart->pBaseAddress->US_RCR  = 1;
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0x6829             LDR      R1,[R5, #+0]
   \   00000108   0xF8C1 0x0104      STR      R0,[R1, #+260]
    346            psRequestedUart->pBaseAddress->US_RNCR = 1;
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x6829             LDR      R1,[R5, #+0]
   \   00000110   0xF8C1 0x0114      STR      R0,[R1, #+276]
    347            
    348            /* Enable the receiver and transmitter requests */
    349            psRequestedUart->pBaseAddress->US_PTCR = AT91C_PDC_RXTEN | AT91C_PDC_TXTEN;
   \   00000114   0xF240 0x1001      MOVW     R0,#+257
   \   00000118   0x6829             LDR      R1,[R5, #+0]
   \   0000011A   0xF8C1 0x0120      STR      R0,[R1, #+288]
    350          
    351            /* Enable UART interrupts */
    352            NVIC_ClearPendingIRQ( (IRQn_Type)psRequestedUart->u8PeripheralId );
   \   0000011E   0xF995 0x0022      LDRSB    R0,[R5, #+34]
   \   00000122   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000124   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    353            NVIC_EnableIRQ( (IRQn_Type)psRequestedUart->u8PeripheralId );
   \   00000128   0xF995 0x0022      LDRSB    R0,[R5, #+34]
   \   0000012C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000012E   0x.... 0x....      BL       NVIC_EnableIRQ
    354            
    355            return(psRequestedUart);
   \   00000132   0x0028             MOVS     R0,R5
   \                     ??UartRequest_6: (+1)
   \   00000134   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    356            
    357          } /* end UartRequest() */
    358          
    359          
    360          /*----------------------------------------------------------------------------------------------------------------------
    361          Function: UartRelease
    362          
    363          Description:
    364          Releases a UART resource.  
    365          
    366          Requires:
    367            - psUartPeripheral_ has the UART peripheral number, address of the RxBuffer, and the RxBuffer size and the calling
    368              application is ready to start using the peripheral.
    369          
    370          Promises:
    371            - Resets peripheral object's pointers and data to safe values
    372            - Peripheral is disabled
    373            - Peripheral interrupts are disabled.
    374          */

   \                                 In section .text, align 2, keep-with-next
    375          void UartRelease(UartPeripheralType* psUartPeripheral_)
    376          {
   \                     UartRelease: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    377            /* Check to see if the peripheral is already released */
    378            if(psUartPeripheral_->pu8RxBuffer == NULL)
   \   00000004   0x6960             LDR      R0,[R4, #+20]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD023             BEQ.N    ??UartRelease_0
    379            {
    380              return;
    381            }
    382            
    383            /* First disable the interrupts */
    384            NVIC_DisableIRQ( (IRQn_Type)(psUartPeripheral_->u8PeripheralId) );
   \                     ??UartRelease_1: (+1)
   \   0000000A   0xF994 0x0022      LDRSB    R0,[R4, #+34]
   \   0000000E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       NVIC_DisableIRQ
    385            NVIC_ClearPendingIRQ( (IRQn_Type)(psUartPeripheral_->u8PeripheralId) );
   \   00000014   0xF994 0x0022      LDRSB    R0,[R4, #+34]
   \   00000018   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    386           
    387            /* Now it's safe to release all of the resources in the target peripheral */
    388            psUartPeripheral_->pu8RxBuffer    = NULL;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6160             STR      R0,[R4, #+20]
    389            psUartPeripheral_->pu8RxNextByte  = NULL;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x61A0             STR      R0,[R4, #+24]
    390            psUartPeripheral_->fnRxCallback   = NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x61E0             STR      R0,[R4, #+28]
    391            psUartPeripheral_->u32PrivateFlags = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6060             STR      R0,[R4, #+4]
    392          
    393            /* Empty the transmit buffer if there were leftover messages */
    394            while(psUartPeripheral_->psTransmitBuffer != NULL)
   \                     ??UartRelease_2: (+1)
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD009             BEQ.N    ??UartRelease_3
    395            {
    396              UpdateMessageStatus(psUartPeripheral_->psTransmitBuffer->u32Token, ABANDONED);
   \   00000034   0x2106             MOVS     R1,#+6
   \   00000036   0x68A0             LDR      R0,[R4, #+8]
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      BL       UpdateMessageStatus
    397              DeQueueMessage(&psUartPeripheral_->psTransmitBuffer);
   \   0000003E   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000042   0x.... 0x....      BL       DeQueueMessage
   \   00000046   0xE7F2             B.N      ??UartRelease_2
    398            }
    399            
    400            /* Ensure the SM is in the Idle state */
    401            Uart_pfnStateMachine = UartSM_Idle;
   \                     ??UartRelease_3: (+1)
   \   00000048   0x.... 0x....      ADR.W    R0,UartSM_Idle
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   00000050   0x6008             STR      R0,[R1, #+0]
    402           
    403          } /* end UartRelease() */
   \                     ??UartRelease_0: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    404          
    405          
    406          /*----------------------------------------------------------------------------------------------------------------------
    407          Function: UartWriteByte
    408          
    409          Description:
    410          Queues a single byte for transfer on the target UART peripheral.  
    411          
    412          Requires:
    413            - psUartPeripheral_ has been requested.
    414          
    415          Promises:
    416            - Creates a 1-byte message at psUartPeripheral_->pTransmitBuffer that will be sent by the UART application
    417              when it is available.
    418            - Returns the message token assigned to the message
    419          */

   \                                 In section .text, align 2, keep-with-next
    420          u32 UartWriteByte(UartPeripheralType* psUartPeripheral_, u8 u8Byte_)
    421          {
   \                     UartWriteByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    422            u32 u32Token;
    423            u8 u8Data = u8Byte_;
   \   00000008   0xF88D 0x5000      STRB     R5,[SP, #+0]
    424            
    425            u32Token = QueueMessage(&psUartPeripheral_->psTransmitBuffer, 1, &u8Data);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000014   0x.... 0x....      BL       QueueMessage
   \   00000018   0x0006             MOVS     R6,R0
    426            if( u32Token != 0 )
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD006             BEQ.N    ??UartWriteByte_0
    427            {
    428              /* If the system is initializing, we want to manually cycle the UART task through one iteration
    429              to send the message */
    430              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD501             BPL.N    ??UartWriteByte_0
    431              {
    432                UartManualMode();
   \   00000028   0x.... 0x....      BL       UartManualMode
    433              }
    434            }
    435            
    436            return(u32Token);
   \                     ??UartWriteByte_0: (+1)
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    437            
    438          } /* end UartWriteByte() */
    439          
    440          
    441          /*----------------------------------------------------------------------------------------------------------------------
    442          Function: UartWriteData
    443          
    444          Description:
    445          Queues a data array for transfer on the target UART peripheral.  
    446          
    447          Requires:
    448            - psUartPeripheral_ has been requested and holds a valid pointer to a transmit buffer; even if a transmission is
    449              in progress, the node in the buffer that is currently being sent will not be destroyed during this function.
    450            - u32Size_ is the number of bytes in the data array
    451            - u8Data_ points to the first byte of the data array
    452          
    453          Promises:
    454            - adds the data message at psUartPeripheral_->pTransmitBuffer that will be sent by the UART application
    455              when it is available.
    456            - Returns the message token assigned to the message; 0 is returned if the message cannot be queued in which case
    457              G_u32MessagingFlags can be checked for the reason
    458          */

   \                                 In section .text, align 2, keep-with-next
    459          u32 UartWriteData(UartPeripheralType* psUartPeripheral_, u32 u32Size_, u8* u8Data_)
    460          {
   \                     UartWriteData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    461            u32 u32Token;
    462          
    463            u32Token = QueueMessage(&psUartPeripheral_->psTransmitBuffer, u32Size_, u8Data_);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000010   0x.... 0x....      BL       QueueMessage
   \   00000014   0x0007             MOVS     R7,R0
    464            if(u32Token)
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD006             BEQ.N    ??UartWriteData_0
    465            {
    466              /* If the system is initializing, manually cycle the UART task through one iteration to send the message */
    467              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD501             BPL.N    ??UartWriteData_0
    468              {
    469                UartManualMode();
   \   00000024   0x.... 0x....      BL       UartManualMode
    470              }
    471            }
    472            
    473            return(u32Token);
   \                     ??UartWriteData_0: (+1)
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    474            
    475          } /* end UartWriteData() */
    476          
    477          
    478          /*--------------------------------------------------------------------------------------------------------------------*/
    479          /* Protected Functions */
    480          /*--------------------------------------------------------------------------------------------------------------------*/
    481          
    482          /*----------------------------------------------------------------------------------------------------------------------
    483          Function: UartInitialize
    484          
    485          Description:
    486          Initializes the UART application and its variables.  UART0 is setup to be available immediately for debugging
    487          purposes.  The generic peripherals themselves are not fully configured until requested by a calling application.
    488          
    489          Requires:
    490            - 
    491          
    492          Promises:
    493            - UART peripheral objects are ready 
    494            - UART application set to Idle
    495          */

   \                                 In section .text, align 2, keep-with-next
    496          void UartInitialize(void)
    497          {
    498            UART_u32Flags = 0;
   \                     UartInitialize: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable15_13
   \   00000006   0x6008             STR      R0,[R1, #+0]
    499            
    500            /* Setup generic UARTs */
    501            
    502            /* Initialize the UART peripheral structures */
    503            UART_Peripheral.pBaseAddress     = (AT91S_USART*)AT91C_BASE_DBGU;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable15_14  ;; 0x400e0600
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000010   0x6008             STR      R0,[R1, #+0]
    504            UART_Peripheral.psTransmitBuffer = NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000018   0x6088             STR      R0,[R1, #+8]
    505            UART_Peripheral.pu8RxBuffer      = NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000020   0x6148             STR      R0,[R1, #+20]
    506            UART_Peripheral.u16RxBufferSize  = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000028   0x8408             STRH     R0,[R1, #+32]
    507            UART_Peripheral.pu8RxNextByte    = NULL;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000030   0x6188             STR      R0,[R1, #+24]
    508            UART_Peripheral.u32PrivateFlags  = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000038   0x6048             STR      R0,[R1, #+4]
    509            UART_Peripheral.u8PeripheralId  = AT91C_ID_DBGU;
   \   0000003A   0x2008             MOVS     R0,#+8
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000040   0xF881 0x0022      STRB     R0,[R1, #+34]
    510          
    511            UART_Peripheral0.pBaseAddress    = AT91C_BASE_US0;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable15_15  ;; 0x40090000
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    512            UART_Peripheral0.psTransmitBuffer = NULL;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   00000054   0x6088             STR      R0,[R1, #+8]
    513            UART_Peripheral0.pu8RxBuffer     = NULL;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   0000005C   0x6148             STR      R0,[R1, #+20]
    514            UART_Peripheral0.u16RxBufferSize = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   00000064   0x8408             STRH     R0,[R1, #+32]
    515            UART_Peripheral0.pu8RxNextByte   = NULL;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   0000006C   0x6188             STR      R0,[R1, #+24]
    516            UART_Peripheral0.u32PrivateFlags = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   00000074   0x6048             STR      R0,[R1, #+4]
    517            UART_Peripheral0.u8PeripheralId  = AT91C_ID_US0;
   \   00000076   0x200D             MOVS     R0,#+13
   \   00000078   0x....             LDR.N    R1,??DataTable15_5
   \   0000007A   0xF881 0x0022      STRB     R0,[R1, #+34]
    518          
    519            UART_Peripheral1.pBaseAddress    = AT91C_BASE_US1;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable15_16  ;; 0x40094000
   \   00000082   0x....             LDR.N    R1,??DataTable15_6
   \   00000084   0x6008             STR      R0,[R1, #+0]
    520            UART_Peripheral1.psTransmitBuffer = NULL;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x....             LDR.N    R1,??DataTable15_6
   \   0000008A   0x6088             STR      R0,[R1, #+8]
    521            UART_Peripheral1.pu8RxBuffer     = NULL;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x....             LDR.N    R1,??DataTable15_6
   \   00000090   0x6148             STR      R0,[R1, #+20]
    522            UART_Peripheral1.u16RxBufferSize = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x....             LDR.N    R1,??DataTable15_6
   \   00000096   0x8408             STRH     R0,[R1, #+32]
    523            UART_Peripheral1.pu8RxNextByte   = NULL;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x....             LDR.N    R1,??DataTable15_6
   \   0000009C   0x6188             STR      R0,[R1, #+24]
    524            UART_Peripheral1.u32PrivateFlags = 0;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x....             LDR.N    R1,??DataTable15_6
   \   000000A2   0x6048             STR      R0,[R1, #+4]
    525            UART_Peripheral1.u8PeripheralId  = AT91C_ID_US1;
   \   000000A4   0x200E             MOVS     R0,#+14
   \   000000A6   0x....             LDR.N    R1,??DataTable15_6
   \   000000A8   0xF881 0x0022      STRB     R0,[R1, #+34]
    526          
    527            UART_Peripheral2.pBaseAddress    = AT91C_BASE_US2;
   \   000000AC   0x....             LDR.N    R0,??DataTable15_17  ;; 0x40098000
   \   000000AE   0x....             LDR.N    R1,??DataTable15_8
   \   000000B0   0x6008             STR      R0,[R1, #+0]
    528            UART_Peripheral2.psTransmitBuffer = NULL;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x....             LDR.N    R1,??DataTable15_8
   \   000000B6   0x6088             STR      R0,[R1, #+8]
    529            UART_Peripheral2.pu8RxBuffer     = NULL;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x....             LDR.N    R1,??DataTable15_8
   \   000000BC   0x6148             STR      R0,[R1, #+20]
    530            UART_Peripheral2.u16RxBufferSize = 0;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x....             LDR.N    R1,??DataTable15_8
   \   000000C2   0x8408             STRH     R0,[R1, #+32]
    531            UART_Peripheral2.pu8RxNextByte   = NULL;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x....             LDR.N    R1,??DataTable15_8
   \   000000C8   0x6188             STR      R0,[R1, #+24]
    532            UART_Peripheral2.u32PrivateFlags = 0;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x....             LDR.N    R1,??DataTable15_8
   \   000000CE   0x6048             STR      R0,[R1, #+4]
    533            UART_Peripheral2.u8PeripheralId  = AT91C_ID_US2;
   \   000000D0   0x200F             MOVS     R0,#+15
   \   000000D2   0x....             LDR.N    R1,??DataTable15_8
   \   000000D4   0xF881 0x0022      STRB     R0,[R1, #+34]
    534            
    535            UART_psCurrentUart               = &UART_Peripheral;
   \   000000D8   0x....             LDR.N    R0,??DataTable15_3
   \   000000DA   0x....             LDR.N    R1,??DataTable15_18
   \   000000DC   0x6008             STR      R0,[R1, #+0]
    536          
    537            /* Set application pointer */
    538            Uart_pfnStateMachine = UartSM_Idle;
   \   000000DE   0x.... 0x....      ADR.W    R0,UartSM_Idle
   \   000000E2   0x....             LDR.N    R1,??DataTable15_11
   \   000000E4   0x6008             STR      R0,[R1, #+0]
    539            
    540          } /* end UartInitialize() */
   \   000000E6   0x4770             BX       LR               ;; return
    541          
    542          
    543          /*----------------------------------------------------------------------------------------------------------------------
    544          Function UartRunActiveState()
    545          
    546          Description:
    547          Selects and runs one iteration of the current state in the state machine.
    548          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    549          may take 1ms / n to execute.
    550          
    551          Requires:
    552            - State machine function pointer points at current state
    553          
    554          Promises:
    555            - Calls the function to pointed by the state machine function pointer
    556          */

   \                                 In section .text, align 2, keep-with-next
    557          void UartRunActiveState(void)
    558          {
   \                     UartRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    559            Uart_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable15_11
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    560          
    561          } /* end UartRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    562          
    563          
    564          
    565          /*--------------------------------------------------------------------------------------------------------------------*/
    566          /* Private functions */
    567          /*--------------------------------------------------------------------------------------------------------------------*/
    568          
    569          
    570          /*----------------------------------------------------------------------------------------------------------------------
    571          Function: UartManualMode
    572          
    573          Description:
    574          Runs a transmit cycle of the UART application to clock out a message.  This function is used only during
    575          initialization.
    576          
    577          Requires:
    578            - UART application has been initialized.
    579          
    580          Promises:
    581            - All bytes currently in the UART Rx FIFO are read out to the application receive circular buffer.
    582          */

   \                                 In section .text, align 2, keep-with-next
    583          static void UartManualMode(void)
    584          {
    585          #ifndef SIMULATOR_MODE
    586            UART_u32Flags |=_UART_MANUAL_MODE;
    587            UART_psCurrentUart = &UART_Peripheral;
    588            
    589            while(UART_u32Flags &_UART_MANUAL_MODE)
    590            {
    591              Uart_pfnStateMachine();
    592              UART_u32Timer  = G_u32SystemTime1ms;
    593              IsTimeUp(&UART_u32Timer, 1);
    594            }
    595          #endif /* SIMULATOR_MODE */
    596            
    597          } /* end UartManualMode() */
   \                     UartManualMode: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    598          
    599          
    600          #ifdef USE_SIMPLE_USART0
    601          /*----------------------------------------------------------------------------------------------------------------------
    602          Interrupt Service Routine: UART0_IRQHandler
    603          
    604          Description:
    605          Handles the enabled UART0 interrupts. 
    606          Receive: The UART peripheral is always enabled and ready to receive data.  Receive interrupts will occur when a
    607          new byte has been read by the peripheral. All incoming data is dumped into the circular receive data buffer UART_au8U0RxBuffer.
    608          No processing is done on the data - it is up to the processing application to parse incoming data to find useful information
    609          and to manage dummy bytes.
    610          
    611          Note that if the Rx buffer is not read and U0RX_BUFFER_SIZE characters come in, all data will be lost because of the popinter wrap.
    612          
    613          Transmit: All data bytes in the transmit buffer are immediately sent as fast as the interrupt can process them.
    614          
    615          Requires:
    616            - Only TXEMPTY and RXRDY interrupts are ever enabled
    617            - Transmit and receive buffers should be correctly configured 
    618          
    619          Promises:
    620            - If ENDRX interrupt occurs, the received character is deposited in UART_au8U0RxBuffer
    621            - If ENDTX interrupt occurs, the transmit buffer is checked to see if another character should be queued to the peripheral
    622          */
    623          
    624          void USART0_IrqHandler(void)
    625          {
    626            /* Check which interrupt has occurred */
    627            if(AT91C_BASE_US0->US_CSR & AT91C_US_RXRDY)
    628            {
    629              /* Move the received character into the buffer - clears the RXRDY flag */
    630              *UART_pu8U0RxBufferNextChar = (u8)(AT91C_BASE_US0->US_RHR);
    631              
    632              /* Safely advance the pointer */
    633              UART_pu8U0RxBufferNextChar++;
    634              if(UART_pu8U0RxBufferNextChar == &UART_au8U0RxBuffer[U0RX_BUFFER_SIZE])
    635              {
    636                UART_pu8U0RxBufferNextChar = &UART_au8U0RxBuffer[0];
    637              }
    638            }
    639          #if 0
    640            if(AT91C_BASE_US0->US_CSR & AT91C_US_TXEMPTY)
    641            {
    642              /* If the transmit buffer has more data to send, then queue the next byte */
    643              if(UART_pu8U0TxBufferUnsentChar != UART_pu8U0TxBufferNextChar)
    644              {
    645                /* Queue the next byte */
    646                AT91C_BASE_US0->US_THR = *UART_pu8U0TxBufferUnsentChar;
    647          
    648                /* Safely advance the pointer */
    649                UART_pu8U0TxBufferUnsentChar++;
    650                if(UART_pu8U0TxBufferUnsentChar == &UART_au8U0TxBuffer[U0TX_BUFFER_SIZE])
    651                {
    652                  UART_pu8U0TxBufferUnsentChar = &UART_au8U0TxBuffer[0];
    653                }
    654              }
    655              /* Otherwise all data has been sent */
    656              else
    657              {
    658                UART_u32Flags &= _UART_U0_SENDING;
    659                AT91C_BASE_US0->US_IER = AT91C_US_TXEMPTY;
    660              }
    661            }
    662          #endif
    663          } /* end UART0_IRQHandler() */
    664          #endif /* USE_SIMPLE_USART0 */
    665          
    666          
    667          /*----------------------------------------------------------------------------------------------------------------------
    668          Interrupt Service Routine: UART_IRQHandler
    669          
    670          Description:
    671          Handles the enabled UART interrupts for the current UART. 
    672          
    673          
    674          Requires:
    675            - No other interrupts UART interrupts may be active
    676          
    677          Promises:
    678            - Gets the current interrupt context and proceeds to the Generic handler
    679          */
    680          

   \                                 In section .text, align 2, keep-with-next
    681          void UART_IRQHandler(void)
    682          {
   \                     DBGU_IrqHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    683            /* Set the current ISR pointers to SSP1 targets */
    684            UART_psCurrentISR = &UART_Peripheral;                          /* Current UART ISR */
   \   00000002   0x....             LDR.N    R0,??DataTable15_3
   \   00000004   0x....             LDR.N    R1,??DataTable15_19
   \   00000006   0x6008             STR      R0,[R1, #+0]
    685            UART_pu32ApplicationFlagsISR = &G_u32UartApplicationFlags;     /* Current UART application status flags */
   \   00000008   0x....             LDR.N    R0,??DataTable15_20
   \   0000000A   0x....             LDR.N    R1,??DataTable15_21
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    686            UART_u32IntCount++;
   \   0000000E   0x....             LDR.N    R0,??DataTable15_22
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable15_22
   \   00000016   0x6008             STR      R0,[R1, #+0]
    687          
    688            /* Go to common SSP interrupt using psCurrentSspISR since the SSP cannot interrupt itself */
    689            UartGenericHandler();
   \   00000018   0x.... 0x....      BL       UartGenericHandler
    690          
    691          } /* end UART_IRQHandler() */
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    692          
    693          
    694          /*----------------------------------------------------------------------------------------------------------------------
    695          Interrupt Service Routine: UART0_IRQHandler
    696          
    697          Description:
    698          Handles the enabled UART interrupts for the current UART. 
    699          
    700          
    701          Requires:
    702            - No other interrupts UART interrupts may be active
    703          
    704          Promises:
    705            - Gets the current interrupt context and proceeds to the Generic handler
    706          */
    707          

   \                                 In section .text, align 2, keep-with-next
    708          void UART0_IRQHandler(void)
    709          {
   \                     USART0_IrqHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    710            /* Set the current ISR pointers to SSP1 targets */
    711            UART_psCurrentISR = &UART_Peripheral0;                          /* Current UART ISR */
   \   00000002   0x....             LDR.N    R0,??DataTable15_5
   \   00000004   0x....             LDR.N    R1,??DataTable15_19
   \   00000006   0x6008             STR      R0,[R1, #+0]
    712            UART_pu32ApplicationFlagsISR = &G_u32Uart0ApplicationFlags;     /* Current UART application status flags */
   \   00000008   0x....             LDR.N    R0,??DataTable15_23
   \   0000000A   0x....             LDR.N    R1,??DataTable15_21
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    713            UART_u32Int0Count++;
   \   0000000E   0x....             LDR.N    R0,??DataTable15_24
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable15_24
   \   00000016   0x6008             STR      R0,[R1, #+0]
    714          
    715            /* Go to common interrupt */
    716            UartGenericHandler();
   \   00000018   0x.... 0x....      BL       UartGenericHandler
    717          
    718          } /* end UART0_IRQHandler() */
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    719          
    720          
    721          /*----------------------------------------------------------------------------------------------------------------------
    722          Interrupt Service Routine: UART1_IRQHandler
    723          
    724          Description:
    725          Handles the enabled UART interrupts for the current UART. 
    726          
    727          
    728          Requires:
    729            - No other interrupts UART interrupts may be active
    730          
    731          Promises:
    732            - Gets the current interrupt context and proceeds to the Generic handler
    733          */
    734          

   \                                 In section .text, align 2, keep-with-next
    735          void UART1_IRQHandler(void)
    736          {
   \                     UART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    737            /* Set the current ISR pointers to SSP1 targets */
    738            UART_psCurrentISR = &UART_Peripheral1;                          /* Current UART ISR */
   \   00000002   0x....             LDR.N    R0,??DataTable15_6
   \   00000004   0x....             LDR.N    R1,??DataTable15_19
   \   00000006   0x6008             STR      R0,[R1, #+0]
    739            UART_pu32ApplicationFlagsISR = &G_u32Uart1ApplicationFlags;     /* Current UART application status flags */
   \   00000008   0x....             LDR.N    R0,??DataTable15_25
   \   0000000A   0x....             LDR.N    R1,??DataTable15_21
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    740            UART_u32Int1Count++;
   \   0000000E   0x....             LDR.N    R0,??DataTable15_26
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable15_26
   \   00000016   0x6008             STR      R0,[R1, #+0]
    741          
    742            /* Go to common interrupt */
    743            UartGenericHandler();
   \   00000018   0x.... 0x....      BL       UartGenericHandler
    744          
    745          } /* end UART1_IRQHandler() */
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    746          
    747          
    748          /*----------------------------------------------------------------------------------------------------------------------
    749          Interrupt Service Routine: UART2_IRQHandler
    750          
    751          Description:
    752          Handles the enabled UART interrupts for the current UART. 
    753          
    754          
    755          Requires:
    756            - No other interrupts UART interrupts may be active
    757          
    758          Promises:
    759            - Gets the current interrupt context and proceeds to the Generic handler
    760          */
    761          

   \                                 In section .text, align 2, keep-with-next
    762          void UART2_IRQHandler(void)
    763          {
   \                     UART2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    764            /* Set the current ISR pointers to SSP1 targets */
    765            UART_psCurrentISR = &UART_Peripheral2;                          /* Current UART ISR */
   \   00000002   0x....             LDR.N    R0,??DataTable15_8
   \   00000004   0x....             LDR.N    R1,??DataTable15_19
   \   00000006   0x6008             STR      R0,[R1, #+0]
    766            UART_pu32ApplicationFlagsISR = &G_u32Uart2ApplicationFlags;     /* Current UART application status flags */
   \   00000008   0x....             LDR.N    R0,??DataTable15_27
   \   0000000A   0x....             LDR.N    R1,??DataTable15_21
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    767            UART_u32Int2Count++;
   \   0000000E   0x....             LDR.N    R0,??DataTable15_28
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable15_28
   \   00000016   0x6008             STR      R0,[R1, #+0]
    768          
    769            /* Go to common interrupt */
    770            UartGenericHandler();
   \   00000018   0x.... 0x....      BL       UartGenericHandler
    771          
    772          } /* end UART2_IRQHandler() */
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    773          
    774          
    775          /*----------------------------------------------------------------------------------------------------------------------
    776          Generic Interrupt Service Routine
    777          
    778          Description:
    779          Receive: A requested UART peripheral is always enabled and ready to receive data.  Receive interrupts will occur when a
    780          new byte has been read by the peripheral. All incoming data is dumped into the circular receive data buffer configured.
    781          No processing is done on the data - it is up to the processing application to parse incoming data to find useful information
    782          and to manage dummy bytes.  All data reception is done with DMA, but only 1 byte at a time.  Receiving is done by using
    783          the two reception pointers to ensure no data is missed.
    784          
    785          Transmit: All data bytes in the transmit buffer are sent using DMA and interrupts. Once the full message has been sent,
    786          the message status is updated.
    787          */

   \                                 In section .text, align 2, keep-with-next
    788          void UartGenericHandler(void)
    789          {
   \                     UartGenericHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    790            /* ENDRX Interrupt when a byte has been received (RNCR is moved to RCR; RNPR is copied to RPR))*/
    791            if( (UART_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDRX) && 
    792                (UART_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_ENDRX) )
   \   00000002   0x....             LDR.N    R0,??DataTable15_19
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0x0700             LSLS     R0,R0,#+28
   \   0000000C   0xD538             BPL.N    ??UartGenericHandler_0
   \   0000000E   0x....             LDR.N    R0,??DataTable15_19
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0x0700             LSLS     R0,R0,#+28
   \   00000018   0xD532             BPL.N    ??UartGenericHandler_0
    793            {
    794              /* Flag that a byte has arrived */
    795              *UART_pu32ApplicationFlagsISR |= _UART_RX_COMPLETE;
   \   0000001A   0x....             LDR.N    R0,??DataTable15_21
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000024   0x....             LDR.N    R1,??DataTable15_21
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x6008             STR      R0,[R1, #+0]
    796          
    797              /* Update the "next" DMA pointer to the next valid Rx location */
    798              UART_psCurrentISR->pBaseAddress->US_RNPR++;
   \   0000002A   0x....             LDR.N    R0,??DataTable15_19
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF8D0 0x0110      LDR      R0,[R0, #+272]
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0x....             LDR.N    R1,??DataTable15_19
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x6809             LDR      R1,[R1, #+0]
   \   0000003C   0xF8C1 0x0110      STR      R0,[R1, #+272]
    799              if(UART_psCurrentISR->pBaseAddress->US_RNPR == (u32)(UART_psCurrentISR->pu8RxBuffer + (u32)UART_psCurrentISR->u16RxBufferSize) )
   \   00000040   0x....             LDR.N    R0,??DataTable15_19
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF8D0 0x0110      LDR      R0,[R0, #+272]
   \   0000004A   0x....             LDR.N    R1,??DataTable15_19
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x6949             LDR      R1,[R1, #+20]
   \   00000050   0x....             LDR.N    R2,??DataTable15_19
   \   00000052   0x6812             LDR      R2,[R2, #+0]
   \   00000054   0x8C12             LDRH     R2,[R2, #+32]
   \   00000056   0x1851             ADDS     R1,R2,R1
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD107             BNE.N    ??UartGenericHandler_1
    800              {
    801                UART_psCurrentISR->pBaseAddress->US_RNPR = (u32)UART_psCurrentISR->pu8RxBuffer;  /* !!!!! CHECK */
   \   0000005C   0x....             LDR.N    R0,??DataTable15_19
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x6940             LDR      R0,[R0, #+20]
   \   00000062   0x....             LDR.N    R1,??DataTable15_19
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0xF8C1 0x0110      STR      R0,[R1, #+272]
    802              }
    803          
    804              /* Invoke the callback */
    805              UART_psCurrentISR->fnRxCallback();
   \                     ??UartGenericHandler_1: (+1)
   \   0000006C   0x....             LDR.N    R0,??DataTable15_19
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x69C0             LDR      R0,[R0, #+28]
   \   00000072   0x4780             BLX      R0
    806              
    807              /* Write RNCR to 1 to clear the ENDRX flag */
    808              UART_psCurrentISR->pBaseAddress->US_RNCR = 1;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x....             LDR.N    R1,??DataTable15_19
   \   00000078   0x6809             LDR      R1,[R1, #+0]
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0xF8C1 0x0114      STR      R0,[R1, #+276]
    809            }
    810          
    811            
    812            /* ENDTX Interrupt when all requested transmit bytes have been sent (if enabled) */
    813            if( (UART_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDTX) && 
    814                (UART_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_ENDTX) )
   \                     ??UartGenericHandler_0: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable15_19
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x6900             LDR      R0,[R0, #+16]
   \   00000088   0x06C0             LSLS     R0,R0,#+27
   \   0000008A   0xD532             BPL.N    ??UartGenericHandler_2
   \   0000008C   0x....             LDR.N    R0,??DataTable15_19
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x6940             LDR      R0,[R0, #+20]
   \   00000094   0x06C0             LSLS     R0,R0,#+27
   \   00000096   0xD52C             BPL.N    ??UartGenericHandler_2
    815            {
    816              /* Update this message token status and then DeQueue it */
    817              UpdateMessageStatus(UART_psCurrentISR->psTransmitBuffer->u32Token, COMPLETE);
   \   00000098   0x2104             MOVS     R1,#+4
   \   0000009A   0x....             LDR.N    R0,??DataTable15_19
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x6880             LDR      R0,[R0, #+8]
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x.... 0x....      BL       UpdateMessageStatus
    818              DeQueueMessage( &UART_psCurrentISR->psTransmitBuffer );
   \   000000A6   0x....             LDR.N    R0,??DataTable15_19
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x3008             ADDS     R0,R0,#+8
   \   000000AC   0x.... 0x....      BL       DeQueueMessage
    819              UART_psCurrentISR->u32PrivateFlags &= ~_UART_PERIPHERAL_TX;
   \   000000B0   0x....             LDR.N    R0,??DataTable15_19
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x6840             LDR      R0,[R0, #+4]
   \   000000B6   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   000000BA   0x....             LDR.N    R1,??DataTable15_19
   \   000000BC   0x6809             LDR      R1,[R1, #+0]
   \   000000BE   0x6048             STR      R0,[R1, #+4]
    820                  
    821              /* Disable the transmitter and interrupt source */
    822              UART_psCurrentISR->pBaseAddress->US_PTCR = AT91C_PDC_TXTDIS;
   \   000000C0   0xF44F 0x7000      MOV      R0,#+512
   \   000000C4   0x....             LDR.N    R1,??DataTable15_19
   \   000000C6   0x6809             LDR      R1,[R1, #+0]
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0xF8C1 0x0120      STR      R0,[R1, #+288]
    823              UART_psCurrentISR->pBaseAddress->US_IDR  = AT91C_US_ENDTX;
   \   000000CE   0x2010             MOVS     R0,#+16
   \   000000D0   0x....             LDR.N    R1,??DataTable15_19
   \   000000D2   0x6809             LDR      R1,[R1, #+0]
   \   000000D4   0x6809             LDR      R1,[R1, #+0]
   \   000000D6   0x60C8             STR      R0,[R1, #+12]
    824              
    825              /* Decrement # of active UARTs */
    826              if(UART_u8ActiveUarts != 0)
   \   000000D8   0x....             LDR.N    R0,??DataTable15_29
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD005             BEQ.N    ??UartGenericHandler_3
    827              {
    828                UART_u8ActiveUarts--;
   \   000000E0   0x....             LDR.N    R0,??DataTable15_29
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x1E40             SUBS     R0,R0,#+1
   \   000000E6   0x....             LDR.N    R1,??DataTable15_29
   \   000000E8   0x7008             STRB     R0,[R1, #+0]
   \   000000EA   0xE002             B.N      ??UartGenericHandler_2
    829              }
    830              else
    831              {
    832                /* If UART_u8ActiveUarts is already 0, then we are not properly synchronized */
    833                DebugPrintf("\n\rUART counter out of sync\n\r");
   \                     ??UartGenericHandler_3: (+1)
   \   000000EC   0x....             LDR.N    R0,??DataTable15_30
   \   000000EE   0x.... 0x....      BL       DebugPrintf
    834              }
    835            }
    836            
    837          } /* end SspGenericHandler() */
   \                     ??UartGenericHandler_2: (+1)
   \   000000F2   0xBD01             POP      {R0,PC}          ;; return
    838          
    839          
    840          /***********************************************************************************************************************
    841          State Machine Function Definitions
    842          
    843          The UART state machine monitors messaging activity on the available UART peripherals.  It manages outgoing messages and will
    844          transmit any bytes that has been queued.  Only one message will be transferred at once (e.g. UART1 and UART2 will not both 
    845          send at the same time, though both peripherals will continue to receive simultaneously).
    846          Since all transmit and receive bytes are transferred using interrupts, the SM does not have to worry about prioritizing.
    847          
    848          Transmitting on USART 0:
    849          When UART_pu8U0TxBufferUnsentChar doesn't match UART_pu8U0TxBufferNextChar, then we know that there is data to send.
    850          Data transfer is initiated by writing the first byte and setting the _UART_U0_SENDING flag to keep the USART state machine 
    851          busy sending all of the current data on the USART.  The interrupt service routine will be responsible for clearing the
    852          bit which will allow the SM to return to Idle.  
    853          
    854          Receiving on USART 0:
    855          Since the UART can only talk to one device, we will hard-code some of the functionality.  Reception of bytes will
    856          simply dump into the UartRxBuffer and the task interested in those bytes can read the data.  In this case, we
    857          know that this is only the Debug / User interface task.  Though other tasks could also access the buffer, we
    858          assume they won't.
    859          
    860          ***********************************************************************************************************************/
    861          
    862          /*-------------------------------------------------------------------------------------------------------------------*/
    863          /* Wait for a transmit message to be queued.  Received data is handled in interrupts. */

   \                                 In section .text, align 4, keep-with-next
    864          void UartSM_Idle(void)
    865          {
   \                     UartSM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    866          #if USE_SIMPLE_USART0
    867            u8 u8Temp;
    868          
    869            /* Send on the debug UART */
    870            if( (UART_pu8U0TxBufferUnsentChar != UART_pu8U0TxBufferNextChar) && !(UART_u32Flags & _UART_U0_SENDING) )
    871            {
    872              /* Flag that a send on U0 is in progress */
    873              UART_u32Flags |= _UART_U0_SENDING;
    874              
    875              /* Get a copy of the next byte and safely advance the pointer */
    876              u8Temp = *UART_pu8U0TxBufferUnsentChar;
    877              UART_pu8U0TxBufferUnsentChar++;
    878              if(UART_pu8U0TxBufferUnsentChar == &UART_au8U0TxBuffer[U0TX_BUFFER_SIZE])
    879              {
    880                UART_pu8U0TxBufferUnsentChar = &UART_au8U0TxBuffer[0];
    881              }
    882              
    883              /* Queue the next byte and enable the Tx interrupt */
    884              AT91C_BASE_US0->US_THR = u8Temp;
    885              AT91C_BASE_US0->US_IER = AT91C_US_TXEMPTY;
    886            }
    887          #endif /* USE_SIMPLE_USART0 */
    888          
    889            /* Check all UART peripherals for message activity or skip the current peripheral if it is already busy sending.
    890            All receive functions take place outside of the state machine.
    891            Devices sending a message will have UART_psCurrentSsp->psTransmitBuffer->pu8Message pointing to the message to send. */
    892            if( (UART_psCurrentUart->psTransmitBuffer != NULL) && 
    893               !(UART_psCurrentUart->u32PrivateFlags & _UART_PERIPHERAL_TX ) )
   \   00000002   0x....             LDR.N    R0,??DataTable15_18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD036             BEQ.N    ??UartSM_Idle_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15_18
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0x0280             LSLS     R0,R0,#+10
   \   00000014   0xD431             BMI.N    ??UartSM_Idle_0
    894            {
    895              /* Transmitting: update the message's status and flag that the peripheral is now busy */
    896              UpdateMessageStatus(UART_psCurrentUart->psTransmitBuffer->u32Token, SENDING);
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x....             LDR.N    R0,??DataTable15_18
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       UpdateMessageStatus
    897              UART_psCurrentUart->u32PrivateFlags |= _UART_PERIPHERAL_TX;    
   \   00000024   0x....             LDR.N    R0,??DataTable15_18
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   0000002E   0x....             LDR.N    R1,??DataTable15_18
   \   00000030   0x6809             LDR      R1,[R1, #+0]
   \   00000032   0x6048             STR      R0,[R1, #+4]
    898                
    899              /* Load the PDC counter and pointer registers */
    900              UART_psCurrentUart->pBaseAddress->US_TPR = (unsigned int)UART_psCurrentUart->psTransmitBuffer->pu8Message; /* CHECK */
   \   00000034   0x....             LDR.N    R0,??DataTable15_18
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x6880             LDR      R0,[R0, #+8]
   \   0000003A   0x3008             ADDS     R0,R0,#+8
   \   0000003C   0x....             LDR.N    R1,??DataTable15_18
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0xF8C1 0x0108      STR      R0,[R1, #+264]
    901              UART_psCurrentUart->pBaseAddress->US_TCR = UART_psCurrentUart->psTransmitBuffer->u32Size;
   \   00000046   0x....             LDR.N    R0,??DataTable15_18
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x6880             LDR      R0,[R0, #+8]
   \   0000004C   0x6840             LDR      R0,[R0, #+4]
   \   0000004E   0x....             LDR.N    R1,??DataTable15_18
   \   00000050   0x6809             LDR      R1,[R1, #+0]
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0xF8C1 0x010C      STR      R0,[R1, #+268]
    902          
    903              /* When TCR is loaded, the ENDTX flag is cleared so it is safe to enable the interrupt */
    904              UART_psCurrentUart->pBaseAddress->US_IER = AT91C_US_ENDTX;
   \   00000058   0x2010             MOVS     R0,#+16
   \   0000005A   0x....             LDR.N    R1,??DataTable15_18
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0x6088             STR      R0,[R1, #+8]
    905              
    906              /* Update active UART count and enable the transmitter to start the transfer */
    907              UART_u8ActiveUarts++;
   \   00000062   0x....             LDR.N    R0,??DataTable15_29
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable15_29
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
    908              UART_psCurrentUart->pBaseAddress->US_PTCR = AT91C_PDC_TXTEN;
   \   0000006C   0xF44F 0x7080      MOV      R0,#+256
   \   00000070   0x....             LDR.N    R1,??DataTable15_18
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0x6809             LDR      R1,[R1, #+0]
   \   00000076   0xF8C1 0x0120      STR      R0,[R1, #+288]
    909            }
    910            
    911            /* Adjust to check the next peripheral next time through */
    912            switch (UART_psCurrentUart->u8PeripheralId)
   \                     ??UartSM_Idle_0: (+1)
   \   0000007A   0x....             LDR.N    R0,??DataTable15_18
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xF890 0x0022      LDRB     R0,[R0, #+34]
   \   00000082   0x2808             CMP      R0,#+8
   \   00000084   0xD006             BEQ.N    ??UartSM_Idle_1
   \   00000086   0x280D             CMP      R0,#+13
   \   00000088   0xD008             BEQ.N    ??UartSM_Idle_2
   \   0000008A   0x280E             CMP      R0,#+14
   \   0000008C   0xD00A             BEQ.N    ??UartSM_Idle_3
   \   0000008E   0x280F             CMP      R0,#+15
   \   00000090   0xD00C             BEQ.N    ??UartSM_Idle_4
   \   00000092   0xE01D             B.N      ??UartSM_Idle_5
    913            {
    914              case AT91C_ID_DBGU:
    915                UART_psCurrentUart = &UART_Peripheral0;
   \                     ??UartSM_Idle_1: (+1)
   \   00000094   0x....             LDR.N    R0,??DataTable15_5
   \   00000096   0x....             LDR.N    R1,??DataTable15_18
   \   00000098   0x6008             STR      R0,[R1, #+0]
    916                break;
   \   0000009A   0xE01C             B.N      ??UartSM_Idle_6
    917          
    918              case AT91C_ID_US0:
    919                UART_psCurrentUart = &UART_Peripheral1;
   \                     ??UartSM_Idle_2: (+1)
   \   0000009C   0x....             LDR.N    R0,??DataTable15_6
   \   0000009E   0x....             LDR.N    R1,??DataTable15_18
   \   000000A0   0x6008             STR      R0,[R1, #+0]
    920                break;
   \   000000A2   0xE018             B.N      ??UartSM_Idle_6
    921          
    922              case AT91C_ID_US1:
    923                UART_psCurrentUart = &UART_Peripheral2;
   \                     ??UartSM_Idle_3: (+1)
   \   000000A4   0x....             LDR.N    R0,??DataTable15_8
   \   000000A6   0x....             LDR.N    R1,??DataTable15_18
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    924                break;
   \   000000AA   0xE014             B.N      ??UartSM_Idle_6
    925          
    926              case AT91C_ID_US2:
    927                UART_psCurrentUart = &UART_Peripheral;
   \                     ??UartSM_Idle_4: (+1)
   \   000000AC   0x....             LDR.N    R0,??DataTable15_3
   \   000000AE   0x....             LDR.N    R1,??DataTable15_18
   \   000000B0   0x6008             STR      R0,[R1, #+0]
    928                
    929                /* Only clear _UART_MANUAL_MODE if all UARTs are done sending to ensure messages are sent during initialization */
    930                if( (G_u32SystemFlags & _SYSTEM_INITIALIZING) && !UART_u8ActiveUarts)
   \   000000B2   0x....             LDR.N    R0,??DataTable15_12
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD509             BPL.N    ??UartSM_Idle_7
   \   000000BA   0x....             LDR.N    R0,??DataTable15_29
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD105             BNE.N    ??UartSM_Idle_7
    931                {
    932                  UART_u32Flags &= ~_UART_MANUAL_MODE;
   \   000000C2   0x....             LDR.N    R0,??DataTable15_13
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x0840             LSRS     R0,R0,#+1
   \   000000C8   0x0040             LSLS     R0,R0,#+1
   \   000000CA   0x....             LDR.N    R1,??DataTable15_13
   \   000000CC   0x6008             STR      R0,[R1, #+0]
    933                }
    934                break;
   \                     ??UartSM_Idle_7: (+1)
   \   000000CE   0xE002             B.N      ??UartSM_Idle_6
    935          
    936              default:
    937                UART_psCurrentUart = &UART_Peripheral;
   \                     ??UartSM_Idle_5: (+1)
   \   000000D0   0x....             LDR.N    R0,??DataTable15_3
   \   000000D2   0x....             LDR.N    R1,??DataTable15_18
   \   000000D4   0x6008             STR      R0,[R1, #+0]
    938                break;
    939            } /* end switch */
    940            
    941          } /* end UartSM_Idle() */
   \                     ??UartSM_Idle_6: (+1)
   \   000000D6   0xBD01             POP      {R0,PC}          ;; return
    942          
    943          
    944          #ifdef USE_SIMPLE_USART0        
    945          /*-------------------------------------------------------------------------------------------------------------------*/
    946          /* Transmit in progress until current bytes have reached 0.  On exit, the transmit message must be dequeued.
    947          */
    948          void UartSM_Transmitting(void)
    949          {
    950            /* Check if all of the message bytes have completely finished sending */
    951            if( (UART_u32CurrentTxBytesRemaining == 0) && 
    952                (UART_psCurrentUart->pBaseAddress->US_IER & AT91C_US_TXEMPTY) )
    953            {
    954              /* Update the status queue and then dequeue the message */
    955              UpdateMessageStatus(UART_psCurrentUart->pTransmitBuffer->u32Token, COMPLETE);
    956              DeQueueMessage(&UART_psCurrentUart->pTransmitBuffer);
    957          
    958              /* Make sure _UART_INIT_MODE flag is clear in case this was a manual cycle */
    959              UART_u32Flags &= ~_UART_INIT_MODE;
    960              Uart_pfnStateMachine = UartSM_Idle;
    961            }
    962              
    963          } /* end UartSM_Transmitting() */
    964          #endif /* USE_SIMPLE_USART0 */
    965          
    966          /*-------------------------------------------------------------------------------------------------------------------*/
    967          /* Handle an error */

   \                                 In section .text, align 2, keep-with-next
    968          void UartSM_Error(void)          
    969          {
    970            UART_u32Flags &= ~UART_ERROR_FLAG_MASK;
   \                     UartSM_Error: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_13
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000006   0x0A00             LSRS     R0,R0,#+8
   \   00000008   0x....             LDR.N    R1,??DataTable15_13
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    971            
    972            Uart_pfnStateMachine = UartSM_Idle;
   \   0000000C   0x....             LDR.N    R0,??DataTable15_31
   \   0000000E   0x....             LDR.N    R1,??DataTable15_11
   \   00000010   0x6008             STR      R0,[R1, #+0]
    973            
    974          } /* end UartSM_Error() */
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     UART_Peripheral

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x004008C0         DC32     0x4008c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x........         DC32     UART_Peripheral0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     UART_Peripheral1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x004518CE         DC32     0x4518ce

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x........         DC32     UART_Peripheral2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x004118FF         DC32     0x4118ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x400E0410         DC32     0x400e0410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x........         DC32     Uart_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x........         DC32     UART_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x400E0600         DC32     0x400e0600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0x40090000         DC32     0x40090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   0x40094000         DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   0x........         DC32     UART_psCurrentUart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \   00000000   0x........         DC32     UART_psCurrentISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_20:
   \   00000000   0x........         DC32     G_u32UartApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_21:
   \   00000000   0x........         DC32     UART_pu32ApplicationFlagsISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_22:
   \   00000000   0x........         DC32     UART_u32IntCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_23:
   \   00000000   0x........         DC32     G_u32Uart0ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_24:
   \   00000000   0x........         DC32     UART_u32Int0Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_25:
   \   00000000   0x........         DC32     G_u32Uart1ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_26:
   \   00000000   0x........         DC32     UART_u32Int1Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_27:
   \   00000000   0x........         DC32     G_u32Uart2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_28:
   \   00000000   0x........         DC32     UART_u32Int2Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_29:
   \   00000000   0x........         DC32     UART_u8ActiveUarts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_30:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_31:
   \   00000000   0x........         DC32     UartSM_Idle

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0A 0x0D          DC8 "\012\015UART counter out of sync\012\015"
   \              0x55 0x41    
   \              0x52 0x54    
   \              0x20 0x63    
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x73 0x79    
   \              0x6E 0x63    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    975          
    976                    
    977                    
    978                    
    979                    
    980                  
    981          /*--------------------------------------------------------------------------------------------------------------------*/
    982          /* End of File */
    983          /*--------------------------------------------------------------------------------------------------------------------*/
    984          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DBGU_IrqHandler
         8   -> UartGenericHandler
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   UART1_IRQHandler
         8   -> UartGenericHandler
       8   UART2_IRQHandler
         8   -> UartGenericHandler
       8   USART0_IrqHandler
         8   -> UartGenericHandler
       8   UartGenericHandler
         8   -- Indirect call
         8   -> DeQueueMessage
         8   -> DebugPrintf
         8   -> UpdateMessageStatus
       0   UartInitialize
       0   UartManualMode
       8   UartRelease
         8   -> DeQueueMessage
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_DisableIRQ
         8   -> UpdateMessageStatus
      32   UartRequest
        32   -> NVIC_ClearPendingIRQ
        32   -> NVIC_EnableIRQ
       8   UartRunActiveState
         8   -- Indirect call
       0   UartSM_Error
       8   UartSM_Idle
         8   -> UpdateMessageStatus
      24   UartWriteByte
        24   -> QueueMessage
        24   -> UartManualMode
      24   UartWriteData
        24   -> QueueMessage
        24   -> UartManualMode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_23
       4  ??DataTable15_24
       4  ??DataTable15_25
       4  ??DataTable15_26
       4  ??DataTable15_27
       4  ??DataTable15_28
       4  ??DataTable15_29
       4  ??DataTable15_3
       4  ??DataTable15_30
       4  ??DataTable15_31
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      32  ?_0
      30  DBGU_IrqHandler
       4  G_u32Uart0ApplicationFlags
       4  G_u32Uart1ApplicationFlags
       4  G_u32Uart2ApplicationFlags
       4  G_u32UartApplicationFlags
      22  NVIC_ClearPendingIRQ
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      30  UART1_IRQHandler
      30  UART2_IRQHandler
      36  UART_Peripheral
      36  UART_Peripheral0
      36  UART_Peripheral1
      36  UART_Peripheral2
       4  UART_psCurrentISR
       4  UART_psCurrentUart
       4  UART_pu32ApplicationFlagsISR
       4  UART_u32Flags
       4  UART_u32Int0Count
       4  UART_u32Int1Count
       4  UART_u32Int2Count
       4  UART_u32IntCount
       1  UART_u8ActiveUarts
      30  USART0_IrqHandler
     244  UartGenericHandler
     232  UartInitialize
       2  UartManualMode
      84  UartRelease
     312  UartRequest
      10  UartRunActiveState
      20  UartSM_Error
     216  UartSM_Idle
      48  UartWriteByte
      44  UartWriteData
       4  Uart_pfnStateMachine

 
   197 bytes in section .bss
    32 bytes in section .rodata
 1 526 bytes in section .text
 
 1 526 bytes of CODE  memory
    32 bytes of CONST memory
   197 bytes of DATA  memory

Errors: none
Warnings: 1
