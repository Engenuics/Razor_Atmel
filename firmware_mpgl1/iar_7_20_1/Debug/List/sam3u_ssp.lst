###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        14/Oct/2015  14:48:09
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\sam3u_ssp.c
#    Command line =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\sam3u_ssp.c
#        --preprocess=cl
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\bsp\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline -I "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\sam3u_ssp.lst
#    Object file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\sam3u_ssp.o
#
###############################################################################

D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\sam3u_ssp.c
      1          /**********************************************************************************************************************
      2          File: sam3u_ssp.c                                                                
      3          
      4          Description:
      5          Provides a driver to use a USART peripheral in SPI/SSP mode to send and receive data using interrupts and peripheral DMA.
      6          Note that Master SPI devices keep !CS as a GPIO so it can be managed manually to more easily work with 
      7          the multitude of variants in slave device !CS requirements.
      8          
      9          This driver should work for SPI slaves with or without flow control, though you may need to make adjustments
     10          to how data is timed.  A slave with flow control requires callback functions to manage flow control lines.
     11          
     12          If LSB first transmission is required, we can't use the DMA if we let the SSP task manage the bit flipping.
     13          For high-traffic or low-power devices, you might consider flipping at the task level so that DMA
     14          can be used (the bytes would have to be pre-flipped for transmit and post-flipped on receive).
     15          
     16          API:
     17          SspPeripheralType* SspRequest(SspConfigurationType* psSspConfig_)
     18          Request a SSP peripheral for your task.  No other tasks in the system will be able to access 
     19          the specific peripheral you request.
     20          e.g. MyTaskSsp = SspRequest(&MyTaskSspConfig);
     21          
     22          void SspRelease(SspPeripheralType* psSspPeripheral_)
     23          If your task is done using the SSP it requested, call this function to "give it back" to the system.
     24          e.g. SspRelease(&MyTaskSsp);
     25          
     26          u32 SspWriteByte(SspPeripheralType* psSspPeripheral_, u8 u8Byte_)
     27          Write a single byte to the SSP.  A token corresponding to the message is returned if you want to monitor
     28          if the byte sends correctly.
     29          e.g u32CurrentMessageToken = SspWriteByte(&MyTaskSsp, u8ByteToWRite);
     30          
     31          u32 SspWriteData(SspPeripheralType* psSspPeripheral_, u32 u32Size_, u8* u8Data_)
     32          Write an array of bytes to the SSP.  Returns the message token for monitoring the status of the message.
     33          e.g. 
     34          u8 au8SData[] = {1, 2, 3, 4, 5, 6};
     35          u32CurrentMessageToken = SspWriteData(&MyTaskSsp, sizeof(au8SData), au8Sting);
     36          
     37          Master mode only:
     38          u32 SspReadByte(SspPeripheralType* psSspPeripheral_)
     39          Creates a dummy byte message of 1 byte to subsequently receive a byte. Returns the message token that can be monitored
     40          to see when the message has been sent, and thus when the received byte should be in the pre-configured receive buffer.
     41          e.g. u32CurrentMessageToken = SspReadByte(&MyTaskSsp);
     42          
     43          u32 SspReadData(SspPeripheralType* psSspPeripheral_, u32 u32Size_)
     44          Creates a dummy byte array to subsequently receive u32Size_ bytes. Returns the message token that can be monitored
     45          to see when the message has been sent, and thus when the received data should be in the pre-configured receive buffer.
     46          e.g. u32CurrentMessageToken = SspReadData(&MyTaskSsp, 10);
     47          
     48          
     49          INITIALIZATION (should take place in application's initialization function):
     50          1. Create a variable of SspConfigurationType in your application and initialize it to the desired SSP peripheral,
     51          and the size & address of the receive buffer in the application.
     52          
     53          2. Call SspRequest() with pointer to the configuration variable created in step 1.  The returned pointer is the
     54          SspPeripheralType object created that will be used by your application.
     55          
     56          3. If the application no longer needs the SSP resource, call SspRelease().  
     57          Note: if multiple slaves share an SSP resource, SspRequest() and SspRelease() must be used frequently to
     58          allow traffic to both devices. 
     59          
     60          MASTER MODE DATA TRANSFER:
     61          Transmitted data is queued using one of two functions, SspWriteByte() and SspWriteData() which both return a message
     62          token unique to the data.  Once the data is queued, it is sent by the SSP as soon as possible.  Different SSP resources may 
     63          transmit and receive data simultaneously.  Regardless, the SPI protocol always receives a byte with every transmitted
     64          byte.  This may be a defined dummy byte, or it may be 0xFF or 0x00 depending on the idle state of the MISO line.
     65          Your application must process the received bytes and determine if they are dummy bytes or useful data.
     66          
     67          Received bytes on the allocated peripheral will be dropped into the application's designated receive
     68          buffer.  The buffer is written circularly, with no provision to monitor bytes that are overwritten.  The 
     69          application is responsible for processing all received data.  The application must provide its own parsing
     70          pointer to read the receive buffer and properly wrap around.  This pointer will not be impacted by the interrupt
     71          service routine that may add additional characters at any time.
     72          
     73          SSP traffic is always full duplex, but protocols are typically half duplex.  To receive
     74          data requested from an SSP slave, call SspReadByte() for a single byte or SspReadData() for multiple
     75          bytes.  These functions will automatically queue SSP_DUMMY bytes to transmit and activate the clock
     76          to receive data into your application's receive buffer.
     77          
     78          
     79          SLAVE MODE DATA TRANSFER:
     80          In Slave mode, the peripheral is always ready to receive bytes from the Master.  
     81          Received bytes on the allocated peripheral will be dropped into the receive
     82          buffer that the application specifies upon requesting the SPI peripheral.  The buffer 
     83          is written circularly, with no provision to monitor bytes that are overwritten.  The 
     84          application is responsible for processing all received data.  The application must 
     85          provide its own parsing pointer to read the receive buffer and properly wrap around.  
     86          This pointer will not be impacted by the interrupt service routine that may add additional 
     87          characters at any time.
     88          
     89          Transmitted data is queued using one of two functions, SspWriteByte() and SspWriteData().  Once the data
     90          is queued, it is sent as soon as possible.  Different SSP resources may transmit and receive data simultaneously.  
     91          Per the SPI protocol, a receive byte is always read with every transmit byte.  Your application must process the received bytes
     92          and determine if they are dummy bytes or useful data.
     93          
     94          
     95          **********************************************************************************************************************/
     96          
     97          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable16  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable16_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable16_2  ;; 0xe000e280
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     98          
     99          /***********************************************************************************************************************
    100          Global variable definitions with scope across entire project.
    101          All Global variable names shall start with "G_<type>Ssp"
    102          ***********************************************************************************************************************/
    103          /* New variables */

   \                                 In section .bss, align 4
    104          u32 G_u32Ssp0ApplicationFlags;                   /* Status flags meant for application using this SSP peripheral */
   \                     G_u32Ssp0ApplicationFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    105          u32 G_u32Ssp1ApplicationFlags;                   /* Status flags meant for application using this SSP peripheral */
   \                     G_u32Ssp1ApplicationFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    106          u32 G_u32Ssp2ApplicationFlags;                   /* Status flags meant for application using this SSP peripheral */
   \                     G_u32Ssp2ApplicationFlags:
   \   00000000                      DS8 4
    107          
    108          
    109          /*--------------------------------------------------------------------------------------------------------------------*/
    110          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
    111          extern volatile u32 G_u32SystemTime1ms;          /* From board-specific source file */
    112          extern volatile u32 G_u32SystemTime1s;           /* From board-specific source file */
    113          
    114          extern volatile u32 G_u32SystemFlags;            /* From main.c */
    115          extern volatile u32 G_u32ApplicationFlags;       /* From main.c */
    116          
    117          
    118          /***********************************************************************************************************************
    119          Global variable definitions with scope limited to this local application.
    120          Variable names shall start with "SSP_" and be declared as static.
    121          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
    122          static fnCode_type Ssp_pfnStateMachine;          /* The SSP application state machine */
   \                     Ssp_pfnStateMachine:
   \   00000000                      DS8 4
    123          
    124          static u32 SSP_u32Timer;                         /* Timeout counter used across states */
                            ^
Warning[Pe177]: variable "SSP_u32Timer" was declared but never referenced

   \                                 In section .bss, align 4
    125          static u32 SSP_u32Flags;                         /* Application flags for SSP */
   \                     SSP_u32Flags:
   \   00000000                      DS8 4
    126          

   \                                 In section .bss, align 4
    127          static SspPeripheralType SSP_Peripheral0;        /* SSP0 peripheral object */
   \                     SSP_Peripheral0:
   \   00000000                      DS8 52

   \                                 In section .bss, align 4
    128          static SspPeripheralType SSP_Peripheral1;        /* SSP1 peripheral object */
   \                     SSP_Peripheral1:
   \   00000000                      DS8 52

   \                                 In section .bss, align 4
    129          static SspPeripheralType SSP_Peripheral2;        /* SSP2 peripheral object */
   \                     SSP_Peripheral2:
   \   00000000                      DS8 52
    130          

   \                                 In section .bss, align 4
    131          static SspPeripheralType* SSP_psCurrentSsp;      /* Current SSP peripheral being processed task */
   \                     SSP_psCurrentSsp:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    132          static SspPeripheralType* SSP_psCurrentISR;      /* Current SSP peripheral being processed in ISR */
   \                     SSP_psCurrentISR:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    133          static u32* SSP_pu32SspApplicationFlagsISR;      /* Current SSP application status flags in ISR */
   \                     SSP_pu32SspApplicationFlagsISR:
   \   00000000                      DS8 4
    134          

   \                                 In section .bss, align 4
    135          static u8 SSP_au8Dummies[MAX_TX_MESSAGE_LENGTH]; /* Array of dummy bytes sent to receive bytes from a slave */
   \                     SSP_au8Dummies:
   \   00000000                      DS8 128
    136          

   \                                 In section .bss, align 4
    137          static u32 SSP_u32Int0Count = 0;                 /* Debug counter for SSP0 interrupts */
   \                     SSP_u32Int0Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    138          static u32 SSP_u32Int1Count = 0;                 /* Debug counter for SSP1 interrupts */
   \                     SSP_u32Int1Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    139          static u32 SSP_u32Int2Count = 0;                 /* Debug counter for SSP2 interrupts */
   \                     SSP_u32Int2Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    140          static u32 SSP_u32AntCounter = 0;                /* Debug counter */
   \                     SSP_u32AntCounter:
   \   00000000                      DS8 4
    141          
    142          
    143          /***********************************************************************************************************************
    144          Function Definitions
    145          ***********************************************************************************************************************/
    146          /*--------------------------------------------------------------------------------------------------------------------*/
    147          /* Public Functions */
    148          /*--------------------------------------------------------------------------------------------------------------------*/
    149          
    150          /*----------------------------------------------------------------------------------------------------------------------
    151          Function: SspRequest
    152          
    153          Description:
    154          Requests access to an SSP resource.  If the resource is available, the transmit and receive parameters are set up
    155          and the peripheral is made ready to use in the application. The peripheral will be configured in different ways
    156          for different SSP modes.  The following modes are supported:
    157          SPI_MASTER: transmit and receive using peripheral DMA controller; transmit occurs through the Message API
    158          SPI_SLAVE: transmit through Message Task; receive set up per-byte using current and next DMA pointers and managed into circular buffer.
    159          SPI_SLAVE_FLOW_CONTROL:
    160          
    161          Requires:
    162            - SSP peripheral register initialization values in configuration.h must be set correctly; currently this does not support
    163              different SSP configurations for multiple slaves on the same bus - all peripherals on the bus must work with
    164              the same setup.
    165            - psSspConfig_ has the SSP peripheral number, address of the RxBuffer and the RxBuffer size
    166            - the calling application is ready to start using the peripheral
    167          
    168          Promises:
    169            - Returns a pointer to the requested SSP peripheral object if the resource is available; otherwise returns NULL
    170            - Peripheral is enabled
    171            - Peripheral interrupts are enabled.
    172          */

   \                                 In section .text, align 2, keep-with-next
    173          SspPeripheralType* SspRequest(SspConfigurationType* psSspConfig_)
    174          {
   \                     SspRequest: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    175            SspPeripheralType* psRequestedSsp; 
    176            u32 u32TargetCR, u32TargetMR, u32TargetIER, u32TargetIDR, u32TargetBRGR;
    177          
    178            /* Set the peripheral pointer to the correct resource */
    179            switch(psSspConfig_->SspPeripheral)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD004             BEQ.N    ??SspRequest_0
   \   0000000C   0xD334             BCC.N    ??SspRequest_1
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD021             BEQ.N    ??SspRequest_2
   \   00000012   0xD310             BCC.N    ??SspRequest_3
   \   00000014   0xE030             B.N      ??SspRequest_1
    180            {
    181              case USART0:
    182              {
    183                psRequestedSsp = &SSP_Peripheral0;
   \                     ??SspRequest_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000001A   0x0005             MOVS     R5,R0
    184                
    185                u32TargetCR   = USART0_US_CR_INIT;
   \   0000001C   0x2050             MOVS     R0,#+80
   \   0000001E   0x0006             MOVS     R6,R0
    186                u32TargetMR   = USART0_US_MR_INIT; 
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x4008c0
   \   00000024   0x0007             MOVS     R7,R0
    187                u32TargetIER  = USART0_US_IER_INIT; 
   \   00000026   0x2008             MOVS     R0,#+8
   \   00000028   0x4680             MOV      R8,R0
    188                u32TargetIDR  = USART0_US_IDR_INIT;
   \   0000002A   0xF07F 0x0008      MVNS     R0,#+8
   \   0000002E   0x4681             MOV      R9,R0
    189                u32TargetBRGR = USART0_US_BRGR_INIT;
   \   00000030   0x201A             MOVS     R0,#+26
   \   00000032   0x4682             MOV      R10,R0
    190                break;
   \   00000034   0xE022             B.N      ??SspRequest_4
    191              }
    192              case USART1:
    193              {
    194                psRequestedSsp = &SSP_Peripheral1;
   \                     ??SspRequest_3: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000003A   0x0005             MOVS     R5,R0
    195                
    196                u32TargetCR   = USART1_US_CR_INIT;
   \   0000003C   0x2060             MOVS     R0,#+96
   \   0000003E   0x0006             MOVS     R6,R0
    197                u32TargetMR   = USART1_US_MR_INIT; 
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16_6  ;; 0x4518ce
   \   00000044   0x0007             MOVS     R7,R0
    198                u32TargetIER  = USART1_US_IER_INIT; 
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x4680             MOV      R8,R0
    199                u32TargetIDR  = USART1_US_IDR_INIT;
   \   0000004A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004E   0x4681             MOV      R9,R0
    200                u32TargetBRGR = USART1_US_BRGR_INIT;
   \   00000050   0x2030             MOVS     R0,#+48
   \   00000052   0x4682             MOV      R10,R0
    201                break;
   \   00000054   0xE012             B.N      ??SspRequest_4
    202              }
    203              case USART2:
    204              {
    205                psRequestedSsp = &SSP_Peripheral2;
   \                     ??SspRequest_2: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   0000005A   0x0005             MOVS     R5,R0
    206                
    207                u32TargetCR   = USART2_US_CR_INIT;
   \   0000005C   0x2050             MOVS     R0,#+80
   \   0000005E   0x0006             MOVS     R6,R0
    208                u32TargetMR   = USART2_US_MR_INIT; 
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_8  ;; 0x4118ff
   \   00000064   0x0007             MOVS     R7,R0
    209                u32TargetIER  = USART2_US_IER_INIT; 
   \   00000066   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000006A   0x4680             MOV      R8,R0
    210                u32TargetIDR  = USART2_US_IDR_INIT;
   \   0000006C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000070   0x4681             MOV      R9,R0
    211                u32TargetBRGR = USART2_US_BRGR_INIT;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4682             MOV      R10,R0
    212                break;
   \   00000076   0xE001             B.N      ??SspRequest_4
    213              }
    214              
    215              default:
    216              {
    217                return(NULL);
   \                     ??SspRequest_1: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE063             B.N      ??SspRequest_5
    218              }
    219            } /* end switch */
    220            
    221            /* If the requested peripheral is already assigned, return NULL now */
    222            if(psRequestedSsp->u32PrivateFlags & _SSP_PERIPHERAL_ASSIGNED)
   \                     ??SspRequest_4: (+1)
   \   0000007C   0x6928             LDR      R0,[R5, #+16]
   \   0000007E   0x02C0             LSLS     R0,R0,#+11
   \   00000080   0xD501             BPL.N    ??SspRequest_6
    223            {
    224              return(NULL);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE05E             B.N      ??SspRequest_5
    225            }
    226          
    227            /* Activate and configure the peripheral */
    228            AT91C_BASE_PMC->PMC_PCER |= (1 << psRequestedSsp->u8PeripheralId);
   \                     ??SspRequest_6: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable16_9  ;; 0x400e0410
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0xF995 0x2026      LDRSB    R2,[R5, #+38]
   \   00000092   0x4091             LSLS     R1,R1,R2
   \   00000094   0x4308             ORRS     R0,R1,R0
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable16_9  ;; 0x400e0410
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    229            
    230            psRequestedSsp->pCsGpioAddress  = psSspConfig_->pCsGpioAddress;
   \   0000009C   0x6860             LDR      R0,[R4, #+4]
   \   0000009E   0x6068             STR      R0,[R5, #+4]
    231            psRequestedSsp->u32CsPin        = psSspConfig_->u32CsPin;
   \   000000A0   0x68A0             LDR      R0,[R4, #+8]
   \   000000A2   0x60A8             STR      R0,[R5, #+8]
    232            psRequestedSsp->BitOrder        = psSspConfig_->BitOrder;
   \   000000A4   0x7B20             LDRB     R0,[R4, #+12]
   \   000000A6   0x7328             STRB     R0,[R5, #+12]
    233            psRequestedSsp->SpiMode         = psSspConfig_->SpiMode;
   \   000000A8   0x7B60             LDRB     R0,[R4, #+13]
   \   000000AA   0x7368             STRB     R0,[R5, #+13]
    234            psRequestedSsp->fnSlaveTxFlowCallback = psSspConfig_->fnSlaveTxFlowCallback;
   \   000000AC   0x6920             LDR      R0,[R4, #+16]
   \   000000AE   0x6168             STR      R0,[R5, #+20]
    235            psRequestedSsp->fnSlaveRxFlowCallback = psSspConfig_->fnSlaveRxFlowCallback;
   \   000000B0   0x6960             LDR      R0,[R4, #+20]
   \   000000B2   0x61A8             STR      R0,[R5, #+24]
    236            psRequestedSsp->pu8RxBuffer     = psSspConfig_->pu8RxBufferAddress;
   \   000000B4   0x69A0             LDR      R0,[R4, #+24]
   \   000000B6   0x61E8             STR      R0,[R5, #+28]
    237            psRequestedSsp->ppu8RxNextByte  = psSspConfig_->ppu8RxNextByte;
   \   000000B8   0x69E0             LDR      R0,[R4, #+28]
   \   000000BA   0x6228             STR      R0,[R5, #+32]
    238            psRequestedSsp->u16RxBufferSize = psSspConfig_->u16RxBufferSize;
   \   000000BC   0x8C20             LDRH     R0,[R4, #+32]
   \   000000BE   0x84A8             STRH     R0,[R5, #+36]
    239            psRequestedSsp->u32PrivateFlags |= _SSP_PERIPHERAL_ASSIGNED;
   \   000000C0   0x6928             LDR      R0,[R5, #+16]
   \   000000C2   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   000000C6   0x6128             STR      R0,[R5, #+16]
    240             
    241            psRequestedSsp->pBaseAddress->US_CR   = u32TargetCR;
   \   000000C8   0x6828             LDR      R0,[R5, #+0]
   \   000000CA   0x6006             STR      R6,[R0, #+0]
    242            psRequestedSsp->pBaseAddress->US_MR   = u32TargetMR;
   \   000000CC   0x6828             LDR      R0,[R5, #+0]
   \   000000CE   0x6047             STR      R7,[R0, #+4]
    243            psRequestedSsp->pBaseAddress->US_IER  = u32TargetIER;
   \   000000D0   0x6828             LDR      R0,[R5, #+0]
   \   000000D2   0xF8C0 0x8008      STR      R8,[R0, #+8]
    244            psRequestedSsp->pBaseAddress->US_IDR  = u32TargetIDR;
   \   000000D6   0x6828             LDR      R0,[R5, #+0]
   \   000000D8   0xF8C0 0x900C      STR      R9,[R0, #+12]
    245            psRequestedSsp->pBaseAddress->US_BRGR = u32TargetBRGR;
   \   000000DC   0x6828             LDR      R0,[R5, #+0]
   \   000000DE   0xF8C0 0xA020      STR      R10,[R0, #+32]
    246            
    247            if(psRequestedSsp->SpiMode == SPI_SLAVE)
   \   000000E2   0x7B68             LDRB     R0,[R5, #+13]
   \   000000E4   0x2801             CMP      R0,#+1
   \   000000E6   0xD11B             BNE.N    ??SspRequest_7
    248            {
    249              /* Preset the PDC pointers and counters; the receive buffer must be starting from [0] and be at least 2 bytes long)*/
    250              psRequestedSsp->pBaseAddress->US_RPR  = (u32)psSspConfig_->pu8RxBufferAddress;
   \   000000E8   0x69A0             LDR      R0,[R4, #+24]
   \   000000EA   0x6829             LDR      R1,[R5, #+0]
   \   000000EC   0xF8C1 0x0100      STR      R0,[R1, #+256]
    251              psRequestedSsp->pBaseAddress->US_RNPR = (u32)(psSspConfig_->pu8RxBufferAddress + 1);
   \   000000F0   0x69A0             LDR      R0,[R4, #+24]
   \   000000F2   0x1C40             ADDS     R0,R0,#+1
   \   000000F4   0x6829             LDR      R1,[R5, #+0]
   \   000000F6   0xF8C1 0x0110      STR      R0,[R1, #+272]
    252              psRequestedSsp->pBaseAddress->US_RCR  = 1;
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0x6829             LDR      R1,[R5, #+0]
   \   000000FE   0xF8C1 0x0104      STR      R0,[R1, #+260]
    253              psRequestedSsp->pBaseAddress->US_RNCR = 1;
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0x6829             LDR      R1,[R5, #+0]
   \   00000106   0xF8C1 0x0114      STR      R0,[R1, #+276]
    254              psRequestedSsp->ppu8RxNextByte = NULL; /* not used for SPI_SLAVE */
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x6228             STR      R0,[R5, #+32]
    255          
    256              /* Enable the receiver and transmitter requests so they are ready to go if the Master starts clocking */
    257              psRequestedSsp->pBaseAddress->US_PTCR = AT91C_PDC_RXTEN | AT91C_PDC_TXTEN;
   \   0000010E   0xF240 0x1001      MOVW     R0,#+257
   \   00000112   0x6829             LDR      R1,[R5, #+0]
   \   00000114   0xF8C1 0x0120      STR      R0,[R1, #+288]
    258              psRequestedSsp->pBaseAddress->US_IER = AT91C_US_CTSIC;
   \   00000118   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000011C   0x6829             LDR      R1,[R5, #+0]
   \   0000011E   0x6088             STR      R0,[R1, #+8]
    259            }
    260          
    261            if(psRequestedSsp->SpiMode == SPI_SLAVE_FLOW_CONTROL)
   \                     ??SspRequest_7: (+1)
   \   00000120   0x7B68             LDRB     R0,[R5, #+13]
   \   00000122   0x2802             CMP      R0,#+2
   \   00000124   0xD103             BNE.N    ??SspRequest_8
    262            {
    263              /* Enable the CS and receiver requests so they are ready to go if the Master starts clocking */
    264              psRequestedSsp->pBaseAddress->US_IER = (AT91C_US_CTSIC | AT91C_US_RXRDY);
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable16_10  ;; 0x80001
   \   0000012A   0x6829             LDR      R1,[R5, #+0]
   \   0000012C   0x6088             STR      R0,[R1, #+8]
    265            }
    266            
    267            /* Enable SSP interrupts */
    268            NVIC_ClearPendingIRQ( (IRQn_Type)psRequestedSsp->u8PeripheralId );
   \                     ??SspRequest_8: (+1)
   \   0000012E   0xF995 0x0026      LDRSB    R0,[R5, #+38]
   \   00000132   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000134   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    269            NVIC_EnableIRQ( (IRQn_Type)psRequestedSsp->u8PeripheralId );
   \   00000138   0xF995 0x0026      LDRSB    R0,[R5, #+38]
   \   0000013C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000013E   0x.... 0x....      BL       NVIC_EnableIRQ
    270            
    271            return(psRequestedSsp);
   \   00000142   0x0028             MOVS     R0,R5
   \                     ??SspRequest_5: (+1)
   \   00000144   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    272            
    273          } /* end SspRequest() */
    274          
    275          
    276          /*----------------------------------------------------------------------------------------------------------------------
    277          Function: SspRelease
    278          
    279          Description:
    280          Releases an SSP resource.  
    281          
    282          Requires:
    283            - psSspPeripheral_ has the SSP peripheral number, address of the RxBuffer, and the RxBuffer size and the calling
    284              application is ready to start using the peripheral.
    285          
    286          Promises:
    287            - Resets peripheral object's pointers and data to safe values
    288            - Peripheral is disabled
    289            - Peripheral interrupts are disabled.
    290          */

   \                                 In section .text, align 2, keep-with-next
    291          void SspRelease(SspPeripheralType* psSspPeripheral_)
    292          {
   \                     SspRelease: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    293            /* Check to see if the peripheral is already released */
    294            if(psSspPeripheral_->pu8RxBuffer == NULL)
   \   00000004   0x69E0             LDR      R0,[R4, #+28]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD027             BEQ.N    ??SspRelease_0
    295            {
    296              return;
    297            }
    298            
    299            /* First disable the interrupts */
    300            NVIC_DisableIRQ( (IRQn_Type)(psSspPeripheral_->u8PeripheralId) );
   \                     ??SspRelease_1: (+1)
   \   0000000A   0xF994 0x0026      LDRSB    R0,[R4, #+38]
   \   0000000E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       NVIC_DisableIRQ
    301            NVIC_ClearPendingIRQ( (IRQn_Type)(psSspPeripheral_->u8PeripheralId) );
   \   00000014   0xF994 0x0026      LDRSB    R0,[R4, #+38]
   \   00000018   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    302           
    303            /* Now it's safe to release all of the resources in the target peripheral */
    304            psSspPeripheral_->pCsGpioAddress = NULL;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6060             STR      R0,[R4, #+4]
    305            psSspPeripheral_->pu8RxBuffer    = NULL;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x61E0             STR      R0,[R4, #+28]
    306            psSspPeripheral_->ppu8RxNextByte  = NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6220             STR      R0,[R4, #+32]
    307            psSspPeripheral_->u32PrivateFlags = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6120             STR      R0,[R4, #+16]
    308            psSspPeripheral_->fnSlaveTxFlowCallback = NULL;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6160             STR      R0,[R4, #+20]
    309            psSspPeripheral_->fnSlaveRxFlowCallback = NULL;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x61A0             STR      R0,[R4, #+24]
    310          
    311            /* Empty the transmit buffer if there were leftover messages */
    312            while(psSspPeripheral_->psTransmitBuffer != NULL)
   \                     ??SspRelease_2: (+1)
   \   00000036   0x6AA0             LDR      R0,[R4, #+40]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD009             BEQ.N    ??SspRelease_3
    313            {
    314              UpdateMessageStatus(psSspPeripheral_->psTransmitBuffer->u32Token, ABANDONED);
   \   0000003C   0x2106             MOVS     R1,#+6
   \   0000003E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x.... 0x....      BL       UpdateMessageStatus
    315              DeQueueMessage(&psSspPeripheral_->psTransmitBuffer);
   \   00000046   0xF114 0x0028      ADDS     R0,R4,#+40
   \   0000004A   0x.... 0x....      BL       DeQueueMessage
   \   0000004E   0xE7F2             B.N      ??SspRelease_2
    316            }
    317            
    318            /* Ensure the SM is in the Idle state */
    319            Ssp_pfnStateMachine = SspSM_Idle;
   \                     ??SspRelease_3: (+1)
   \   00000050   0x.... 0x....      ADR.W    R0,SspSM_Idle
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable16_11
   \   00000058   0x6008             STR      R0,[R1, #+0]
    320            
    321          } /* end SspRelease() */
   \                     ??SspRelease_0: (+1)
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    322          
    323          
    324          /*----------------------------------------------------------------------------------------------------------------------
    325          Function: SspWriteByte
    326          
    327          Description:
    328          Queues a single byte for transfer on the target SSP peripheral.  
    329          
    330          Requires:
    331            - psSspPeripheral_ has been requested.
    332            - The chip select line of the SSP device should be asserted
    333          
    334          Promises:
    335            - Creates a 1-byte message at psSspPeripheral_->psTransmitBuffer that will be sent by the SSP application
    336              when it is available.
    337            - Returns the message token assigned to the message
    338          */

   \                                 In section .text, align 2, keep-with-next
    339          u32 SspWriteByte(SspPeripheralType* psSspPeripheral_, u8 u8Byte_)
    340          {
   \                     SspWriteByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    341            u32 u32Token;
    342            u8 u8Data = u8Byte_;
   \   00000008   0xF88D 0x5000      STRB     R5,[SP, #+0]
    343            
    344            u32Token = QueueMessage(&psSspPeripheral_->psTransmitBuffer, 1, &u8Data);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF114 0x0028      ADDS     R0,R4,#+40
   \   00000014   0x.... 0x....      BL       QueueMessage
   \   00000018   0x0006             MOVS     R6,R0
    345            if( u32Token != 0 )
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD006             BEQ.N    ??SspWriteByte_0
    346            {
    347              /* If the system is initializing, we want to manually cycle the SSP task through one iteration
    348              to send the message */
    349              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD501             BPL.N    ??SspWriteByte_0
    350              {
    351                SspManualMode();
   \   00000028   0x.... 0x....      BL       SspManualMode
    352              }
    353            }
    354            
    355            return(u32Token);
   \                     ??SspWriteByte_0: (+1)
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    356            
    357          } /* end SspWriteByte() */
    358          
    359          
    360          /*----------------------------------------------------------------------------------------------------------------------
    361          Function: SspWriteData
    362          
    363          Description:
    364          Queues a data array for transfer on the target SSP peripheral.  
    365          
    366          Requires:
    367            - psSspPeripheral_ has been requested and holds a valid pointer to a transmit buffer; even if a transmission is
    368              in progress, the node in the buffer that is currently being sent will not be destroyed during this function.
    369            - The chip select line of the SSP device should be asserted
    370            - u32Size_ is the number of bytes in the data array
    371            - u8Data_ points to the first byte of the data array
    372          
    373          Promises:
    374            - adds the data message at psSspPeripheral_->psTransmitBuffer that will be sent by the SSP application
    375              when it is available.
    376            - Returns the message token assigned to the message; 0 is returned if the message cannot be queued in which case
    377              G_u32MessagingFlags can be checked for the reason
    378          */

   \                                 In section .text, align 2, keep-with-next
    379          u32 SspWriteData(SspPeripheralType* psSspPeripheral_, u32 u32Size_, u8* pu8Data_)
    380          {
   \                     SspWriteData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    381            u32 u32Token;
    382          
    383            u32Token = QueueMessage(&psSspPeripheral_->psTransmitBuffer, u32Size_, pu8Data_);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xF114 0x0028      ADDS     R0,R4,#+40
   \   00000010   0x.... 0x....      BL       QueueMessage
   \   00000014   0x0007             MOVS     R7,R0
    384            if( u32Token == 0 )
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD101             BNE.N    ??SspWriteData_0
    385            {
    386              return(0);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE007             B.N      ??SspWriteData_1
    387            }
    388            
    389            /* If the system is initializing, manually cycle the SSP task through one iteration to send the message */
    390            if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??SspWriteData_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD501             BPL.N    ??SspWriteData_2
    391            {
    392              SspManualMode();
   \   00000028   0x.... 0x....      BL       SspManualMode
    393            }
    394          
    395            return(u32Token);
   \                     ??SspWriteData_2: (+1)
   \   0000002C   0x0038             MOVS     R0,R7
   \                     ??SspWriteData_1: (+1)
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    396          
    397          } /* end SspWriteData() */
    398          
    399          
    400          /*----------------------------------------------------------------------------------------------------------------------
    401          Function: SspReadByte
    402          
    403          Description:
    404          Master mode only.  Gets a single byte from the slave on the target SSP peripheral.  
    405          
    406          Requires:
    407            - psSspPeripheral_ has been requested.
    408            - The chip select line of the SSP device should be asserted
    409            - 
    410          
    411          Promises:
    412            - Creates a message with one SSP_DUMMY_BYTE at psSspPeripheral_->psTransmitBuffer that will be sent by the SSP application
    413              when it is available and thus clock in a received byte to the target receive buffer.
    414            - Returns the Token of the transmitted dummy message used to read data.
    415          
    416          */

   \                                 In section .text, align 2, keep-with-next
    417          u32 SspReadByte(SspPeripheralType* psSspPeripheral_)
    418          {
   \                     SspReadByte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    419            return( QueueMessage(&psSspPeripheral_->psTransmitBuffer, 1, &SSP_au8Dummies[0]) );
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable16_13
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF114 0x0028      ADDS     R0,R4,#+40
   \   0000000E   0x.... 0x....      BL       QueueMessage
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    420          
    421          } /* end SspReadByte() */
    422          
    423          
    424          /*----------------------------------------------------------------------------------------------------------------------
    425          Function: SspReadData
    426          
    427          Description:
    428          Gets multiple bytes from the slave on the target SSP peripheral.  
    429          
    430          Requires:
    431            - psSspPeripheral_ has been requested and holds a valid pointer to a transmit buffer; even if a transmission is
    432              in progress, the node in the buffer that is currently being sent will not be destroyed during this function.
    433            - The chip select line of the SSP device should be asserted
    434            - u32Size_ is the number of bytes in the data array
    435          
    436          Promises:
    437            - Adds a dummy byte message at psSspPeripheral_->psTransmitBuffer that will be sent by the SSP application
    438              when it is available and thus clock in the received bytes to the designated Rx buffer.
    439            - Returns the message token of the dummy message used to read data
    440            - If the peripheral is busy reading data already, then returns 0.
    441          */

   \                                 In section .text, align 2, keep-with-next
    442          u32 SspReadData(SspPeripheralType* psSspPeripheral_, u32 u32Size_)
    443          {
   \                     SspReadData: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    444            u8 au8MsgTooBig[] = "\r\nSSP message to large\n\r";
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable16_14
   \   0000000E   0x2219             MOVS     R2,#+25
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy
    445            
    446            /* Disallow if requested size is too large */
    447            if(u32Size_ > MAX_TX_MESSAGE_LENGTH)
   \   00000014   0x2D81             CMP      R5,#+129
   \   00000016   0xD304             BCC.N    ??SspReadData_0
    448            {
    449              DebugPrintf(au8MsgTooBig);
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x.... 0x....      BL       DebugPrintf
    450              return 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE006             B.N      ??SspReadData_1
    451            }
    452            
    453            return( QueueMessage(&psSspPeripheral_->psTransmitBuffer, u32Size_, &SSP_au8Dummies[0]) );
   \                     ??SspReadData_0: (+1)
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable16_13
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0xF114 0x0028      ADDS     R0,R4,#+40
   \   0000002C   0x.... 0x....      BL       QueueMessage
   \                     ??SspReadData_1: (+1)
   \   00000030   0xB007             ADD      SP,SP,#+28
   \   00000032   0xBD30             POP      {R4,R5,PC}       ;; return
    454              
    455          } /* end SspReadData() */
    456          
    457          
    458          /*--------------------------------------------------------------------------------------------------------------------*/
    459          /* Protected Functions */
    460          /*--------------------------------------------------------------------------------------------------------------------*/
    461          
    462          /*----------------------------------------------------------------------------------------------------------------------
    463          Function: SspInitialize
    464          
    465          Description:
    466          Initializes the SSP application and its variables.  The peripherals themselves are not configured until
    467          requested by a calling application.
    468          
    469          Requires:
    470            - 
    471          
    472          Promises:
    473            - SSP peripheral objects are ready 
    474            - SSP application set to Idle
    475          */

   \                                 In section .text, align 2, keep-with-next
    476          void SspInitialize(void)
    477          {
   \                     SspInitialize: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    478            static u8 au8SspStartupMessage[] = "SSP Peripherals Ready\n\r";
    479            
    480            /* Initialize the SSP peripheral structures */
    481            SSP_Peripheral0.pBaseAddress     = AT91C_BASE_US0;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_15  ;; 0x40090000
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    482            SSP_Peripheral0.pCsGpioAddress   = NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000012   0x6048             STR      R0,[R1, #+4]
    483            SSP_Peripheral0.psTransmitBuffer = NULL;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   0000001A   0x6288             STR      R0,[R1, #+40]
    484            SSP_Peripheral0.pu8RxBuffer      = NULL;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000022   0x61C8             STR      R0,[R1, #+28]
    485            SSP_Peripheral0.u16RxBufferSize  = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   0000002A   0x8488             STRH     R0,[R1, #+36]
    486            SSP_Peripheral0.ppu8RxNextByte    = NULL;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000032   0x6208             STR      R0,[R1, #+32]
    487            SSP_Peripheral0.u32PrivateFlags  = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   0000003A   0x6108             STR      R0,[R1, #+16]
    488            SSP_Peripheral0.u8PeripheralId   = AT91C_ID_US0;
   \   0000003C   0x200D             MOVS     R0,#+13
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000042   0xF881 0x0026      STRB     R0,[R1, #+38]
    489            
    490            SSP_Peripheral1.pBaseAddress     = AT91C_BASE_US1;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable16_16  ;; 0x40094000
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    491            SSP_Peripheral1.pCsGpioAddress   = NULL;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000056   0x6048             STR      R0,[R1, #+4]
    492            SSP_Peripheral1.psTransmitBuffer = NULL;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000005E   0x6288             STR      R0,[R1, #+40]
    493            SSP_Peripheral1.pu8RxBuffer      = NULL;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000066   0x61C8             STR      R0,[R1, #+28]
    494            SSP_Peripheral1.u16RxBufferSize  = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000006E   0x8488             STRH     R0,[R1, #+36]
    495            SSP_Peripheral1.ppu8RxNextByte    = NULL;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000076   0x6208             STR      R0,[R1, #+32]
    496            SSP_Peripheral1.u32PrivateFlags  = 0;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000007E   0x6108             STR      R0,[R1, #+16]
    497            SSP_Peripheral1.u8PeripheralId   = AT91C_ID_US1;
   \   00000080   0x200E             MOVS     R0,#+14
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000086   0xF881 0x0026      STRB     R0,[R1, #+38]
    498          
    499            SSP_Peripheral2.pBaseAddress     = AT91C_BASE_US2;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable16_17  ;; 0x40098000
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   00000092   0x6008             STR      R0,[R1, #+0]
    500            SSP_Peripheral2.pCsGpioAddress   = NULL;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   0000009A   0x6048             STR      R0,[R1, #+4]
    501            SSP_Peripheral2.psTransmitBuffer = NULL;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   000000A2   0x6288             STR      R0,[R1, #+40]
    502            SSP_Peripheral2.pu8RxBuffer      = NULL;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   000000AA   0x61C8             STR      R0,[R1, #+28]
    503            SSP_Peripheral2.u16RxBufferSize  = 0;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   000000B2   0x8488             STRH     R0,[R1, #+36]
    504            SSP_Peripheral2.ppu8RxNextByte    = NULL;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   000000BA   0x6208             STR      R0,[R1, #+32]
    505            SSP_Peripheral2.u32PrivateFlags  = 0;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   000000C2   0x6108             STR      R0,[R1, #+16]
    506            SSP_Peripheral2.u8PeripheralId   = AT91C_ID_US2;
   \   000000C4   0x200F             MOVS     R0,#+15
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   000000CA   0xF881 0x0026      STRB     R0,[R1, #+38]
    507          
    508            SSP_psCurrentSsp                = &SSP_Peripheral0;
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable16_18
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    509            
    510            /* Fill the dummy array with SSP_DUMMY bytes */
    511            memset(SSP_au8Dummies, SSP_DUMMY_BYTE, MAX_TX_MESSAGE_LENGTH);
   \   000000D8   0x2480             MOVS     R4,#+128
   \   000000DA   0x25FF             MOVS     R5,#+255
   \   000000DC   0x.... 0x....      LDR.W    R6,??DataTable16_13
   \   000000E0   0x002A             MOVS     R2,R5
   \   000000E2   0x0021             MOVS     R1,R4
   \   000000E4   0x0030             MOVS     R0,R6
   \   000000E6   0x.... 0x....      BL       __aeabi_memset
    512          
    513            /* Set application pointer */
    514            Ssp_pfnStateMachine = SspSM_Idle;
   \   000000EA   0x.... 0x....      ADR.W    R0,SspSM_Idle
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable16_11
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    515            DebugPrintf(au8SspStartupMessage);
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable16_19
   \   000000F8   0x.... 0x....      BL       DebugPrintf
    516          
    517          } /* end SspInitialize() */
   \   000000FC   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8SspStartupMessage:
   \   00000000   0x53 0x53          DC8 "SSP Peripherals Ready\012\015"
   \              0x50 0x20    
   \              0x50 0x65    
   \              0x72 0x69    
   \              0x70 0x68    
   \              0x65 0x72    
   \              0x61 0x6C    
   \              0x73 0x20    
   \              0x52 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
    518          
    519          
    520          /*----------------------------------------------------------------------------------------------------------------------
    521          Function SspRunActiveState()
    522          
    523          Description:
    524          Selects and runs one iteration of the current state in the state machine.
    525          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    526          may take 1ms / n to execute.
    527          
    528          Requires:
    529            - State machine function pointer points at current state
    530          
    531          Promises:
    532            - Calls the function to pointed by the state machine function pointer
    533          */

   \                                 In section .text, align 2, keep-with-next
    534          void SspRunActiveState(void)
    535          {
   \                     SspRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    536            Ssp_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_11
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    537          
    538          } /* end SspRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    539          
    540          
    541          /*----------------------------------------------------------------------------------------------------------------------
    542          Function: SspManualMode
    543          
    544          Description:
    545          Runs a transmit cycle of the SSP application to clock out a message.  This function is used only during
    546          initialization.
    547          
    548          Requires:
    549            - SSP application has been initialized.
    550          
    551          Promises:
    552            - All bytes currently in the SSP Tx FIFO are sent out and thus all the expected received bytes
    553              are read into the application receive circular buffer.
    554          */

   \                                 In section .text, align 2, keep-with-next
    555          void SspManualMode(void)
    556          {
    557          #ifndef SIMULATOR_MODE
    558            /* Set up for manual mode */
    559            SSP_u32Flags |= _SSP_MANUAL_MODE;
    560            SSP_psCurrentSsp = &SSP_Peripheral0;
    561          
    562            /* Run a full cycle of the SSP state machine so all SSP peripherals send their current message */  
    563            while(SSP_u32Flags & _SSP_MANUAL_MODE)
    564            {
    565              Ssp_pfnStateMachine();
    566              
    567              SSP_u32Timer = G_u32SystemTime1ms;
    568              IsTimeUp(&SSP_u32Timer, 1);
    569            }
    570          #endif /* SIMULATOR_MODE */
    571                
    572          } /* end SspManualMode() */
   \                     SspManualMode: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    573          
    574          
    575          /*--------------------------------------------------------------------------------------------------------------------*/
    576          /* Private functions */
    577          /*--------------------------------------------------------------------------------------------------------------------*/
    578          
    579          
    580          /*----------------------------------------------------------------------------------------------------------------------
    581          Interrupt Service Routine: SSP0_IRQHandler
    582          
    583          Description:
    584          Handles the enabled SSP0 interrupts. 
    585          
    586          Transmit: An End Transmit interrupt will occur when the PDC has finished sending all of the bytes.
    587          Receive: An End Receive interrupt will occur when the PDC has finished receiving all of the expected bytes.
    588          
    589          Requires:
    590            - ISRs cannot require anything
    591          
    592          Promises:
    593            - Status of message that has completed transferring will be set to COMPLETE.
    594            - Peripheral CS line is cleared and the PDC is disabled
    595            - _SSP_PERIPHERAL_RX/TX is cleared
    596          */

   \                                 In section .text, align 2, keep-with-next
    597          void SSP0_IRQHandler(void)
    598          {
   \                     SSP0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    599            /* Set the current ISR pointers to SSP0 targets */
    600            SSP_psCurrentISR = &SSP_Peripheral0;                         /* Current SSP ISR */
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    601            SSP_pu32SspApplicationFlagsISR = &G_u32Ssp0ApplicationFlags; /* Current SSP application status flags */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_21
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   00000014   0x6008             STR      R0,[R1, #+0]
    602            SSP_u32Int0Count++;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_23
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable16_23
   \   00000022   0x6008             STR      R0,[R1, #+0]
    603          
    604            /* Go to common SSP interrupt using psCurrentSspISR since the SSP cannot interrupt itself */
    605            SspGenericHandler();
   \   00000024   0x.... 0x....      BL       SspGenericHandler
    606            
    607          } /* end SSP0_IRQHandler() */
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    608          
    609          
    610          /*----------------------------------------------------------------------------------------------------------------------
    611          Interrupt Service Routine: SSP1_IRQHandler
    612          
    613          Description:
    614          Sets up to handles the enabled SSP1 interrupts. 
    615          
    616          Requires:
    617            - ISRs cannot require anything
    618          
    619          Promises:
    620            - See GenericSspHandler
    621          */

   \                                 In section .text, align 2, keep-with-next
    622          void SSP1_IRQHandler(void)
    623          {
   \                     USART1_IrqHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    624            /* Set the current ISR pointers to SSP1 targets */
    625            SSP_psCurrentISR = &SSP_Peripheral1;                      /* Current SSP ISR */
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    626            SSP_pu32SspApplicationFlagsISR = &G_u32Ssp1ApplicationFlags; /* Current SSP application status flags */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_24
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   00000014   0x6008             STR      R0,[R1, #+0]
    627            SSP_u32Int1Count++;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_25
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable16_25
   \   00000022   0x6008             STR      R0,[R1, #+0]
    628          
    629            /* Go to common SSP interrupt using psCurrentSspISR since the SSP cannot interrupt itself */
    630            SspGenericHandler();
   \   00000024   0x.... 0x....      BL       SspGenericHandler
    631            
    632          } /* end SSP1_IRQHandler() */
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    633          
    634          
    635          /*----------------------------------------------------------------------------------------------------------------------
    636          Interrupt Service Routine: SSP2_IRQHandler
    637          
    638          Description:
    639          Handles the enabled SSP2 interrupts. 
    640          
    641          */

   \                                 In section .text, align 2, keep-with-next
    642          void SSP2_IRQHandler(void)
    643          {
   \                     USART2_IrqHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    644            /* Set the current ISR pointers to SSP2 targets */
    645            SSP_psCurrentISR = &SSP_Peripheral2;                      /* Current SSP ISR */
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    646            SSP_pu32SspApplicationFlagsISR = &G_u32Ssp2ApplicationFlags; /* Current SSP application status flags */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_26
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   00000014   0x6008             STR      R0,[R1, #+0]
    647            SSP_u32Int2Count++;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_27
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable16_27
   \   00000022   0x6008             STR      R0,[R1, #+0]
    648          
    649            /* Go to common SSP interrupt using psCurrentSspISR since the SSP cannot interrupt itself */
    650            SspGenericHandler();
   \   00000024   0x.... 0x....      BL       SspGenericHandler
    651           
    652          } /* end SSP2_IRQHandler() */
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    653          
    654          
    655          /*----------------------------------------------------------------------------------------------------------------------
    656          Generic Interrupt Service Routine
    657          
    658          Description:
    659          Handles the enabled interrupts for the current SSP. 
    660          
    661          Chip select: only enabled for SLAVE peripherals.  A Slave peripheral needs this signal to know it is communicating.  
    662          If it is supposed to be transmitting and does not have any flow control, the data should already be ready.
    663          Transmit: An End Transmit interrupt will occur when the PDC has finished sending all of the bytes for Master or Slave.
    664          Receive: An End Receive interrupt will occur when the PDC has finished receiving all of the expected bytes for Master or a single byte for Slave.
    665          Receive RXBUFF: An Rx Buffer empty interrupt occurs on a Slave when both the current and next send counters are 0.
    666          
    667          Requires:
    668            - SSP_psCurrentISR points to the SSP peripheral who has triggered the interrupt
    669            - SSP_pu32SspApplicationFlagsISR points to the application flags from the SSP peripheral that triggered the interrupt
    670            - A different SSP peripheral cannot interrupt this ISR
    671          
    672          Promises:
    673            - Status of message that has completed transferring will be set to COMPLETE.
    674            - For Master peripherals, the CS line is cleared and the PDC is disabled
    675            - _SSP_PERIPHERAL_RX/TX is cleared
    676          */

   \                                 In section .text, align 2, keep-with-next
    677          void SspGenericHandler(void)
    678          {
   \                     SspGenericHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    679            u32 u32Byte;
    680            u32 u32Timeout;
    681            u32 u32Current_CSR;
    682            
    683            /* Get a copy of CSR because reading it changes it */
    684            u32Current_CSR = SSP_psCurrentISR->pBaseAddress->US_CSR;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x6940             LDR      R0,[R0, #+20]
   \   0000000C   0x0006             MOVS     R6,R0
    685          
    686            /* Check for CS change state interrupt - only enabled on Slave SSP peripherals */
    687            if( (SSP_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_CTSIC) && 
    688                (u32Current_CSR & AT91C_US_CTSIC) )
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x6900             LDR      R0,[R0, #+16]
   \   00000018   0x0300             LSLS     R0,R0,#+12
   \   0000001A   0xD538             BPL.N    ??SspGenericHandler_0
   \   0000001C   0x0330             LSLS     R0,R6,#+12
   \   0000001E   0xD536             BPL.N    ??SspGenericHandler_0
    689            {
    690              /* Is the CS pin asserted now? */
    691              if( (SSP_psCurrentISR->pCsGpioAddress->PIO_PDSR & SSP_psCurrentISR->u32CsPin) == 0)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x6840             LDR      R0,[R0, #+4]
   \   00000028   0x6BC0             LDR      R0,[R0, #+60]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x6889             LDR      R1,[R1, #+8]
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD114             BNE.N    ??SspGenericHandler_1
    692              {
    693                /* Flag that CS is asserted */
    694                *SSP_pu32SspApplicationFlagsISR |= _SSP_CS_ASSERTED;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable16_22
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0x6008             STR      R0,[R1, #+0]
    695                *SSP_pu32SspApplicationFlagsISR &= ~(_SSP_TX_COMPLETE | _SSP_RX_COMPLETE);
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable16_22
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   0000005A   0x6809             LDR      R1,[R1, #+0]
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   \   0000005E   0xE016             B.N      ??SspGenericHandler_0
    696              }
    697              else
    698              {
    699                /* Flag that CS is deasserted */
    700                *SSP_pu32SspApplicationFlagsISR &= ~_SSP_CS_ASSERTED;
   \                     ??SspGenericHandler_1: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_22
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x0840             LSRS     R0,R0,#+1
   \   0000006A   0x0040             LSLS     R0,R0,#+1
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   00000070   0x6809             LDR      R1,[R1, #+0]
   \   00000072   0x6008             STR      R0,[R1, #+0]
    701               
    702                /* Make sure RCR is 1 for next transmission on Slave - no flow control devices only */
    703                if(SSP_psCurrentISR->SpiMode == SPI_SLAVE)
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x7B40             LDRB     R0,[R0, #+13]
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xD106             BNE.N    ??SspGenericHandler_0
    704                {
    705                  SSP_psCurrentISR->pBaseAddress->US_RCR  = 1;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   00000086   0x6809             LDR      R1,[R1, #+0]
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0xF8C1 0x0104      STR      R0,[R1, #+260]
    706                }
    707              }
    708            } /* end CS change state interrupt */
    709          
    710            /*** SSP ISR transmit handling for flow-control devices that do not use DMA ***/
    711            if( (SSP_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_TXEMPTY) && 
    712                (u32Current_CSR & AT91C_US_TXEMPTY) )
   \                     ??SspGenericHandler_0: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x6900             LDR      R0,[R0, #+16]
   \   00000098   0x0580             LSLS     R0,R0,#+22
   \   0000009A   0xD570             BPL.N    ??SspGenericHandler_2
   \   0000009C   0x05B0             LSLS     R0,R6,#+22
   \   0000009E   0xD56E             BPL.N    ??SspGenericHandler_2
    713            {
    714              /* Decrement counter and read the dummy byte so the SSP peripheral doesn't oveerrun */
    715              SSP_psCurrentISR->u32CurrentTxBytesRemaining--;
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0x6AC0             LDR      R0,[R0, #+44]
   \   000000A8   0x1E40             SUBS     R0,R0,#+1
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   000000AE   0x6809             LDR      R1,[R1, #+0]
   \   000000B0   0x62C8             STR      R0,[R1, #+44]
    716              u32Byte = SSP_psCurrentISR->pBaseAddress->US_RHR;
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x6980             LDR      R0,[R0, #+24]
   \   000000BC   0x0004             MOVS     R4,R0
    717              
    718              if(SSP_psCurrentISR->u32CurrentTxBytesRemaining != 0)
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0x6AC0             LDR      R0,[R0, #+44]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD025             BEQ.N    ??SspGenericHandler_3
    719              {
    720                /* Advance the pointer (non-circular buffer), load the next byte and use the callback */
    721                SSP_psCurrentISR->pu8CurrentTxData++;
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x6B00             LDR      R0,[R0, #+48]
   \   000000D2   0x1C40             ADDS     R0,R0,#+1
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   000000D8   0x6809             LDR      R1,[R1, #+0]
   \   000000DA   0x6308             STR      R0,[R1, #+48]
    722                u32Byte = 0x000000FF & *SSP_psCurrentISR->pu8CurrentTxData;
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0x6B00             LDR      R0,[R0, #+48]
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x0004             MOVS     R4,R0
    723          
    724                /* If we need LSB first, use inline assembly to flip bits with a single instruction. */
    725                if(SSP_psCurrentISR->BitOrder == LSB_FIRST)
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x7B00             LDRB     R0,[R0, #+12]
   \   000000F0   0x2801             CMP      R0,#+1
   \   000000F2   0xD103             BNE.N    ??SspGenericHandler_4
    726                {
    727                  u32Byte = __RBIT(u32Byte)>>24;
   \   000000F4   0xFA94 0xF0A4      RBIT     R0,R4
   \   000000F8   0x0E00             LSRS     R0,R0,#+24
   \   000000FA   0x0004             MOVS     R4,R0
    728                }
    729              
    730                SSP_psCurrentISR->pBaseAddress->US_THR = (u8)u32Byte; /* Clears interrupt flag */
   \                     ??SspGenericHandler_4: (+1)
   \   000000FC   0x0020             MOVS     R0,R4
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   00000104   0x6809             LDR      R1,[R1, #+0]
   \   00000106   0x6809             LDR      R1,[R1, #+0]
   \   00000108   0x61C8             STR      R0,[R1, #+28]
    731                SSP_psCurrentISR->fnSlaveTxFlowCallback();
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0x6940             LDR      R0,[R0, #+20]
   \   00000112   0x4780             BLX      R0
   \   00000114   0xE033             B.N      ??SspGenericHandler_2
    732              }
    733              else
    734              {
    735                /* Done! Disable TX interrupt */
    736                SSP_psCurrentISR->pBaseAddress->US_IDR = AT91C_US_TXEMPTY;
   \                     ??SspGenericHandler_3: (+1)
   \   00000116   0xF44F 0x7000      MOV      R0,#+512
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   0000011E   0x6809             LDR      R1,[R1, #+0]
   \   00000120   0x6809             LDR      R1,[R1, #+0]
   \   00000122   0x60C8             STR      R0,[R1, #+12]
    737                
    738                /* Clean up the message status and flags */
    739                SSP_psCurrentISR->u32PrivateFlags &= ~_SSP_PERIPHERAL_TX;  
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0x6900             LDR      R0,[R0, #+16]
   \   0000012C   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   00000134   0x6809             LDR      R1,[R1, #+0]
   \   00000136   0x6108             STR      R0,[R1, #+16]
    740                UpdateMessageStatus(SSP_psCurrentISR->psTransmitBuffer->u32Token, COMPLETE);
   \   00000138   0x2104             MOVS     R1,#+4
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0x6A80             LDR      R0,[R0, #+40]
   \   00000142   0x6800             LDR      R0,[R0, #+0]
   \   00000144   0x.... 0x....      BL       UpdateMessageStatus
    741                DeQueueMessage(&SSP_psCurrentISR->psTransmitBuffer);
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0x3028             ADDS     R0,R0,#+40
   \   00000150   0x.... 0x....      BL       DeQueueMessage
    742           
    743                /* Re-enable Rx interrupt and clean-up the operation */    
    744                SSP_psCurrentISR->pBaseAddress->US_IER = AT91C_US_RXRDY;
   \   00000154   0x2001             MOVS     R0,#+1
   \   00000156   0x.... 0x....      LDR.W    R1,??DataTable16_20
   \   0000015A   0x6809             LDR      R1,[R1, #+0]
   \   0000015C   0x6809             LDR      R1,[R1, #+0]
   \   0000015E   0x6088             STR      R0,[R1, #+8]
    745                *SSP_pu32SspApplicationFlagsISR |= _SSP_TX_COMPLETE; 
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable16_22
   \   00000164   0x6800             LDR      R0,[R0, #+0]
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000016C   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   00000170   0x6809             LDR      R1,[R1, #+0]
   \   00000172   0x6008             STR      R0,[R1, #+0]
    746                SSP_psCurrentISR->fnSlaveTxFlowCallback();
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \   0000017A   0x6940             LDR      R0,[R0, #+20]
   \   0000017C   0x4780             BLX      R0
    747              }
    748            } /* end AT91C_US_TXEMPTY */
    749            
    750            /* SSP ISR handling for Slave Rx with flow control (no DMA) */
    751            if( (SSP_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_RXRDY) && 
    752                (SSP_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_RXRDY) )
   \                     ??SspGenericHandler_2: (+1)
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000182   0x6800             LDR      R0,[R0, #+0]
   \   00000184   0x6800             LDR      R0,[R0, #+0]
   \   00000186   0x6900             LDR      R0,[R0, #+16]
   \   00000188   0x07C0             LSLS     R0,R0,#+31
   \   0000018A   0xD537             BPL.N    ??SspGenericHandler_5
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000190   0x6800             LDR      R0,[R0, #+0]
   \   00000192   0x6800             LDR      R0,[R0, #+0]
   \   00000194   0x6940             LDR      R0,[R0, #+20]
   \   00000196   0x07C0             LSLS     R0,R0,#+31
   \   00000198   0xD530             BPL.N    ??SspGenericHandler_5
    753            {
    754              /* Pull the byte out of the receive register into the Rx buffer */
    755              u32Byte = 0x000000FF & SSP_psCurrentISR->pBaseAddress->US_RHR;
   \   0000019A   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   0000019E   0x6800             LDR      R0,[R0, #+0]
   \   000001A0   0x6800             LDR      R0,[R0, #+0]
   \   000001A2   0x6980             LDR      R0,[R0, #+24]
   \   000001A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A6   0x0004             MOVS     R4,R0
    756          
    757              /* If we need LSB first, use inline assembly to flip bits with a single instruction. */
    758              if(SSP_psCurrentISR->BitOrder == LSB_FIRST)
   \   000001A8   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   000001AC   0x6800             LDR      R0,[R0, #+0]
   \   000001AE   0x7B00             LDRB     R0,[R0, #+12]
   \   000001B0   0x2801             CMP      R0,#+1
   \   000001B2   0xD103             BNE.N    ??SspGenericHandler_6
    759              {
    760                u32Byte = __RBIT(u32Byte)>>24;
   \   000001B4   0xFA94 0xF0A4      RBIT     R0,R4
   \   000001B8   0x0E00             LSRS     R0,R0,#+24
   \   000001BA   0x0004             MOVS     R4,R0
    761              }
    762              
    763              /* DEBUG */
    764              if((u8)u32Byte == 0xff)
   \                     ??SspGenericHandler_6: (+1)
   \   000001BC   0x0020             MOVS     R0,R4
   \   000001BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C0   0x28FF             CMP      R0,#+255
   \   000001C2   0xD106             BNE.N    ??SspGenericHandler_7
    765              {
    766                SSP_u32AntCounter++;
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable16_28
   \   000001C8   0x6800             LDR      R0,[R0, #+0]
   \   000001CA   0x1C40             ADDS     R0,R0,#+1
   \   000001CC   0x.... 0x....      LDR.W    R1,??DataTable16_28
   \   000001D0   0x6008             STR      R0,[R1, #+0]
    767              }
    768              /* Send the byte to the Rx buffer; since we only do one byte at a time in this mode, then _SSP_RX_COMPLETE */
    769              **(SSP_psCurrentISR->ppu8RxNextByte) = (u8)u32Byte;
   \                     ??SspGenericHandler_7: (+1)
   \   000001D2   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   000001D6   0x6800             LDR      R0,[R0, #+0]
   \   000001D8   0x6A00             LDR      R0,[R0, #+32]
   \   000001DA   0x6800             LDR      R0,[R0, #+0]
   \   000001DC   0x7004             STRB     R4,[R0, #+0]
    770              *SSP_pu32SspApplicationFlagsISR |= _SSP_RX_COMPLETE;
   \   000001DE   0x.... 0x....      LDR.W    R0,??DataTable16_22
   \   000001E2   0x6800             LDR      R0,[R0, #+0]
   \   000001E4   0x6800             LDR      R0,[R0, #+0]
   \   000001E6   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000001EA   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   000001EE   0x6809             LDR      R1,[R1, #+0]
   \   000001F0   0x6008             STR      R0,[R1, #+0]
    771          
    772              /* Invoke callback */
    773              SSP_psCurrentISR->fnSlaveRxFlowCallback();
   \   000001F2   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   000001F6   0x6800             LDR      R0,[R0, #+0]
   \   000001F8   0x6980             LDR      R0,[R0, #+24]
   \   000001FA   0x4780             BLX      R0
    774            }
    775          
    776            
    777            /*** SSP ISR responses for non-flow-control devices that use DMA (master or slave) ***/
    778              
    779            /* ENDRX Interrupt when all requested bytes have been received */
    780            if( (SSP_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDRX) && 
    781                (u32Current_CSR & AT91C_US_ENDRX) )
   \                     ??SspGenericHandler_5: (+1)
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000200   0x6800             LDR      R0,[R0, #+0]
   \   00000202   0x6800             LDR      R0,[R0, #+0]
   \   00000204   0x6900             LDR      R0,[R0, #+16]
   \   00000206   0x0700             LSLS     R0,R0,#+28
   \   00000208   0xD560             BPL.N    ??SspGenericHandler_8
   \   0000020A   0x0730             LSLS     R0,R6,#+28
   \   0000020C   0xD55E             BPL.N    ??SspGenericHandler_8
    782            {
    783              /* Master mode and Slave mode operate differently */
    784              if(SSP_psCurrentISR->SpiMode == SPI_MASTER)
   \   0000020E   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000212   0x6800             LDR      R0,[R0, #+0]
   \   00000214   0x7B40             LDRB     R0,[R0, #+13]
   \   00000216   0x2800             CMP      R0,#+0
   \   00000218   0xD129             BNE.N    ??SspGenericHandler_9
    785              {
    786                /* Update this message token status and then DeQueue it */
    787                UpdateMessageStatus(SSP_psCurrentISR->psTransmitBuffer->u32Token, COMPLETE);
   \   0000021A   0x2104             MOVS     R1,#+4
   \   0000021C   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000220   0x6800             LDR      R0,[R0, #+0]
   \   00000222   0x6A80             LDR      R0,[R0, #+40]
   \   00000224   0x6800             LDR      R0,[R0, #+0]
   \   00000226   0x.... 0x....      BL       UpdateMessageStatus
    788                DeQueueMessage( &SSP_psCurrentISR->psTransmitBuffer );
   \   0000022A   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   0000022E   0x6800             LDR      R0,[R0, #+0]
   \   00000230   0x3028             ADDS     R0,R0,#+40
   \   00000232   0x.... 0x....      BL       DeQueueMessage
    789                SSP_psCurrentISR->u32PrivateFlags &= ~_SSP_PERIPHERAL_RX;
   \   00000236   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   0000023A   0x6800             LDR      R0,[R0, #+0]
   \   0000023C   0x6900             LDR      R0,[R0, #+16]
   \   0000023E   0xF430 0x0080      BICS     R0,R0,#0x400000
   \   00000242   0x....             LDR.N    R1,??DataTable16_20
   \   00000244   0x6809             LDR      R1,[R1, #+0]
   \   00000246   0x6108             STR      R0,[R1, #+16]
    790              
    791                /* Shut down hardware */
    792                SSP_psCurrentISR->pCsGpioAddress->PIO_SODR = SSP_psCurrentISR->u32CsPin;
   \   00000248   0x....             LDR.N    R0,??DataTable16_20
   \   0000024A   0x6800             LDR      R0,[R0, #+0]
   \   0000024C   0x6880             LDR      R0,[R0, #+8]
   \   0000024E   0x....             LDR.N    R1,??DataTable16_20
   \   00000250   0x6809             LDR      R1,[R1, #+0]
   \   00000252   0x6849             LDR      R1,[R1, #+4]
   \   00000254   0x6308             STR      R0,[R1, #+48]
    793                
    794                /* Disable the receiver */
    795                SSP_psCurrentISR->pBaseAddress->US_PTCR = AT91C_PDC_RXTDIS;
   \   00000256   0x2002             MOVS     R0,#+2
   \   00000258   0x....             LDR.N    R1,??DataTable16_20
   \   0000025A   0x6809             LDR      R1,[R1, #+0]
   \   0000025C   0x6809             LDR      R1,[R1, #+0]
   \   0000025E   0xF8C1 0x0120      STR      R0,[R1, #+288]
    796                SSP_psCurrentISR->pBaseAddress->US_IDR  = AT91C_US_ENDRX;
   \   00000262   0x2008             MOVS     R0,#+8
   \   00000264   0x....             LDR.N    R1,??DataTable16_20
   \   00000266   0x6809             LDR      R1,[R1, #+0]
   \   00000268   0x6809             LDR      R1,[R1, #+0]
   \   0000026A   0x60C8             STR      R0,[R1, #+12]
   \   0000026C   0xE02E             B.N      ??SspGenericHandler_8
    797              }
    798              /* Otherwise the peripheral is a Slave that just received a byte */
    799              /* ENDRX Interrupt when a byte has been received (RNCR is moved to RCR; RNPR is copied to RPR))*/
    800              else
    801              {
    802                /* Flag that a byte has arrived */
    803                *SSP_pu32SspApplicationFlagsISR |= _SSP_RX_COMPLETE;
   \                     ??SspGenericHandler_9: (+1)
   \   0000026E   0x....             LDR.N    R0,??DataTable16_22
   \   00000270   0x6800             LDR      R0,[R0, #+0]
   \   00000272   0x6800             LDR      R0,[R0, #+0]
   \   00000274   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000278   0x....             LDR.N    R1,??DataTable16_22
   \   0000027A   0x6809             LDR      R1,[R1, #+0]
   \   0000027C   0x6008             STR      R0,[R1, #+0]
    804          
    805                /* Update the pointer to the next valid Rx location (always leap-frogs the immediate next byte since it will be filled by the other DMA proces */
    806                SSP_psCurrentISR->pBaseAddress->US_RNPR ++;
   \   0000027E   0x....             LDR.N    R0,??DataTable16_20
   \   00000280   0x6800             LDR      R0,[R0, #+0]
   \   00000282   0x6800             LDR      R0,[R0, #+0]
   \   00000284   0xF8D0 0x0110      LDR      R0,[R0, #+272]
   \   00000288   0x1C40             ADDS     R0,R0,#+1
   \   0000028A   0x....             LDR.N    R1,??DataTable16_20
   \   0000028C   0x6809             LDR      R1,[R1, #+0]
   \   0000028E   0x6809             LDR      R1,[R1, #+0]
   \   00000290   0xF8C1 0x0110      STR      R0,[R1, #+272]
    807                if(SSP_psCurrentISR->pBaseAddress->US_RPR == (u32)(SSP_psCurrentISR->pu8RxBuffer + (u32)SSP_psCurrentISR->u16RxBufferSize) )
   \   00000294   0x....             LDR.N    R0,??DataTable16_20
   \   00000296   0x6800             LDR      R0,[R0, #+0]
   \   00000298   0x6800             LDR      R0,[R0, #+0]
   \   0000029A   0xF8D0 0x0100      LDR      R0,[R0, #+256]
   \   0000029E   0x....             LDR.N    R1,??DataTable16_20
   \   000002A0   0x6809             LDR      R1,[R1, #+0]
   \   000002A2   0x69C9             LDR      R1,[R1, #+28]
   \   000002A4   0x....             LDR.N    R2,??DataTable16_20
   \   000002A6   0x6812             LDR      R2,[R2, #+0]
   \   000002A8   0x8C92             LDRH     R2,[R2, #+36]
   \   000002AA   0x1851             ADDS     R1,R2,R1
   \   000002AC   0x4288             CMP      R0,R1
   \   000002AE   0xD107             BNE.N    ??SspGenericHandler_10
    808                {
    809                  SSP_psCurrentISR->pBaseAddress->US_RPR = (u32)SSP_psCurrentISR->pu8RxBuffer;  /* !!!!! CHECK */
   \   000002B0   0x....             LDR.N    R0,??DataTable16_20
   \   000002B2   0x6800             LDR      R0,[R0, #+0]
   \   000002B4   0x69C0             LDR      R0,[R0, #+28]
   \   000002B6   0x....             LDR.N    R1,??DataTable16_20
   \   000002B8   0x6809             LDR      R1,[R1, #+0]
   \   000002BA   0x6809             LDR      R1,[R1, #+0]
   \   000002BC   0xF8C1 0x0100      STR      R0,[R1, #+256]
    810                }
    811                
    812                /* Write RNCR to 1 to clear the ENDRX flag */
    813                SSP_psCurrentISR->pBaseAddress->US_RNCR = 1;
   \                     ??SspGenericHandler_10: (+1)
   \   000002C0   0x2001             MOVS     R0,#+1
   \   000002C2   0x....             LDR.N    R1,??DataTable16_20
   \   000002C4   0x6809             LDR      R1,[R1, #+0]
   \   000002C6   0x6809             LDR      R1,[R1, #+0]
   \   000002C8   0xF8C1 0x0114      STR      R0,[R1, #+276]
    814              }  
    815            } /* end ENDRX handling */
    816          
    817          
    818            /* ENDTX Interrupt when all requested transmit bytes have been sent (if enabled) */
    819            if( (SSP_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDTX) && 
    820                (u32Current_CSR & AT91C_US_ENDTX) )
   \                     ??SspGenericHandler_8: (+1)
   \   000002CC   0x....             LDR.N    R0,??DataTable16_20
   \   000002CE   0x6800             LDR      R0,[R0, #+0]
   \   000002D0   0x6800             LDR      R0,[R0, #+0]
   \   000002D2   0x6900             LDR      R0,[R0, #+16]
   \   000002D4   0x06C0             LSLS     R0,R0,#+27
   \   000002D6   0xD539             BPL.N    ??SspGenericHandler_11
   \   000002D8   0x06F0             LSLS     R0,R6,#+27
   \   000002DA   0xD537             BPL.N    ??SspGenericHandler_11
    821            {
    822              /* Update this message token status and then DeQueue it */
    823              UpdateMessageStatus(SSP_psCurrentISR->psTransmitBuffer->u32Token, COMPLETE);
   \   000002DC   0x2104             MOVS     R1,#+4
   \   000002DE   0x....             LDR.N    R0,??DataTable16_20
   \   000002E0   0x6800             LDR      R0,[R0, #+0]
   \   000002E2   0x6A80             LDR      R0,[R0, #+40]
   \   000002E4   0x6800             LDR      R0,[R0, #+0]
   \   000002E6   0x.... 0x....      BL       UpdateMessageStatus
    824              DeQueueMessage( &SSP_psCurrentISR->psTransmitBuffer );
   \   000002EA   0x....             LDR.N    R0,??DataTable16_20
   \   000002EC   0x6800             LDR      R0,[R0, #+0]
   \   000002EE   0x3028             ADDS     R0,R0,#+40
   \   000002F0   0x.... 0x....      BL       DeQueueMessage
    825              SSP_psCurrentISR->u32PrivateFlags &= ~_SSP_PERIPHERAL_TX;
   \   000002F4   0x....             LDR.N    R0,??DataTable16_20
   \   000002F6   0x6800             LDR      R0,[R0, #+0]
   \   000002F8   0x6900             LDR      R0,[R0, #+16]
   \   000002FA   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   000002FE   0x....             LDR.N    R1,??DataTable16_20
   \   00000300   0x6809             LDR      R1,[R1, #+0]
   \   00000302   0x6108             STR      R0,[R1, #+16]
    826                  
    827              /* Disable the transmitter and interrupt source */
    828              SSP_psCurrentISR->pBaseAddress->US_PTCR = AT91C_PDC_TXTDIS;
   \   00000304   0xF44F 0x7000      MOV      R0,#+512
   \   00000308   0x....             LDR.N    R1,??DataTable16_20
   \   0000030A   0x6809             LDR      R1,[R1, #+0]
   \   0000030C   0x6809             LDR      R1,[R1, #+0]
   \   0000030E   0xF8C1 0x0120      STR      R0,[R1, #+288]
    829              SSP_psCurrentISR->pBaseAddress->US_IDR  = AT91C_US_ENDTX;
   \   00000312   0x2010             MOVS     R0,#+16
   \   00000314   0x....             LDR.N    R1,??DataTable16_20
   \   00000316   0x6809             LDR      R1,[R1, #+0]
   \   00000318   0x6809             LDR      R1,[R1, #+0]
   \   0000031A   0x60C8             STR      R0,[R1, #+12]
    830          
    831              /* Allow the peripheral to finish clocking out the Tx byte */
    832              u32Timeout = 0;
   \   0000031C   0x2000             MOVS     R0,#+0
   \   0000031E   0x0005             MOVS     R5,R0
    833              while ( !(SSP_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_TXEMPTY) && 
    834                      u32Timeout < SSP_TXEMPTY_TIMEOUT)
   \                     ??SspGenericHandler_12: (+1)
   \   00000320   0x....             LDR.N    R0,??DataTable16_20
   \   00000322   0x6800             LDR      R0,[R0, #+0]
   \   00000324   0x6800             LDR      R0,[R0, #+0]
   \   00000326   0x6940             LDR      R0,[R0, #+20]
   \   00000328   0x0580             LSLS     R0,R0,#+22
   \   0000032A   0xD403             BMI.N    ??SspGenericHandler_13
   \   0000032C   0x2D64             CMP      R5,#+100
   \   0000032E   0xD201             BCS.N    ??SspGenericHandler_13
    835              {
    836                u32Timeout++;
   \   00000330   0x1C6D             ADDS     R5,R5,#+1
   \   00000332   0xE7F5             B.N      ??SspGenericHandler_12
    837              } 
    838              
    839              if(SSP_psCurrentISR->SpiMode == SPI_MASTER)
   \                     ??SspGenericHandler_13: (+1)
   \   00000334   0x....             LDR.N    R0,??DataTable16_20
   \   00000336   0x6800             LDR      R0,[R0, #+0]
   \   00000338   0x7B40             LDRB     R0,[R0, #+13]
   \   0000033A   0x2800             CMP      R0,#+0
   \   0000033C   0xD106             BNE.N    ??SspGenericHandler_11
    840              {
    841                /* Deassert chip select when the buffer and shift register are totally empty */
    842                SSP_psCurrentISR->pCsGpioAddress->PIO_SODR = SSP_psCurrentISR->u32CsPin;
   \   0000033E   0x....             LDR.N    R0,??DataTable16_20
   \   00000340   0x6800             LDR      R0,[R0, #+0]
   \   00000342   0x6880             LDR      R0,[R0, #+8]
   \   00000344   0x....             LDR.N    R1,??DataTable16_20
   \   00000346   0x6809             LDR      R1,[R1, #+0]
   \   00000348   0x6849             LDR      R1,[R1, #+4]
   \   0000034A   0x6308             STR      R0,[R1, #+48]
    843              }
    844            } /* end ENDTX interrupt handling */
    845          
    846            
    847          } /* end SspGenericHandler() */
   \                     ??SspGenericHandler_11: (+1)
   \   0000034C   0xBD70             POP      {R4-R6,PC}       ;; return
    848          
    849          
    850          /***********************************************************************************************************************
    851          State Machine Function Definitions
    852          
    853          The SSP state machine monitors messaging activity on the available SSP Master peripherals.  It manages all SSP outgoing messages and will
    854          transmit any message that has been queued.  All configured SSP peripherals can be transmitting and receiving
    855          simultaneously.
    856          
    857          ***********************************************************************************************************************/
    858          
    859          /*-------------------------------------------------------------------------------------------------------------------*/
    860          /* Wait for a transmit message to be queued -- this can include a dummy transmission to receive bytes.
    861          Half duplex transmissions are always assumed. Check one peripheral per iteration. */

   \                                 In section .text, align 4, keep-with-next
    862          void SspSM_Idle(void)
    863          {
   \                     SspSM_Idle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    864           static u8 au8SspErrorInvalidSsp[] = "Invalid SSP attempt\r\n";
    865           u32 u32Byte;
    866            
    867            /* Check all SPI/SSP peripherals for message activity or skip the current peripheral if it is already busy.
    868            Slave devices receive outside of the state machine
    869            For SSP SPI Master mode, the peripheral will have a message queued regardless of whether the intent is send or receive.
    870            For Master devices sending a message, SSP_psCurrentSsp->psTransmitBuffer->pu8Message will point to the application transmit buffer
    871            For Master devices receiving a message, SSP_psCurrentSsp->psTransmitBuffer->pu8Message will point to SSP_au8Dummies */
    872            if( (SSP_psCurrentSsp->psTransmitBuffer != NULL) && 
    873               !(SSP_psCurrentSsp->u32PrivateFlags & (_SSP_PERIPHERAL_TX | _SSP_PERIPHERAL_RX) ) )
   \   00000002   0x....             LDR.N    R0,??DataTable16_18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6A80             LDR      R0,[R0, #+40]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xF000 0x80B5      BEQ.W    ??SspSM_Idle_0
   \   0000000E   0x....             LDR.N    R0,??DataTable16_18
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x6900             LDR      R0,[R0, #+16]
   \   00000014   0xF410 0x0FC0      TST      R0,#0x600000
   \   00000018   0xF040 0x80AE      BNE.W    ??SspSM_Idle_0
    874            {
    875              /* For a Master device, start by asserting chip select */
    876              if(SSP_psCurrentSsp->SpiMode == SPI_MASTER)
   \   0000001C   0x....             LDR.N    R0,??DataTable16_18
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x7B40             LDRB     R0,[R0, #+13]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD106             BNE.N    ??SspSM_Idle_1
    877              {
    878                SSP_psCurrentSsp->pCsGpioAddress->PIO_CODR = SSP_psCurrentSsp->u32CsPin;
   \   00000026   0x....             LDR.N    R0,??DataTable16_18
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x....             LDR.N    R1,??DataTable16_18
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x6849             LDR      R1,[R1, #+4]
   \   00000032   0x6348             STR      R0,[R1, #+52]
    879              }
    880                 
    881              /* Check if the message is receiving based on what psTransmitBuffer is pointing to */
    882              if(SSP_psCurrentSsp->psTransmitBuffer->pu8Message == &SSP_au8Dummies[0])
   \                     ??SspSM_Idle_1: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable16_18
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x6A80             LDR      R0,[R0, #+40]
   \   0000003A   0x3008             ADDS     R0,R0,#+8
   \   0000003C   0x....             LDR.N    R1,??DataTable16_13
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD12C             BNE.N    ??SspSM_Idle_2
    883              {
    884                /* Receiving: update the message's status and flag that the peripheral is now busy */
    885                UpdateMessageStatus(SSP_psCurrentSsp->psTransmitBuffer->u32Token, RECEIVING);
   \   00000042   0x2103             MOVS     R1,#+3
   \   00000044   0x....             LDR.N    R0,??DataTable16_18
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x6A80             LDR      R0,[R0, #+40]
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x.... 0x....      BL       UpdateMessageStatus
    886                SSP_psCurrentSsp->u32PrivateFlags |= _SSP_PERIPHERAL_RX;    
   \   00000050   0x....             LDR.N    R0,??DataTable16_18
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x6900             LDR      R0,[R0, #+16]
   \   00000056   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   0000005A   0x....             LDR.N    R1,??DataTable16_18
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x6108             STR      R0,[R1, #+16]
    887                
    888                /* Load the PDC counter and pointer registers */
    889                SSP_psCurrentSsp->pBaseAddress->US_RPR = (unsigned int)SSP_psCurrentSsp->psTransmitBuffer->pu8Message; 
   \   00000060   0x....             LDR.N    R0,??DataTable16_18
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x6A80             LDR      R0,[R0, #+40]
   \   00000066   0x3008             ADDS     R0,R0,#+8
   \   00000068   0x....             LDR.N    R1,??DataTable16_18
   \   0000006A   0x6809             LDR      R1,[R1, #+0]
   \   0000006C   0x6809             LDR      R1,[R1, #+0]
   \   0000006E   0xF8C1 0x0100      STR      R0,[R1, #+256]
    890                SSP_psCurrentSsp->pBaseAddress->US_RCR = SSP_psCurrentSsp->psTransmitBuffer->u32Size;
   \   00000072   0x....             LDR.N    R0,??DataTable16_18
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x6A80             LDR      R0,[R0, #+40]
   \   00000078   0x6840             LDR      R0,[R0, #+4]
   \   0000007A   0x....             LDR.N    R1,??DataTable16_18
   \   0000007C   0x6809             LDR      R1,[R1, #+0]
   \   0000007E   0x6809             LDR      R1,[R1, #+0]
   \   00000080   0xF8C1 0x0104      STR      R0,[R1, #+260]
    891                
    892                /* When RCR is loaded, the ENDRX flag is cleared so it is safe to enable the interrupt */
    893                SSP_psCurrentSsp->pBaseAddress->US_IER = AT91C_US_ENDRX;
   \   00000084   0x2008             MOVS     R0,#+8
   \   00000086   0x....             LDR.N    R1,??DataTable16_18
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0x6809             LDR      R1,[R1, #+0]
   \   0000008C   0x6088             STR      R0,[R1, #+8]
    894                
    895                /* Enable the receiver to start the transfer */
    896                SSP_psCurrentSsp->pBaseAddress->US_PTCR = AT91C_PDC_RXTEN;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x....             LDR.N    R1,??DataTable16_18
   \   00000092   0x6809             LDR      R1,[R1, #+0]
   \   00000094   0x6809             LDR      R1,[R1, #+0]
   \   00000096   0xF8C1 0x0120      STR      R0,[R1, #+288]
   \   0000009A   0xE06D             B.N      ??SspSM_Idle_0
    897              }
    898              else
    899              {
    900                /* Transmitting: update the message's status and flag that the peripheral is now busy */
    901                UpdateMessageStatus(SSP_psCurrentSsp->psTransmitBuffer->u32Token, SENDING);
   \                     ??SspSM_Idle_2: (+1)
   \   0000009C   0x2102             MOVS     R1,#+2
   \   0000009E   0x....             LDR.N    R0,??DataTable16_18
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x6A80             LDR      R0,[R0, #+40]
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0x.... 0x....      BL       UpdateMessageStatus
    902                SSP_psCurrentSsp->u32PrivateFlags |= _SSP_PERIPHERAL_TX;    
   \   000000AA   0x....             LDR.N    R0,??DataTable16_18
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x6900             LDR      R0,[R0, #+16]
   \   000000B0   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   000000B4   0x....             LDR.N    R1,??DataTable16_18
   \   000000B6   0x6809             LDR      R1,[R1, #+0]
   \   000000B8   0x6108             STR      R0,[R1, #+16]
    903                
    904                /* A Slave device with flow control uses interrupt-driven single byte transfers */
    905                if(SSP_psCurrentSsp->SpiMode == SPI_SLAVE_FLOW_CONTROL)
   \   000000BA   0x....             LDR.N    R0,??DataTable16_18
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x7B40             LDRB     R0,[R0, #+13]
   \   000000C0   0x2802             CMP      R0,#+2
   \   000000C2   0xD13B             BNE.N    ??SspSM_Idle_3
    906                {
    907                  /* At this point, CS is asserted and the master is waiting for flow control.
    908                  Load in the message parameters. */
    909                  SSP_psCurrentSsp->u32CurrentTxBytesRemaining = SSP_psCurrentSsp->psTransmitBuffer->u32Size;
   \   000000C4   0x....             LDR.N    R0,??DataTable16_18
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0x6A80             LDR      R0,[R0, #+40]
   \   000000CA   0x6840             LDR      R0,[R0, #+4]
   \   000000CC   0x....             LDR.N    R1,??DataTable16_18
   \   000000CE   0x6809             LDR      R1,[R1, #+0]
   \   000000D0   0x62C8             STR      R0,[R1, #+44]
    910                  SSP_psCurrentSsp->pu8CurrentTxData = SSP_psCurrentSsp->psTransmitBuffer->pu8Message;
   \   000000D2   0x....             LDR.N    R0,??DataTable16_18
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x6A80             LDR      R0,[R0, #+40]
   \   000000D8   0x3008             ADDS     R0,R0,#+8
   \   000000DA   0x....             LDR.N    R1,??DataTable16_18
   \   000000DC   0x6809             LDR      R1,[R1, #+0]
   \   000000DE   0x6308             STR      R0,[R1, #+48]
    911          
    912                  /* If we need LSB first, use inline assembly to flip bits with a single instruction. */
    913                  u32Byte = 0x000000FF & *SSP_psCurrentSsp->pu8CurrentTxData;
   \   000000E0   0x....             LDR.N    R0,??DataTable16_18
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0x6B00             LDR      R0,[R0, #+48]
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0x0004             MOVS     R4,R0
    914                  if(SSP_psCurrentSsp->BitOrder == LSB_FIRST)
   \   000000EA   0x....             LDR.N    R0,??DataTable16_18
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x7B00             LDRB     R0,[R0, #+12]
   \   000000F0   0x2801             CMP      R0,#+1
   \   000000F2   0xD103             BNE.N    ??SspSM_Idle_4
    915                  {
    916                    u32Byte = __RBIT(u32Byte)>>24;
   \   000000F4   0xFA94 0xF0A4      RBIT     R0,R4
   \   000000F8   0x0E00             LSRS     R0,R0,#+24
   \   000000FA   0x0004             MOVS     R4,R0
    917                  }
    918                  
    919                  /* Reset the transmitter since we have not been managing dummy bytes and it tends to be
    920                  in the middle of a transmission or something that causes the wrong byte to get sent (at least on startup). */
    921                  SSP_psCurrentSsp->pBaseAddress->US_CR = (AT91C_US_RSTTX);
   \                     ??SspSM_Idle_4: (+1)
   \   000000FC   0x2008             MOVS     R0,#+8
   \   000000FE   0x....             LDR.N    R1,??DataTable16_18
   \   00000100   0x6809             LDR      R1,[R1, #+0]
   \   00000102   0x6809             LDR      R1,[R1, #+0]
   \   00000104   0x6008             STR      R0,[R1, #+0]
    922                  SSP_psCurrentSsp->pBaseAddress->US_CR = (AT91C_US_TXEN);
   \   00000106   0x2040             MOVS     R0,#+64
   \   00000108   0x....             LDR.N    R1,??DataTable16_18
   \   0000010A   0x6809             LDR      R1,[R1, #+0]
   \   0000010C   0x6809             LDR      R1,[R1, #+0]
   \   0000010E   0x6008             STR      R0,[R1, #+0]
    923                  SSP_psCurrentSsp->pBaseAddress->US_THR = (u8)u32Byte;
   \   00000110   0x0020             MOVS     R0,R4
   \   00000112   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000114   0x....             LDR.N    R1,??DataTable16_18
   \   00000116   0x6809             LDR      R1,[R1, #+0]
   \   00000118   0x6809             LDR      R1,[R1, #+0]
   \   0000011A   0x61C8             STR      R0,[R1, #+28]
    924                  SSP_psCurrentSsp->pBaseAddress->US_IDR = AT91C_US_RXRDY;
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0x....             LDR.N    R1,??DataTable16_18
   \   00000120   0x6809             LDR      R1,[R1, #+0]
   \   00000122   0x6809             LDR      R1,[R1, #+0]
   \   00000124   0x60C8             STR      R0,[R1, #+12]
    925                  SSP_psCurrentSsp->pBaseAddress->US_IER = AT91C_US_TXEMPTY;
   \   00000126   0xF44F 0x7000      MOV      R0,#+512
   \   0000012A   0x....             LDR.N    R1,??DataTable16_18
   \   0000012C   0x6809             LDR      R1,[R1, #+0]
   \   0000012E   0x6809             LDR      R1,[R1, #+0]
   \   00000130   0x6088             STR      R0,[R1, #+8]
    926                  SSP_psCurrentSsp->fnSlaveTxFlowCallback();
   \   00000132   0x....             LDR.N    R0,??DataTable16_18
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0x6940             LDR      R0,[R0, #+20]
   \   00000138   0x4780             BLX      R0
   \   0000013A   0xE01D             B.N      ??SspSM_Idle_0
    927                }
    928                /* A Master or Slave device without flow control uses the PDC */
    929                else
    930                {
    931                  /* Load the PDC counter and pointer registers */
    932                  SSP_psCurrentSsp->pBaseAddress->US_TPR = (unsigned int)SSP_psCurrentSsp->psTransmitBuffer->pu8Message; 
   \                     ??SspSM_Idle_3: (+1)
   \   0000013C   0x....             LDR.N    R0,??DataTable16_18
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0x6A80             LDR      R0,[R0, #+40]
   \   00000142   0x3008             ADDS     R0,R0,#+8
   \   00000144   0x....             LDR.N    R1,??DataTable16_18
   \   00000146   0x6809             LDR      R1,[R1, #+0]
   \   00000148   0x6809             LDR      R1,[R1, #+0]
   \   0000014A   0xF8C1 0x0108      STR      R0,[R1, #+264]
    933                  SSP_psCurrentSsp->pBaseAddress->US_TCR = SSP_psCurrentSsp->psTransmitBuffer->u32Size;
   \   0000014E   0x....             LDR.N    R0,??DataTable16_18
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x6A80             LDR      R0,[R0, #+40]
   \   00000154   0x6840             LDR      R0,[R0, #+4]
   \   00000156   0x....             LDR.N    R1,??DataTable16_18
   \   00000158   0x6809             LDR      R1,[R1, #+0]
   \   0000015A   0x6809             LDR      R1,[R1, #+0]
   \   0000015C   0xF8C1 0x010C      STR      R0,[R1, #+268]
    934             
    935                  /* When TCR is loaded, the ENDTX flag is cleared so it is safe to enable the interrupt */
    936                  SSP_psCurrentSsp->pBaseAddress->US_IER = AT91C_US_ENDTX;
   \   00000160   0x2010             MOVS     R0,#+16
   \   00000162   0x....             LDR.N    R1,??DataTable16_18
   \   00000164   0x6809             LDR      R1,[R1, #+0]
   \   00000166   0x6809             LDR      R1,[R1, #+0]
   \   00000168   0x6088             STR      R0,[R1, #+8]
    937                  
    938                  /* Enable the transmitter to start the transfer */
    939                  SSP_psCurrentSsp->pBaseAddress->US_PTCR = AT91C_PDC_TXTEN;
   \   0000016A   0xF44F 0x7080      MOV      R0,#+256
   \   0000016E   0x....             LDR.N    R1,??DataTable16_18
   \   00000170   0x6809             LDR      R1,[R1, #+0]
   \   00000172   0x6809             LDR      R1,[R1, #+0]
   \   00000174   0xF8C1 0x0120      STR      R0,[R1, #+288]
    940                }
    941              }
    942            }
    943            
    944            /* Adjust to check the next peripheral next time through */
    945            switch (SSP_psCurrentSsp->u8PeripheralId)
   \                     ??SspSM_Idle_0: (+1)
   \   00000178   0x....             LDR.N    R0,??DataTable16_18
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0xF890 0x0026      LDRB     R0,[R0, #+38]
   \   00000180   0x280D             CMP      R0,#+13
   \   00000182   0xD004             BEQ.N    ??SspSM_Idle_5
   \   00000184   0xD315             BCC.N    ??SspSM_Idle_6
   \   00000186   0x280F             CMP      R0,#+15
   \   00000188   0xD009             BEQ.N    ??SspSM_Idle_7
   \   0000018A   0xD304             BCC.N    ??SspSM_Idle_8
   \   0000018C   0xE011             B.N      ??SspSM_Idle_6
    946            {
    947              case AT91C_ID_US0:
    948                SSP_psCurrentSsp = &SSP_Peripheral1;
   \                     ??SspSM_Idle_5: (+1)
   \   0000018E   0x....             LDR.N    R0,??DataTable16_5
   \   00000190   0x....             LDR.N    R1,??DataTable16_18
   \   00000192   0x6008             STR      R0,[R1, #+0]
    949                break;
   \   00000194   0xE013             B.N      ??SspSM_Idle_9
    950          
    951              case AT91C_ID_US1:
    952                SSP_psCurrentSsp = &SSP_Peripheral2;
   \                     ??SspSM_Idle_8: (+1)
   \   00000196   0x....             LDR.N    R0,??DataTable16_7
   \   00000198   0x....             LDR.N    R1,??DataTable16_18
   \   0000019A   0x6008             STR      R0,[R1, #+0]
    953                break;
   \   0000019C   0xE00F             B.N      ??SspSM_Idle_9
    954          
    955              case AT91C_ID_US2:
    956                SSP_psCurrentSsp = &SSP_Peripheral0;
   \                     ??SspSM_Idle_7: (+1)
   \   0000019E   0x....             LDR.N    R0,??DataTable16_3
   \   000001A0   0x....             LDR.N    R1,??DataTable16_18
   \   000001A2   0x6008             STR      R0,[R1, #+0]
    957                SSP_u32Flags &= ~_SSP_MANUAL_MODE;
   \   000001A4   0x....             LDR.N    R0,??DataTable16_29
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0x0840             LSRS     R0,R0,#+1
   \   000001AA   0x0040             LSLS     R0,R0,#+1
   \   000001AC   0x....             LDR.N    R1,??DataTable16_29
   \   000001AE   0x6008             STR      R0,[R1, #+0]
    958                break;
   \   000001B0   0xE005             B.N      ??SspSM_Idle_9
    959          
    960              default:
    961                DebugPrintf(au8SspErrorInvalidSsp);
   \                     ??SspSM_Idle_6: (+1)
   \   000001B2   0x....             LDR.N    R0,??DataTable16_30
   \   000001B4   0x.... 0x....      BL       DebugPrintf
    962                SSP_psCurrentSsp = &SSP_Peripheral0;
   \   000001B8   0x....             LDR.N    R0,??DataTable16_3
   \   000001BA   0x....             LDR.N    R1,??DataTable16_18
   \   000001BC   0x6008             STR      R0,[R1, #+0]
    963                break;
    964            } /* end switch */
    965            
    966          } /* end SspSM_Idle() */
   \                     ??SspSM_Idle_9: (+1)
   \   000001BE   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .data, align 4
   \                     ??au8SspErrorInvalidSsp:
   \   00000000   0x49 0x6E          DC8 "Invalid SSP attempt\015\012"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x53 0x53    
   \              0x50 0x20    
   \              0x61 0x74    
   \              0x74 0x65    
   \              0x6D 0x70    
   \              0x74 0x0D    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0
    967          
    968          
    969          /*-------------------------------------------------------------------------------------------------------------------*/
    970          /* Handle an error (!!!!!FUTURE) */

   \                                 In section .text, align 2, keep-with-next
    971          void SspSM_Error(void)          
    972          {
    973            Ssp_pfnStateMachine = SspSM_Idle;
   \                     SspSM_Error: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_31
   \   00000002   0x....             LDR.N    R1,??DataTable16_11
   \   00000004   0x6008             STR      R0,[R1, #+0]
    974            
    975          } /* end SspSM_Error() */
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     SSP_Peripheral0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x004008C0         DC32     0x4008c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     SSP_Peripheral1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x004518CE         DC32     0x4518ce

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     SSP_Peripheral2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x004118FF         DC32     0x4118ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x400E0410         DC32     0x400e0410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x00080001         DC32     0x80001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     Ssp_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x........         DC32     SSP_au8Dummies

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   0x40090000         DC32     0x40090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   0x40094000         DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \   00000000   0x........         DC32     SSP_psCurrentSsp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \   00000000   0x........         DC32     ??au8SspStartupMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_20:
   \   00000000   0x........         DC32     SSP_psCurrentISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_21:
   \   00000000   0x........         DC32     G_u32Ssp0ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_22:
   \   00000000   0x........         DC32     SSP_pu32SspApplicationFlagsISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_23:
   \   00000000   0x........         DC32     SSP_u32Int0Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_24:
   \   00000000   0x........         DC32     G_u32Ssp1ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_25:
   \   00000000   0x........         DC32     SSP_u32Int1Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_26:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_27:
   \   00000000   0x........         DC32     SSP_u32Int2Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_28:
   \   00000000   0x........         DC32     SSP_u32AntCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_29:
   \   00000000   0x........         DC32     SSP_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_30:
   \   00000000   0x........         DC32     ??au8SspErrorInvalidSsp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_31:
   \   00000000   0x........         DC32     SspSM_Idle

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0D 0x0A          DC8 "\015\012SSP message to large\012\015"
   \              0x53 0x53    
   \              0x50 0x20    
   \              0x6D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x20 0x6C    
   \              0x61 0x72    
   \              0x67 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    976          
    977                  
    978          /*--------------------------------------------------------------------------------------------------------------------*/
    979          /* End of File */
    980          /*--------------------------------------------------------------------------------------------------------------------*/
    981          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   SSP0_IRQHandler
         8   -> SspGenericHandler
      16   SspGenericHandler
        16   -- Indirect call
        16   -> DeQueueMessage
        16   -> UpdateMessageStatus
      16   SspInitialize
        16   -> DebugPrintf
        16   -> __aeabi_memset
       0   SspManualMode
       8   SspReadByte
         8   -> QueueMessage
      40   SspReadData
        40   -> DebugPrintf
        40   -> QueueMessage
        40   -> __aeabi_memcpy
       8   SspRelease
         8   -> DeQueueMessage
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_DisableIRQ
         8   -> UpdateMessageStatus
      32   SspRequest
        32   -> NVIC_ClearPendingIRQ
        32   -> NVIC_EnableIRQ
       8   SspRunActiveState
         8   -- Indirect call
       0   SspSM_Error
       8   SspSM_Idle
         8   -- Indirect call
         8   -> DebugPrintf
         8   -> UpdateMessageStatus
      24   SspWriteByte
        24   -> QueueMessage
        24   -> SspManualMode
      24   SspWriteData
        24   -> QueueMessage
        24   -> SspManualMode
       8   USART1_IrqHandler
         8   -> SspGenericHandler
       8   USART2_IrqHandler
         8   -> SspGenericHandler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_27
       4  ??DataTable16_28
       4  ??DataTable16_29
       4  ??DataTable16_3
       4  ??DataTable16_30
       4  ??DataTable16_31
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      28  ?_0
       4  G_u32Ssp0ApplicationFlags
       4  G_u32Ssp1ApplicationFlags
       4  G_u32Ssp2ApplicationFlags
      22  NVIC_ClearPendingIRQ
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      42  SSP0_IRQHandler
      52  SSP_Peripheral0
      52  SSP_Peripheral1
      52  SSP_Peripheral2
     128  SSP_au8Dummies
       4  SSP_psCurrentISR
       4  SSP_psCurrentSsp
       4  SSP_pu32SspApplicationFlagsISR
       4  SSP_u32AntCounter
       4  SSP_u32Flags
       4  SSP_u32Int0Count
       4  SSP_u32Int1Count
       4  SSP_u32Int2Count
     846  SspGenericHandler
     254  SspInitialize
       2  SspManualMode
      20  SspReadByte
      52  SspReadData
      92  SspRelease
     328  SspRequest
      12  SspRunActiveState
       8  SspSM_Error
     448  SspSM_Idle
      48  SspWriteByte
      48  SspWriteData
       4  Ssp_pfnStateMachine
      42  USART1_IrqHandler
      42  USART2_IrqHandler
      24  au8SspErrorInvalidSsp
      24  au8SspStartupMessage

 
   332 bytes in section .bss
    48 bytes in section .data
    28 bytes in section .rodata
 2 478 bytes in section .text
 
 2 478 bytes of CODE  memory
    28 bytes of CONST memory
   380 bytes of DATA  memory

Errors: none
Warnings: 1
