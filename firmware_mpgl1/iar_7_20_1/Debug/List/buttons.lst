###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        04/Mar/2016  23:31:45
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\buttons.c
#    Command line =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\buttons.c
#        -D MPGL1 -D MPG1 --preprocess=cl
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\bsp\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline -I "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\buttons.lst
#    Object file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\buttons.o
#
###############################################################################

D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\buttons.c
      1          /***********************************************************************************************************************
      2          File: buttons.c                                                                
      3          
      4          Description:
      5          Button functions and state machine.  The application handles all debouncing and glitch filtering.
      6          
      7          ------------------------------------------------------------------------------------------------------------------------
      8          API:
      9          Types:
     10          MPG1: The argument u32Button_ is either BUTTON0, BUTTON1, BUTTON2, or BUTTON3.  
     11          MPG1: The argument u32Button_ is either BUTTON0 or BUTTON1.  
     12          
     13          Public:
     14          bool IsButtonPressed(u32 u32Button_)
     15          Returns TRUE if Button_aeCurrentState[eButton_] is currently pressed (and debounced).
     16          
     17          bool WasButtonPressed(u32 u32Button_)
     18          Returns TRUE if a particular button was pressed since last time it was checked even if it is no longer pressed.
     19          ButtonAcknowledge is typically called immediately after WasButtonPressed() returns TRUE to clear the button
     20          pressed state.
     21          
     22          void ButtonAcknowledge(u32 u32Button_)
     23          Clears the New Press state of a button -- generally always called after WasButtonPressed() returns TRUE.
     24          
     25          bool IsButtonHeld(u32 u32Button_, u32 u32ButtonHeldTime_)
     26          Returns TRUE if a button has been held for u32ButtonHeldTime_ time in milliseconds.
     27          
     28          Protected:
     29          void ButtonInitialize(void)
     30          Configures the button system for the product including enabling button GPIO interrupts.  
     31          
     32          u32 GetButtonBitLocation(u8 u8Button_, ButtonPortType ePort_)
     33          Returns the location of the button within its port (should be required only for interrupt service routines).  
     34          
     35          DISCLAIMER: THIS CODE IS PROVIDED WITHOUT ANY WARRANTY OR GUARANTEES.  USERS MAY
     36          USE THIS CODE FOR DEVELOPMENT AND EXAMPLE PURPOSES ONLY.  ENGENUICS TECHNOLOGIES
     37          INCORPORATED IS NOT RESPONSIBLE FOR ANY ERRORS, OMISSIONS, OR DAMAGES THAT COULD
     38          RESULT FROM USING THIS FIRMWARE IN WHOLE OR IN PART.
     39          
     40          ***********************************************************************************************************************/
     41          
     42          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable10  ;; 0xe000e100
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable10_1  ;; 0xe000e280
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return
     43          
     44          /***********************************************************************************************************************
     45          Global variable definitions with scope across entire project.
     46          All Global variable names shall start with "G_<type>Button"
     47          ***********************************************************************************************************************/
     48          /* New variables */

   \                                 In section .bss, align 4
     49          volatile bool G_abButtonDebounceActive[TOTAL_BUTTONS];           /* Flags for buttons being debounced */
   \                     G_abButtonDebounceActive:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     50          volatile u32 G_au32ButtonDebounceTimeStart[TOTAL_BUTTONS];       /* Button debounce start time */
   \                     G_au32ButtonDebounceTimeStart:
   \   00000000                      DS8 16
     51          
     52          /*--------------------------------------------------------------------------------------------------------------------*/
     53          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     54          extern volatile u32 G_u32SystemTime1ms;        /* From board-specific source file */
     55          extern volatile u32 G_u32SystemTime1s;         /* From board-specific source file */
     56          
     57          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     58          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     59          
     60          
     61          /***********************************************************************************************************************
     62          Global variable definitions with scope limited to this local application.
     63          Variable names shall start with "Button_" and be declared as static.
     64          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     65          static fnCode_type Button_pfnStateMachine;                  /* The Button application state machine function pointer */
   \                     Button_pfnStateMachine:
   \   00000000                      DS8 4
     66          

   \                                 In section .bss, align 4
     67          static ButtonStateType Button_aeCurrentState[TOTAL_BUTTONS];/* Current pressed state of button */
   \                     Button_aeCurrentState:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     68          static ButtonStateType Button_aeNewState[TOTAL_BUTTONS];    /* New (pending) pressed state of button */
   \                     Button_aeNewState:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     69          static u32 Button_au32HoldTimeStart[TOTAL_BUTTONS];         /* System 1ms time when a button press started */
   \                     Button_au32HoldTimeStart:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     70          static bool Button_abNewPress[TOTAL_BUTTONS];               /* Flags to indicate a button was pressed */    
   \                     Button_abNewPress:
   \   00000000                      DS8 4
     71          
     72          
     73          /************ %BUTTON% EDIT BOARD-SPECIFIC GPIO DEFINITIONS BELOW ***************/
     74          /* Add all of the GPIO pin names for the buttons in the system.  
     75          The order of the definitions below must match the order of the definitions provided in configuration.h */ 
     76          
     77          #ifdef MPGL1

   \                                 In section .rodata, align 4
     78          static const u32 Button_au32ButtonPins[TOTAL_BUTTONS] = 
   \                     Button_au32ButtonPins:
   \   00000000   0x00020000         DC32 131072, 1, 2, 4
   \              0x00000001   
   \              0x00000002   
   \              0x00000004   
     79          {
     80            PA_17_BUTTON0, PB_00_BUTTON1, PB_01_BUTTON2, PB_02_BUTTON3
     81          };
     82          
     83          /* Control array for all buttons in system initialized for ButtonInitialize().  Array values correspond to ButtonConfigType fields: 
     84               eActiveState       ePort                   */

   \                                 In section .data, align 4
     85          static ButtonConfigType Buttons_asArray[TOTAL_BUTTONS] = 
   \                     Buttons_asArray:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 128, 0, 128, 0, 128
   \              0x00 0x80    
   \              0x00 0x80    
   \              0x00 0x80    
     86          {{BUTTON_ACTIVE_LOW, BUTTON_PORTA}, /* BUTTON0  */
     87           {BUTTON_ACTIVE_LOW, BUTTON_PORTB}, /* BUTTON1  */
     88           {BUTTON_ACTIVE_LOW, BUTTON_PORTB}, /* BUTTON2  */
     89           {BUTTON_ACTIVE_LOW, BUTTON_PORTB}, /* BUTTON3  */
     90          };   
     91          #endif /* MPGL1 */
     92          
     93          #ifdef MPGL2
     94          static const u32 Button_au32ButtonPins[TOTAL_BUTTONS] = 
     95          {
     96            PA_17_BUTTON0, PB_00_BUTTON1
     97          };
     98          
     99          /* Control array for all buttons in system initialized for ButtonInitialize().  Array values correspond to ButtonConfigType fields: 
    100               eActiveState       ePort                   */
    101          static ButtonConfigType Buttons_asArray[TOTAL_BUTTONS] = 
    102          {{BUTTON_ACTIVE_LOW, BUTTON_PORTA}, /* BUTTON0  */
    103           {BUTTON_ACTIVE_LOW, BUTTON_PORTB} /* BUTTON1  */
    104          };   
    105          #endif /* MPGL2 */
    106          
    107          /************ EDIT BOARD-SPECIFIC GPIO DEFINITIONS ABOVE ***************/
    108          
    109          
    110          /***********************************************************************************************************************
    111          Function Definitions
    112          ***********************************************************************************************************************/
    113          /*--------------------------------------------------------------------------------------------------------------------*/
    114          /* Public Functions */
    115          /*--------------------------------------------------------------------------------------------------------------------*/
    116          
    117          /*----------------------------------------------------------------------------------------------------------------------
    118          Function: IsButtonPressed
    119          
    120          Description:
    121          Determine if a particular button is currently pressed at this moment in time.
    122          The button must still be pressed at the time of this inquiry for the function
    123          to return TRUE.
    124          
    125          Requires:
    126            - u32Button_ is a valid button index
    127            - Button_aeCurrentState[u32Button_] is valid
    128           
    129          Promises:
    130            - Returns TRUE if Button_aeCurrentState[eButton_] is pressed; otherwise returns FALSE
    131          */

   \                                 In section .text, align 2, keep-with-next
    132          bool IsButtonPressed(u32 u32Button_)
    133          {
   \                     IsButtonPressed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    134            if( Button_aeCurrentState[u32Button_] == PRESSED)
   \   00000002   0x....             LDR.N    R0,??DataTable10_2
   \   00000004   0x5C08             LDRB     R0,[R1, R0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??IsButtonPressed_0
    135            {
    136              return(TRUE);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??IsButtonPressed_1
    137            }
    138            else
    139            {
    140              return(FALSE);
   \                     ??IsButtonPressed_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??IsButtonPressed_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    141            }
    142          
    143          } /* end IsButtonPressed() */
    144          
    145          
    146          /*----------------------------------------------------------------------------------------------------------------------
    147          Function: WasButtonPressed
    148          
    149          Description:
    150          Determines if a particular button was pressed since last time it was checked. 
    151          The button may or may not still be pressed when this inquiry is made.  Mulitple
    152          button presses are not tracked.  The user should call ButtonAcknowledge immediately
    153          following this function to clear the state.
    154          
    155          Requires:
    156            - u32 u32Button_ is a valid button index
    157            - Button_aeCurrentState[u32Button_] is valid
    158           
    159          Promises:
    160            - Returns TRUE if Button_abNewPress[u32Button_] is TRUE; other wise returns FALSE
    161          */

   \                                 In section .text, align 2, keep-with-next
    162          bool WasButtonPressed(u32 u32Button_)
    163          {
   \                     WasButtonPressed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    164            if( Button_abNewPress[u32Button_] == TRUE)
   \   00000002   0x....             LDR.N    R0,??DataTable10_3
   \   00000004   0x5C08             LDRB     R0,[R1, R0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??WasButtonPressed_0
    165            {
    166              return(TRUE);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??WasButtonPressed_1
    167            }
    168            else
    169            {
    170              return(FALSE);
   \                     ??WasButtonPressed_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??WasButtonPressed_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    171            }
    172          
    173          } /* end WasButtonPressed() */
    174          
    175          
    176          /*----------------------------------------------------------------------------------------------------------------------
    177          Function: ButtonAcknowledge
    178          
    179          Description:
    180          Clears the New Press state of a button.
    181          
    182          Requires:
    183            - u32Button_ is a valid button index
    184           
    185          Promises:
    186            - The flag at Button_abNewPress[eButton_] is set to FALSE
    187          */

   \                                 In section .text, align 2, keep-with-next
    188          void ButtonAcknowledge(u32 u32Button_)
    189          {
    190            Button_abNewPress[u32Button_] = FALSE;
   \                     ButtonAcknowledge: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable10_3
   \   00000004   0x5481             STRB     R1,[R0, R2]
    191          
    192          } /* end ButtonAcknowledge() */
   \   00000006   0x4770             BX       LR               ;; return
    193          
    194          
    195          /*----------------------------------------------------------------------------------------------------------------------
    196          Function: IsButtonHeld
    197          
    198          Description:
    199          Queries to see if a button has been held for a certain time.  The button
    200          must still be pressed when this function is called if it is to return TRUE.
    201          
    202          Requires:
    203            - u32Button_ is a valid button index
    204            - u32ButtonHeldTime is a time in ms 
    205           
    206          Promises:
    207            - Returns TRUE if eButton_ has been held longer than u32ButtonHeldTime_
    208          */

   \                                 In section .text, align 2, keep-with-next
    209          bool IsButtonHeld(u32 u32Button_, u32 u32ButtonHeldTime_)
    210          {
   \                     IsButtonHeld: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    211           if( IsButtonPressed(u32Button_) && 
    212               IsTimeUp(&Button_au32HoldTimeStart[u32Button_], u32ButtonHeldTime_ ) )
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       IsButtonPressed
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD009             BEQ.N    ??IsButtonHeld_0
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x....             LDR.N    R0,??DataTable10_4
   \   00000014   0xEB10 0x0084      ADDS     R0,R0,R4, LSL #+2
   \   00000018   0x.... 0x....      BL       IsTimeUp
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??IsButtonHeld_0
    213           {
    214             return(TRUE);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B.N      ??IsButtonHeld_1
    215           }
    216           else
    217           {
    218             return(FALSE);
   \                     ??IsButtonHeld_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??IsButtonHeld_1: (+1)
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    219           }
    220          
    221          } /* end IsButtonHeld() */
    222          
    223          
    224          /*--------------------------------------------------------------------------------------------------------------------*/
    225          /* Protected Functions */
    226          /*--------------------------------------------------------------------------------------------------------------------*/
    227          
    228          /*----------------------------------------------------------------------------------------------------------------------
    229          Function: ButtonInitialize
    230          
    231          Description:
    232          Configures the button system for the product including enabling button GPIO interrupts.  
    233          
    234          Requires:
    235            - GPIO configuration is already complete for all button inputs
    236            - Button interrupt initializations and handler functions are ready
    237           
    238          Promises:
    239            - G_abButtonDebounceActive, LGaeButtonPreviousState and Button_aeCurrentState 
    240              are intialized
    241            - GGstButtonTrackballPosition fields are all initialized to default values
    242            - The button state machine is initialized to Idle
    243          */

   \                                 In section .text, align 2, keep-with-next
    244          void ButtonInitialize(void)
    245          {
   \                     ButtonInitialize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    246            u32 u32PortAInterruptMask = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    247            u32 u32PortBInterruptMask = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    248            static u8 au8ButtonStartupMsg[] = "Button task ready\n\r";
    249            
    250            /* Setup default data for all of the buttons in the system */
    251            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \   00000006   0x2000             MOVS     R0,#+0
   \                     ??ButtonInitialize_0: (+1)
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xDA0D             BGE.N    ??ButtonInitialize_1
    252            {
    253              G_abButtonDebounceActive[i] = FALSE;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x....             LDR.N    R2,??DataTable10_5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5481             STRB     R1,[R0, R2]
    254              Button_aeCurrentState[i]    = RELEASED;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x....             LDR.N    R2,??DataTable10_2
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x5481             STRB     R1,[R0, R2]
    255              Button_aeNewState[i]        = RELEASED;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x....             LDR.N    R2,??DataTable10_6
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x5481             STRB     R1,[R0, R2]
    256            }
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0xE7EE             B.N      ??ButtonInitialize_0
    257            
    258            /* Create masks based on any buttons in the system.  It's ok to have an empty mask. */
    259            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \                     ??ButtonInitialize_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??ButtonInitialize_2: (+1)
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2804             CMP      R0,#+4
   \   00000030   0xDA1A             BGE.N    ??ButtonInitialize_3
    260            {
    261              if(Buttons_asArray[i].ePort == BUTTON_PORTA)
   \   00000032   0x....             LDR.N    R1,??DataTable10_7
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \   0000003A   0x7849             LDRB     R1,[R1, #+1]
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD105             BNE.N    ??ButtonInitialize_4
    262              {
    263                u32PortAInterruptMask |= Button_au32ButtonPins[i];
   \   00000040   0x....             LDR.N    R1,??DataTable10_8
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000048   0x430C             ORRS     R4,R1,R4
   \   0000004A   0xE00B             B.N      ??ButtonInitialize_5
    264              }
    265              else if(Buttons_asArray[i].ePort == BUTTON_PORTB)
   \                     ??ButtonInitialize_4: (+1)
   \   0000004C   0x....             LDR.N    R1,??DataTable10_7
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \   00000054   0x7849             LDRB     R1,[R1, #+1]
   \   00000056   0x2980             CMP      R1,#+128
   \   00000058   0xD104             BNE.N    ??ButtonInitialize_5
    266              {
    267                u32PortBInterruptMask |= Button_au32ButtonPins[i];
   \   0000005A   0x....             LDR.N    R1,??DataTable10_8
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000062   0x430D             ORRS     R5,R1,R5
    268              }
    269            }
   \                     ??ButtonInitialize_5: (+1)
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0xE7E1             B.N      ??ButtonInitialize_2
    270          
    271            /* Enable PIO interrupts */
    272            AT91C_BASE_PIOA->PIO_IER = u32PortAInterruptMask;
   \                     ??ButtonInitialize_3: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable10_9  ;; 0x400e0c40
   \   0000006A   0x6004             STR      R4,[R0, #+0]
    273            AT91C_BASE_PIOB->PIO_IER = u32PortBInterruptMask;
   \   0000006C   0x....             LDR.N    R0,??DataTable10_10  ;; 0x400e0e40
   \   0000006E   0x6005             STR      R5,[R0, #+0]
    274            
    275            /* Read the ISR register to clear all the current flags */
    276            u32PortAInterruptMask = AT91C_BASE_PIOA->PIO_ISR;
   \   00000070   0x....             LDR.N    R0,??DataTable10_11  ;; 0x400e0c4c
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x0004             MOVS     R4,R0
    277            u32PortBInterruptMask = AT91C_BASE_PIOB->PIO_ISR;
   \   00000076   0x....             LDR.N    R0,??DataTable10_12  ;; 0x400e0e4c
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x0005             MOVS     R5,R0
    278          
    279            /* Configure the NVIC to ensure the PIOA and PIOB interrupts are active */
    280            NVIC_ClearPendingIRQ(IRQn_PIOA);
   \   0000007C   0x200A             MOVS     R0,#+10
   \   0000007E   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    281            NVIC_ClearPendingIRQ(IRQn_PIOB);
   \   00000082   0x200B             MOVS     R0,#+11
   \   00000084   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    282            NVIC_EnableIRQ(IRQn_PIOA);
   \   00000088   0x200A             MOVS     R0,#+10
   \   0000008A   0x.... 0x....      BL       NVIC_EnableIRQ
    283            NVIC_EnableIRQ(IRQn_PIOB);
   \   0000008E   0x200B             MOVS     R0,#+11
   \   00000090   0x.... 0x....      BL       NVIC_EnableIRQ
    284              
    285            /* Init complete: set function pointer and application flag */
    286            Button_pfnStateMachine = ButtonSM_Idle;
   \   00000094   0x.... 0x....      ADR.W    R0,ButtonSM_Idle
   \   00000098   0x....             LDR.N    R1,??DataTable10_13
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    287            G_u32ApplicationFlags |= _APPLICATION_FLAGS_BUTTON;
   \   0000009C   0x....             LDR.N    R0,??DataTable10_14
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000A4   0x....             LDR.N    R1,??DataTable10_14
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    288            DebugPrintf(au8ButtonStartupMsg);
   \   000000A8   0x....             LDR.N    R0,??DataTable10_15
   \   000000AA   0x.... 0x....      BL       DebugPrintf
    289          
    290          } /* end ButtonInitialize() */
   \   000000AE   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .data, align 4
   \                     ??au8ButtonStartupMsg:
   \   00000000   0x42 0x75          DC8 "Button task ready\012\015"
   \              0x74 0x74    
   \              0x6F 0x6E    
   \              0x20 0x74    
   \              0x61 0x73    
   \              0x6B 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
    291          
    292          
    293          /*----------------------------------------------------------------------------------------------------------------------
    294          Function ButtonRunActiveState()
    295          
    296          Description:
    297          Selects and runs one iteration of the current state in the state machine.
    298          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    299          may take 1ms / n to execute.
    300          
    301          Requires:
    302            - State machine function pointer points at current state
    303          
    304          Promises:
    305            - Calls the function to pointed by the state machine function pointer
    306          */

   \                                 In section .text, align 2, keep-with-next
    307          void ButtonRunActiveState(void)
    308          {
   \                     ButtonRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    309            Button_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable10_13
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    310          
    311          } /* end ButtonRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    312          
    313          
    314          /*----------------------------------------------------------------------------------------------------------------------
    315          Function: GetButtonBitLocation
    316          
    317          Description:
    318          Returns the location of the button within its port.  
    319          The GPIO interrupt requires access to this function.
    320          
    321          Requires:
    322            - u8Button_ is a valid ButtonNumberType.
    323            - ePort_ is the port where the button is located
    324          
    325          Promises:
    326            - Returns a value that has a bit set in the corresponding position of u32Button_ on the button's port
    327            - Returns 0 if no match
    328          */

   \                                 In section .text, align 2, keep-with-next
    329          u32 GetButtonBitLocation(u8 u8Button_, ButtonPortType ePort_)
    330          {
   \                     GetButtonBitLocation: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    331            /* Make sure the index is valid */
    332            if(u8Button_ < TOTAL_BUTTONS) 
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A04             CMP      R2,#+4
   \   00000006   0xDA0C             BGE.N    ??GetButtonBitLocation_0
    333            {
    334              /* Index is valid so check that the button exists on the port */
    335              if(Buttons_asArray[u8Button_].ePort == ePort_)
   \   00000008   0x....             LDR.N    R0,??DataTable10_7
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xEB10 0x0042      ADDS     R0,R0,R2, LSL #+1
   \   00000010   0x7840             LDRB     R0,[R0, #+1]
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD104             BNE.N    ??GetButtonBitLocation_0
    336              {
    337                /* Return the button position if the index is the correct port */
    338                return(Button_au32ButtonPins[u8Button_]);
   \   00000018   0x....             LDR.N    R0,??DataTable10_8
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   00000020   0xE000             B.N      ??GetButtonBitLocation_1
    339              }
    340            }
    341            
    342            /* Otherwise return 0 */
    343            return(0);
   \                     ??GetButtonBitLocation_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??GetButtonBitLocation_1: (+1)
   \   00000024   0x4770             BX       LR               ;; return
    344            
    345          } /* end GetButtonBitLocation() */
    346          
    347          
    348          /*--------------------------------------------------------------------------------------------------------------------*/
    349          /* Private functions */
    350          /*--------------------------------------------------------------------------------------------------------------------*/
    351          
    352          
    353          /***********************************************************************************************************************
    354          State Machine Function Definitions
    355          
    356          The button state machine monitors button activity and manages debouncing and
    357          maintaining the global button states.
    358          ***********************************************************************************************************************/
    359          
    360          /*--------------------------------------------------------------------------------------------------------------------*/
    361          /* Do nothing but wait for a debounce time to start */

   \                                 In section .text, align 4, keep-with-next
    362          static void ButtonSM_Idle(void)                
    363          {
    364            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \                     ButtonSM_Idle: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \                     ??ButtonSM_Idle_0: (+1)
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2804             CMP      R0,#+4
   \   00000006   0xDA0A             BGE.N    ??ButtonSM_Idle_1
    365            {
    366              if(G_abButtonDebounceActive[i])
   \   00000008   0x....             LDR.N    R1,??DataTable10_5
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x5C41             LDRB     R1,[R0, R1]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD003             BEQ.N    ??ButtonSM_Idle_2
    367              {
    368                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   00000012   0x.... 0x....      ADR.W    R1,ButtonSM_ButtonActive
   \   00000016   0x....             LDR.N    R2,??DataTable10_13
   \   00000018   0x6011             STR      R1,[R2, #+0]
    369              }
    370            }
   \                     ??ButtonSM_Idle_2: (+1)
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xE7F1             B.N      ??ButtonSM_Idle_0
    371            
    372          } /* end ButtonSM_Idle(void) */
   \                     ??ButtonSM_Idle_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    373          
    374          
    375          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    376          static void ButtonSM_ButtonActive(void)         
    377          {
   \                     ButtonSM_ButtonActive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    378            u32 *pu32PortAddress;
    379            u32 *pu32InterruptAddress;
    380          
    381            /* Start by resseting back to Idle in case no buttons are active */
    382            Button_pfnStateMachine = ButtonSM_Idle;
   \   00000002   0x....             LDR.N    R0,??DataTable10_16
   \   00000004   0x....             LDR.N    R1,??DataTable10_13
   \   00000006   0x6008             STR      R0,[R1, #+0]
    383          
    384            /* Check for buttons that are debouncing */
    385            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \   00000008   0x2600             MOVS     R6,#+0
   \                     ??ButtonSM_ButtonActive_0: (+1)
   \   0000000A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   0x2E04             CMP      R6,#+4
   \   0000000E   0xDA74             BGE.N    ??ButtonSM_ButtonActive_1
    386            {
    387              /* Load address offsets for the current button */
    388              pu32PortAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_PDSR) + Buttons_asArray[i].ePort);
   \   00000010   0x....             LDR.N    R0,??DataTable10_17  ;; 0x400e0c3c
   \   00000012   0x....             LDR.N    R1,??DataTable10_7
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0xEB11 0x0146      ADDS     R1,R1,R6, LSL #+1
   \   0000001A   0x7849             LDRB     R1,[R1, #+1]
   \   0000001C   0xEB10 0x0081      ADDS     R0,R0,R1, LSL #+2
   \   00000020   0x0004             MOVS     R4,R0
    389              pu32InterruptAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_IER) + Buttons_asArray[i].ePort);
   \   00000022   0x....             LDR.N    R0,??DataTable10_9  ;; 0x400e0c40
   \   00000024   0x....             LDR.N    R1,??DataTable10_7
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0xEB11 0x0146      ADDS     R1,R1,R6, LSL #+1
   \   0000002C   0x7849             LDRB     R1,[R1, #+1]
   \   0000002E   0xEB10 0x0081      ADDS     R0,R0,R1, LSL #+2
   \   00000032   0x0005             MOVS     R5,R0
    390              
    391              if( G_abButtonDebounceActive[i] )
   \   00000034   0x....             LDR.N    R0,??DataTable10_5
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x5C30             LDRB     R0,[R6, R0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD05B             BEQ.N    ??ButtonSM_ButtonActive_2
    392              {
    393                /* Still have an active button */
    394                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   0000003E   0x....             LDR.N    R0,??DataTable10_18
   \   00000040   0x....             LDR.N    R1,??DataTable10_13
   \   00000042   0x6008             STR      R0,[R1, #+0]
    395                
    396                if( IsTimeUp((u32*)&G_au32ButtonDebounceTimeStart[i], BUTTON_DEBOUNCE_TIME) )
   \   00000044   0x2119             MOVS     R1,#+25
   \   00000046   0x....             LDR.N    R0,??DataTable10_19
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0xEB10 0x0086      ADDS     R0,R0,R6, LSL #+2
   \   0000004E   0x.... 0x....      BL       IsTimeUp
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD04F             BEQ.N    ??ButtonSM_ButtonActive_2
    397                {
    398                  /* Active low: get current state of button */
    399                  if(Buttons_asArray[i].eActiveState == BUTTON_ACTIVE_LOW)
   \   00000056   0x....             LDR.N    R0,??DataTable10_7
   \   00000058   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005A   0xF810 0x0016      LDRB     R0,[R0, R6, LSL #+1]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD111             BNE.N    ??ButtonSM_ButtonActive_3
    400                  {
    401                    if( ~(*pu32PortAddress) & Button_au32ButtonPins[i] )
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x43C0             MVNS     R0,R0
   \   00000066   0x....             LDR.N    R1,??DataTable10_8
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   0000006E   0x4208             TST      R0,R1
   \   00000070   0xD004             BEQ.N    ??ButtonSM_ButtonActive_4
    402                    {          
    403                      Button_aeNewState[i] = PRESSED;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x....             LDR.N    R1,??DataTable10_6
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x5470             STRB     R0,[R6, R1]
   \   0000007A   0xE014             B.N      ??ButtonSM_ButtonActive_5
    404                    }
    405                    else
    406                    {
    407                      Button_aeNewState[i] = RELEASED;
   \                     ??ButtonSM_ButtonActive_4: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x....             LDR.N    R1,??DataTable10_6
   \   00000080   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000082   0x5470             STRB     R0,[R6, R1]
   \   00000084   0xE00F             B.N      ??ButtonSM_ButtonActive_5
    408                    }
    409                  }
    410                  /* Active high */
    411                  else
    412                  {
    413                    if( *pu32PortAddress & Button_au32ButtonPins[i] )
   \                     ??ButtonSM_ButtonActive_3: (+1)
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x....             LDR.N    R1,??DataTable10_8
   \   0000008A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008C   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   00000090   0x4208             TST      R0,R1
   \   00000092   0xD004             BEQ.N    ??ButtonSM_ButtonActive_6
    414                    {          
    415                      Button_aeNewState[i] = PRESSED;
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x....             LDR.N    R1,??DataTable10_6
   \   00000098   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   0x5470             STRB     R0,[R6, R1]
   \   0000009C   0xE003             B.N      ??ButtonSM_ButtonActive_5
    416                    }
    417                    else
    418                    {
    419                      Button_aeNewState[i] = RELEASED;
   \                     ??ButtonSM_ButtonActive_6: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x....             LDR.N    R1,??DataTable10_6
   \   000000A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A4   0x5470             STRB     R0,[R6, R1]
    420                    }
    421                  }
    422                  
    423                  /* Update if the button state has changed */
    424                  if( Button_aeNewState[i] != Button_aeCurrentState[i] )
   \                     ??ButtonSM_ButtonActive_5: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable10_6
   \   000000A8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AA   0x5C30             LDRB     R0,[R6, R0]
   \   000000AC   0x....             LDR.N    R1,??DataTable10_2
   \   000000AE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B0   0x5C71             LDRB     R1,[R6, R1]
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD014             BEQ.N    ??ButtonSM_ButtonActive_7
    425                  {
    426                    Button_aeCurrentState[i] = Button_aeNewState[i];
   \   000000B6   0x....             LDR.N    R0,??DataTable10_6
   \   000000B8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BA   0x5C30             LDRB     R0,[R6, R0]
   \   000000BC   0x....             LDR.N    R1,??DataTable10_2
   \   000000BE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C0   0x5470             STRB     R0,[R6, R1]
    427                    if(Button_aeCurrentState[i] == PRESSED)
   \   000000C2   0x....             LDR.N    R0,??DataTable10_2
   \   000000C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C6   0x5C30             LDRB     R0,[R6, R0]
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD109             BNE.N    ??ButtonSM_ButtonActive_7
    428                    {
    429                      Button_abNewPress[i] = TRUE;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x....             LDR.N    R1,??DataTable10_3
   \   000000D0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D2   0x5470             STRB     R0,[R6, R1]
    430                      Button_au32HoldTimeStart[i] = G_u32SystemTime1ms;
   \   000000D4   0x....             LDR.N    R0,??DataTable10_20
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x....             LDR.N    R1,??DataTable10_4
   \   000000DA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DC   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
    431                    }
    432                  }
    433          
    434                  /* Regardless of a good press or not, clear the debounce active flag and re-enable the interrupts */
    435                  G_abButtonDebounceActive[i] = FALSE;
   \                     ??ButtonSM_ButtonActive_7: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x....             LDR.N    R1,??DataTable10_5
   \   000000E4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E6   0x5470             STRB     R0,[R6, R1]
    436                  *pu32InterruptAddress |= Button_au32ButtonPins[i];
   \   000000E8   0x6828             LDR      R0,[R5, #+0]
   \   000000EA   0x....             LDR.N    R1,??DataTable10_8
   \   000000EC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EE   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   000000F2   0x4308             ORRS     R0,R1,R0
   \   000000F4   0x6028             STR      R0,[R5, #+0]
    437                  
    438                } /* end if( IsTimeUp...) */
    439              } /* end if(G_abButtonDebounceActive[index]) */
    440            } /* end for i */
   \                     ??ButtonSM_ButtonActive_2: (+1)
   \   000000F6   0x1C76             ADDS     R6,R6,#+1
   \   000000F8   0xE787             B.N      ??ButtonSM_ButtonActive_0
    441            
    442          } /* end ButtonSM_ButtonActive() */
   \                     ??ButtonSM_ButtonActive_1: (+1)
   \   000000FA   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     Button_aeCurrentState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     Button_abNewPress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     Button_au32HoldTimeStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     G_abButtonDebounceActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     Button_aeNewState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     Buttons_asArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     Button_au32ButtonPins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x400E0C40         DC32     0x400e0c40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x400E0E40         DC32     0x400e0e40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x400E0C4C         DC32     0x400e0c4c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x400E0E4C         DC32     0x400e0e4c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     Button_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x........         DC32     ??au8ButtonStartupMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x........         DC32     ButtonSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0x400E0C3C         DC32     0x400e0c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   0x........         DC32     ButtonSM_ButtonActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   0x........         DC32     G_au32ButtonDebounceTimeStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   0x........         DC32     G_u32SystemTime1ms
    443          
    444          
    445          
    446          /*--------------------------------------------------------------------------------------------------------------------*/
    447          /* End of File */
    448          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ButtonAcknowledge
      16   ButtonInitialize
        16   -> DebugPrintf
        16   -> NVIC_ClearPendingIRQ
        16   -> NVIC_EnableIRQ
       8   ButtonRunActiveState
         8   -- Indirect call
      16   ButtonSM_ButtonActive
        16   -> IsTimeUp
       0   ButtonSM_Idle
       0   GetButtonBitLocation
      16   IsButtonHeld
        16   -> IsButtonPressed
        16   -> IsTimeUp
       0   IsButtonPressed
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ
       0   WasButtonPressed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       8  ButtonAcknowledge
     176  ButtonInitialize
      10  ButtonRunActiveState
     252  ButtonSM_ButtonActive
      32  ButtonSM_Idle
       4  Button_abNewPress
       4  Button_aeCurrentState
       4  Button_aeNewState
      16  Button_au32ButtonPins
      16  Button_au32HoldTimeStart
       4  Button_pfnStateMachine
       8  Buttons_asArray
       4  G_abButtonDebounceActive
      16  G_au32ButtonDebounceTimeStart
      38  GetButtonBitLocation
      40  IsButtonHeld
      18  IsButtonPressed
      20  NVIC_ClearPendingIRQ
      20  NVIC_EnableIRQ
      18  WasButtonPressed
      20  au8ButtonStartupMsg

 
  52 bytes in section .bss
  28 bytes in section .data
  16 bytes in section .rodata
 716 bytes in section .text
 
 716 bytes of CODE  memory
  16 bytes of CONST memory
  80 bytes of DATA  memory

Errors: none
Warnings: none
