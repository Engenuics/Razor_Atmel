###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        14/Oct/2015  14:35:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\messaging.c
#    Command line =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\messaging.c
#        --preprocess=cl
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\bsp\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline -I "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\messaging.lst
#    Object file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\messaging.o
#
###############################################################################

D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\messaging.c
      1          /**********************************************************************************************************************
      2          File: messaging.c                                                                
      3          
      4          Description:
      5          This file contains utilities to create and monitor outgoing messages.  It essentially provides a 
      6          smart queue system for outgoing data.
      7          Any message being transferred by a peripheral is kept here.  As the peripheral sends the message,
      8          it talks to messaging.c to get data and update the message status.  
      9          All interaction between the peripheral and this task is through unique message tokens that are assigned
     10          to every message queued to messaging.c
     11          ------------------------------------------------------------------------------------------------------------------------
     12          API:
     13          
     14          TYPES
     15          MessageStateType: enum status of a message in the queue
     16          EMPTY, WAITING, SENDING, RECEIVING, COMPLETE, TIMEOUT, ABANDONED, NOT_FOUND
     17          
     18          MessageType: linked-list style entry with token, size, data pointer and next MessageType pointer
     19          
     20          MessageSlot: member of the message queue holding the free/full status of a particular queue location and a pointer to its data
     21          
     22          MessageStatus: token, state and timestamp of a message in the queue
     23          
     24          FUNCTIONS
     25          Public:
     26          MessageStateType QueryMessageStatus(u32 u32Token_)
     27          Queries the current status of the message with u32Token.  If the message has completed or timed out, the query will
     28          cause the message status to be removed from the status queue.
     29          
     30          Protected:
     31          void MessagingInitialize(void)
     32          One-time call to start the messaging application.
     33          
     34          u32 QueueMessage(MessageType** eTargetTxBuffer_, u32 u32MessageSize_, u8* pu8MessageData_)
     35          Adds a message to the correct data queue, assigns a token which is posted to the status queue and returned to the client.
     36          This function is Protected because tasks that can queue messages should be managed carefully and not granted free reign
     37          to queue messages.  The message queue is a finite resource with TX_QUEUE_SIZE slots available for messages.
     38          We avoid dynamic allocation due to the inherent issues with fragmentation on resource-limited systems.
     39          
     40          void DeQueueMessage(MessageType** pTargetQueue_)
     41          Removes a message from the message queue (typically since all the bytes have been submitted to the communication peripheral
     42          which is sending the message.  The message status is updated in the status queue.
     43          
     44          void UpdateMessageStatus(u32 u32Token_, MessageStateType eNewState_)
     45          Changes the status of a message in the statue queue.
     46          
     47          **********************************************************************************************************************/
     48          
     49          #include "configuration.h"
     50          
     51          /***********************************************************************************************************************
     52          Global variable definitions with scope across entire project.
     53          All Global variable names shall start with "G_xxMessaging"
     54          ***********************************************************************************************************************/
     55          /* New variables */

   \                                 In section .bss, align 4
     56          u32 G_u32MessagingFlags;                                 /* Global state flags */
   \                     G_u32MessagingFlags:
   \   00000000                      DS8 4
     57          
     58          /*--------------------------------------------------------------------------------------------------------------------*/
     59          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     60          extern volatile u32 G_u32SystemFlags;                    /* From main.c */
     61          extern volatile u32 G_u32ApplicationFlags;               /* From main.c */
     62          
     63          extern volatile u32 G_u32SystemTime1ms;                  /* From board-specific source file */
     64          extern volatile u32 G_u32SystemTime1s;                   /* From board-specific source file */
     65          
     66          
     67          /***********************************************************************************************************************
     68          Global variable definitions with scope limited to this local application.
     69          Variable names shall start with "Msg_" and be declared as static.
     70          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     71          static fnCode_type Messaging_pfnStateMachine;            /* The state machine function pointer */
   \                     Messaging_pfnStateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     72          static u32 Msg_u32Token;                                 /* Incrementing message token used for all external communications */
   \                     Msg_u32Token:
   \   00000000                      DS8 4
     73          

   \                                 In section .bss, align 4
     74          static MessageSlot Msg_Pool[TX_QUEUE_SIZE];              /* Array of MessageSlot used for the transmit queue */
   \                     Msg_Pool:
   \   00000000                      DS8 2304

   \                                 In section .bss, align 1
     75          static u8 Msg_u8QueuedMessageCount;                      /* Number of messages slots currently occupied */
   \                     Msg_u8QueuedMessageCount:
   \   00000000                      DS8 1
     76          
     77          /* A separate status queue needs to be maintained since the message information in Msg_Pool will be lost when the message
     78          has been dequeued.  Applications must be able to query to determine the status of their message, particularly if
     79          it has been sent. */

   \                                 In section .bss, align 4
     80          static MessageStatus Msg_StatusQueue[STATUS_QUEUE_SIZE]; /* Array of MessageStatus used to monitor message status */
   \                     Msg_StatusQueue:
   \   00000000                      DS8 768

   \                                 In section .bss, align 4
     81          static MessageStatus* Msg_pNextStatus;                   /* Pointer to next available message status */
   \                     Msg_pNextStatus:
   \   00000000                      DS8 4
     82          
     83          
     84          /**********************************************************************************************************************
     85          Function Definitions
     86          **********************************************************************************************************************/
     87          
     88          /*--------------------------------------------------------------------------------------------------------------------*/
     89          /* Public Functions */
     90          /*--------------------------------------------------------------------------------------------------------------------*/
     91          
     92          /*----------------------------------------------------------------------------------------------------------------------
     93          Function: QueryMessageStatus()
     94          
     95          Description:
     96          Checks the state of a message.  If the state is COMPLETE or TIMEOUT, the status is deleted from the message queue.
     97          Since the queue is quite short, most of the time it will hold very little entires.  New entries are always filled at the front,
     98          using a simple linear search starting at index 0.
     99          
    100          Requires:
    101            - u32Token_ is the token of the message of interest
    102          
    103          Promises:
    104            - Returns MessageStateType indicating the status of the message
    105            - if the message is found in COMPLETE or TIMEOUT state, the status is removed from the queue
    106          */

   \                                 In section .text, align 2, keep-with-next
    107          MessageStateType QueryMessageStatus(u32 u32Token_)
    108          {
   \                     QueryMessageStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    109            MessageStateType eStatus   = NOT_FOUND;
   \   00000002   0x20FF             MOVS     R0,#+255
    110            MessageStatus* pListParser = &Msg_StatusQueue[0];
   \   00000004   0x....             LDR.N    R2,??DataTable8
    111            
    112            /* Brute force search for the token - the queue will never be large enough on this system to require a more
    113            intelligent search algorithm */
    114            while( (pListParser->u32Token != u32Token_) && (pListParser != &Msg_StatusQueue[STATUS_QUEUE_SIZE]) )
   \                     ??QueryMessageStatus_0: (+1)
   \   00000006   0x6813             LDR      R3,[R2, #+0]
   \   00000008   0x428B             CMP      R3,R1
   \   0000000A   0xD004             BEQ.N    ??QueryMessageStatus_1
   \   0000000C   0x....             LDR.N    R3,??DataTable8_1
   \   0000000E   0x429A             CMP      R2,R3
   \   00000010   0xD001             BEQ.N    ??QueryMessageStatus_1
    115            {
    116              pListParser++;
   \   00000012   0x320C             ADDS     R2,R2,#+12
   \   00000014   0xE7F7             B.N      ??QueryMessageStatus_0
    117            }
    118          
    119            /* If the token was found pListParser is pointing at it, take appropriate action */
    120            if(pListParser != &Msg_StatusQueue[STATUS_QUEUE_SIZE])
   \                     ??QueryMessageStatus_1: (+1)
   \   00000016   0x....             LDR.N    R3,??DataTable8_1
   \   00000018   0x429A             CMP      R2,R3
   \   0000001A   0xD00B             BEQ.N    ??QueryMessageStatus_2
    121            {
    122              /* Save the status */
    123              eStatus = pListParser->eState;
   \   0000001C   0x7913             LDRB     R3,[R2, #+4]
   \   0000001E   0x0018             MOVS     R0,R3
    124          
    125              /* Release the slot if the message state is final (the client must deal with it now) */
    126              if( (eStatus == COMPLETE) || (eStatus == TIMEOUT) )
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2804             CMP      R0,#+4
   \   00000024   0xD002             BEQ.N    ??QueryMessageStatus_3
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD103             BNE.N    ??QueryMessageStatus_2
    127              {
    128                pListParser->u32Token = 0;
   \                     ??QueryMessageStatus_3: (+1)
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x6013             STR      R3,[R2, #+0]
    129                pListParser->eState = EMPTY;
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x7113             STRB     R3,[R2, #+4]
    130              }
    131            }
    132          
    133            return(eStatus);
   \                     ??QueryMessageStatus_2: (+1)
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x4770             BX       LR               ;; return
    134            
    135          } /* end QueryMessageStatus() */
    136          
    137          
    138          /*--------------------------------------------------------------------------------------------------------------------*/
    139          /* Protected Functions */
    140          /*--------------------------------------------------------------------------------------------------------------------*/
    141          
    142          /*----------------------------------------------------------------------------------------------------------------------
    143          Function: QueueMessage
    144          
    145          Description:
    146          Allocates one of the positions in the message queue to the calling function's send queue.
    147          
    148          Requires:
    149            - eTargetTxBuffer_ is the peripheral transmit buffer where the message will be queued
    150            - u32MessageSize_ is the size of the message data array in bytes
    151            - pu8MessageData_ points to the message data array
    152            - Msg_Pool should not be full 
    153          
    154          Promises:
    155            - The message is inserted into the target list and assigned a token
    156            - If the message is created successfully, the message token is returned; otherwise, NULL is returned
    157          */

   \                                 In section .text, align 2, keep-with-next
    158          u32 QueueMessage(MessageType** eTargetTxBuffer_, u32 u32MessageSize_, u8* pu8MessageData_)
    159          {
   \                     QueueMessage: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    160            MessageSlot *psSlotParser;
    161            MessageType *psNewMessage;
    162            MessageType *psListParser;
    163            u32 u32BytesRemaining = u32MessageSize_;
   \   0000000A   0x46AB             MOV      R11,R5
    164            u32 u32CurrentMessageSize = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    165          
    166          #ifndef SIMULATOR_MODE
    167            /* Check for available space in the message pool */
    168            if(Msg_u8QueuedMessageCount == TX_QUEUE_SIZE)
    169            {
    170              G_u32MessagingFlags |= _MESSAGING_TX_QUEUE_FULL;
    171              return(0);
    172            }
    173          #else
    174            /* To do: Wrap around to the front of the list and free the first message so this acts like a circular buffer */
    175            
    176          #endif /* SIMULATOR_MODE */
    177            
    178            /* Space available, so proceed with allocation.  Though only one message is queued at a time, we
    179            use a while loop to handle messages that are too big and must be split into different slots.  The slots
    180            are always sequential and the message processor will send the bytes continuously across slots */
    181            while(u32BytesRemaining)
   \                     ??QueueMessage_0: (+1)
   \   00000010   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000014   0xD062             BEQ.N    ??QueueMessage_1
    182            {
    183              Msg_u8QueuedMessageCount++;
   \   00000016   0x....             LDR.N    R0,??DataTable8_2
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable8_2
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    184              
    185              /* Flag if we're above the high watermark */
    186              if(Msg_u8QueuedMessageCount >= TX_QUEUE_WATERMARK)
   \   00000020   0x....             LDR.N    R0,??DataTable8_2
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x280E             CMP      R0,#+14
   \   00000026   0xDB06             BLT.N    ??QueueMessage_2
    187              {
    188                G_u32MessagingFlags |= _MESSAGING_TX_QUEUE_ALMOST_FULL;
   \   00000028   0x....             LDR.N    R0,??DataTable8_3
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000030   0x....             LDR.N    R1,??DataTable8_3
   \   00000032   0x6008             STR      R0,[R1, #+0]
   \   00000034   0xE005             B.N      ??QueueMessage_3
    189              }
    190              else
    191              {
    192                G_u32MessagingFlags &= ~_MESSAGING_TX_QUEUE_ALMOST_FULL;
   \                     ??QueueMessage_2: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable8_3
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000003E   0x....             LDR.N    R1,??DataTable8_3
   \   00000040   0x6008             STR      R0,[R1, #+0]
    193              }
    194              
    195              /* Find an empty slot: this is non-circular and there must be at least one free slot if we're here */
    196              psSlotParser = &Msg_Pool[0];
   \                     ??QueueMessage_3: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable8_4
   \   00000044   0x4682             MOV      R10,R0
    197              while(!psSlotParser->bFree)
   \                     ??QueueMessage_4: (+1)
   \   00000046   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD102             BNE.N    ??QueueMessage_5
    198              {
    199                psSlotParser++;
   \   0000004E   0xF11A 0x0A90      ADDS     R10,R10,#+144
   \   00000052   0xE7F8             B.N      ??QueueMessage_4
    200              }
    201              
    202              /* Allocate the slot and set the message pointer */
    203              psSlotParser->bFree = FALSE;
   \                     ??QueueMessage_5: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF88A 0x0000      STRB     R0,[R10, #+0]
    204              psNewMessage = &(psSlotParser->Message);
   \   0000005A   0xF11A 0x0004      ADDS     R0,R10,#+4
   \   0000005E   0x0007             MOVS     R7,R0
    205            
    206              /* Check the message size and split the message up if necessary */
    207              if(u32BytesRemaining > MAX_TX_MESSAGE_LENGTH)
   \   00000060   0xF1BB 0x0F81      CMP      R11,#+129
   \   00000064   0xD304             BCC.N    ??QueueMessage_6
    208              {
    209                u32CurrentMessageSize = MAX_TX_MESSAGE_LENGTH;
   \   00000066   0x2080             MOVS     R0,#+128
   \   00000068   0x4681             MOV      R9,R0
    210                u32BytesRemaining -= MAX_TX_MESSAGE_LENGTH;
   \   0000006A   0xF1BB 0x0B80      SUBS     R11,R11,#+128
   \   0000006E   0xE002             B.N      ??QueueMessage_7
    211              }
    212              else
    213              {
    214                u32CurrentMessageSize = u32BytesRemaining;
   \                     ??QueueMessage_6: (+1)
   \   00000070   0x46D9             MOV      R9,R11
    215                u32BytesRemaining = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4683             MOV      R11,R0
    216              }
    217              
    218              /* Copy all the data to the allocated message structure */
    219              psNewMessage->u32Token      = Msg_u32Token;
   \                     ??QueueMessage_7: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable8_5
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x6038             STR      R0,[R7, #+0]
    220              psNewMessage->u32Size       = u32CurrentMessageSize;
   \   0000007C   0xF8C7 0x9004      STR      R9,[R7, #+4]
    221              psNewMessage->psNextMessage = NULL;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF8C7 0x0088      STR      R0,[R7, #+136]
    222              
    223              /* Add the data into the payload */
    224              for(u32 i = 0; i < psNewMessage->u32Size; i++)
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??QueueMessage_8: (+1)
   \   00000088   0x6879             LDR      R1,[R7, #+4]
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xD205             BCS.N    ??QueueMessage_9
    225              {
    226                *(psNewMessage->pu8Message + i) = *pu8MessageData_++;
   \   0000008E   0x7831             LDRB     R1,[R6, #+0]
   \   00000090   0x19C2             ADDS     R2,R0,R7
   \   00000092   0x7211             STRB     R1,[R2, #+8]
   \   00000094   0x1C76             ADDS     R6,R6,#+1
    227              }
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   \   00000098   0xE7F6             B.N      ??QueueMessage_8
    228            
    229              /* Link the new message into the client's transmit buffer */
    230              /* Handle an empty list */
    231              if(*eTargetTxBuffer_ == NULL)
   \                     ??QueueMessage_9: (+1)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD101             BNE.N    ??QueueMessage_10
    232              {
    233                *eTargetTxBuffer_ = psNewMessage;
   \   000000A0   0x6027             STR      R7,[R4, #+0]
   \   000000A2   0xE00A             B.N      ??QueueMessage_11
    234              }
    235          
    236              /* Add the message to the end of the list */
    237              else
    238              {
    239                /* Find the last node */
    240                psListParser =  *eTargetTxBuffer_;
   \                     ??QueueMessage_10: (+1)
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x4680             MOV      R8,R0
    241                while(psListParser->psNextMessage != NULL)
   \                     ??QueueMessage_12: (+1)
   \   000000A8   0xF8D8 0x0088      LDR      R0,[R8, #+136]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD002             BEQ.N    ??QueueMessage_13
    242                {
    243                  psListParser = psListParser->psNextMessage;
   \   000000B0   0xF8D8 0x8088      LDR      R8,[R8, #+136]
   \   000000B4   0xE7F8             B.N      ??QueueMessage_12
    244                }
    245               
    246                /* Found the end: add the new node */
    247                psListParser->psNextMessage = psNewMessage;
   \                     ??QueueMessage_13: (+1)
   \   000000B6   0xF8C8 0x7088      STR      R7,[R8, #+136]
    248              }
    249            
    250              /* Update the Public status of the message in the status queue */
    251              AddNewMessageStatus(Msg_u32Token);
   \                     ??QueueMessage_11: (+1)
   \   000000BA   0x....             LDR.N    R0,??DataTable8_5
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x.... 0x....      BL       AddNewMessageStatus
    252            
    253              /* Increment message token and catch the rollover every 4 billion messages... Token 0 is not allowed. */
    254              if(++Msg_u32Token == 0)
   \   000000C2   0x....             LDR.N    R0,??DataTable8_5
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \   000000C8   0x....             LDR.N    R1,??DataTable8_5
   \   000000CA   0x6008             STR      R0,[R1, #+0]
   \   000000CC   0x....             LDR.N    R0,??DataTable8_5
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD19D             BNE.N    ??QueueMessage_0
    255              {
    256                Msg_u32Token = 1;
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x....             LDR.N    R1,??DataTable8_5
   \   000000D8   0x6008             STR      R0,[R1, #+0]
   \   000000DA   0xE799             B.N      ??QueueMessage_0
    257              }
    258            
    259            } /* end while */
    260          
    261            /* Return only the current (and highest) message token, as it will be the last portion to be sent if the message was split up */
    262            return(psNewMessage->u32Token);
   \                     ??QueueMessage_1: (+1)
   \   000000DC   0x6838             LDR      R0,[R7, #+0]
   \   000000DE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    263            
    264          } /* end QueueMessage() */
    265          
    266          
    267          /*----------------------------------------------------------------------------------------------------------------------
    268          Function: DeQueueMessage
    269          
    270          Description:
    271          Removes a message from a message queue and adds it back to the pool.
    272          
    273          Requires:
    274            - pTargetQueue_ points to the list queue where the message to be deleted is located
    275            - pTargetQueue_ is a FIFO linked-list where the message that needs to be killed is at the front of the list
    276            - The message to be removed has been completely sent and is no longer in use
    277            - New message cannot be added into the list during this function (via interrupts)
    278          
    279          Promises:
    280            - The first message in the list is deleted; the list is hooked back up
    281            - The message space is added back to the available message queue
    282          */

   \                                 In section .text, align 2, keep-with-next
    283          void DeQueueMessage(MessageType** pTargetQueue_)
    284          {
    285            MessageSlot *psSlotParser;
    286                
    287            /* Make sure there is a message to kill */
    288            if(*pTargetQueue_ == NULL)
   \                     DeQueueMessage: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD106             BNE.N    ??DeQueueMessage_0
    289            {
    290              G_u32MessagingFlags |= _DEQUEUE_GOT_NULL;
   \   00000006   0x....             LDR.N    R2,??DataTable8_3
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   0000000E   0x....             LDR.N    R3,??DataTable8_3
   \   00000010   0x601A             STR      R2,[R3, #+0]
    291              return;
   \   00000012   0xE01F             B.N      ??DeQueueMessage_1
    292            }
    293            
    294            /* Find the message's slot: this message pool is non-circular and the message must be one of the slots */
    295            psSlotParser = &Msg_Pool[0];
   \                     ??DeQueueMessage_0: (+1)
   \   00000014   0x....             LDR.N    R2,??DataTable8_4
   \   00000016   0x0011             MOVS     R1,R2
    296            while( (&psSlotParser->Message != *pTargetQueue_) && (psSlotParser != &Msg_Pool[TX_QUEUE_SIZE]) )
   \                     ??DeQueueMessage_2: (+1)
   \   00000018   0x1D0A             ADDS     R2,R1,#+4
   \   0000001A   0x6803             LDR      R3,[R0, #+0]
   \   0000001C   0x429A             CMP      R2,R3
   \   0000001E   0xD004             BEQ.N    ??DeQueueMessage_3
   \   00000020   0x....             LDR.N    R2,??DataTable8_6
   \   00000022   0x4291             CMP      R1,R2
   \   00000024   0xD001             BEQ.N    ??DeQueueMessage_3
    297            {
    298              psSlotParser++;
   \   00000026   0x3190             ADDS     R1,R1,#+144
   \   00000028   0xE7F6             B.N      ??DeQueueMessage_2
    299            }
    300          
    301            /* Make sure the message has been found */
    302            if(psSlotParser == &Msg_Pool[TX_QUEUE_SIZE])
   \                     ??DeQueueMessage_3: (+1)
   \   0000002A   0x....             LDR.N    R2,??DataTable8_6
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD106             BNE.N    ??DeQueueMessage_4
    303            {
    304              G_u32MessagingFlags |= _DEQUEUE_MSG_NOT_FOUND;
   \   00000030   0x....             LDR.N    R2,??DataTable8_3
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0xF052 0x0208      ORRS     R2,R2,#0x8
   \   00000038   0x....             LDR.N    R3,??DataTable8_3
   \   0000003A   0x601A             STR      R2,[R3, #+0]
    305              return;
   \   0000003C   0xE00A             B.N      ??DeQueueMessage_1
    306            }
    307          
    308            /* Unhook the message from the current owner's queue and put it back in the pool */
    309            *pTargetQueue_ = (*pTargetQueue_)->psNextMessage;
   \                     ??DeQueueMessage_4: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0xF8D2 0x2088      LDR      R2,[R2, #+136]
   \   00000044   0x6002             STR      R2,[R0, #+0]
    310            psSlotParser->bFree = TRUE;
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x700A             STRB     R2,[R1, #+0]
    311            Msg_u8QueuedMessageCount--;
   \   0000004A   0x....             LDR.N    R2,??DataTable8_2
   \   0000004C   0x7812             LDRB     R2,[R2, #+0]
   \   0000004E   0x1E52             SUBS     R2,R2,#+1
   \   00000050   0x....             LDR.N    R3,??DataTable8_2
   \   00000052   0x701A             STRB     R2,[R3, #+0]
    312            
    313          } /* end DeQueueMessage() */
   \                     ??DeQueueMessage_1: (+1)
   \   00000054   0x4770             BX       LR               ;; return
    314          
    315          
    316          /*--------------------------------------------------------------------------------------------------------------------
    317          Function: MessagingInitialize
    318          
    319          Description:
    320          Initializes the State Machine and its variables.
    321          
    322          Requires:
    323            - No messaging in progress
    324          
    325          Promises:
    326            - Message queues are zeroed
    327            - Flags and state machine are initialized
    328          */

   \                                 In section .text, align 2, keep-with-next
    329          void MessagingInitialize(void)
    330          {
    331            /* Inititalize variables */
    332            Msg_u8QueuedMessageCount = 0;
   \                     MessagingInitialize: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable8_2
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    333            Msg_u32Token = 1;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable8_5
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    334          
    335            /* Ensure all message slots are deallocated and the message status queue is empty */
    336            for(u16 i = 0; i < TX_QUEUE_SIZE; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??MessagingInitialize_0: (+1)
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x2810             CMP      R0,#+16
   \   00000012   0xDA08             BGE.N    ??MessagingInitialize_1
    337            {
    338              Msg_Pool[i].bFree = TRUE;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x....             LDR.N    R2,??DataTable8_4
   \   00000018   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001A   0x2390             MOVS     R3,#+144
   \   0000001C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000020   0x7011             STRB     R1,[R2, #+0]
    339            }
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0xE7F3             B.N      ??MessagingInitialize_0
    340          
    341            for(u16 i = 0; i < STATUS_QUEUE_SIZE; i++)
   \                     ??MessagingInitialize_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??MessagingInitialize_2: (+1)
   \   00000028   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002A   0x2840             CMP      R0,#+64
   \   0000002C   0xDA16             BGE.N    ??MessagingInitialize_3
    342            {
    343              Msg_StatusQueue[i].u32Token = 0;
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x....             LDR.N    R2,??DataTable8
   \   00000032   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000034   0x230C             MOVS     R3,#+12
   \   00000036   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000003A   0x6011             STR      R1,[R2, #+0]
    344              Msg_StatusQueue[i].eState = EMPTY;
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x....             LDR.N    R2,??DataTable8
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x230C             MOVS     R3,#+12
   \   00000044   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000048   0x7111             STRB     R1,[R2, #+4]
    345              Msg_StatusQueue[i].u32Timestamp = 0;
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x....             LDR.N    R2,??DataTable8
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0x230C             MOVS     R3,#+12
   \   00000052   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000056   0x6091             STR      R1,[R2, #+8]
    346            }
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0xE7E5             B.N      ??MessagingInitialize_2
    347          
    348            Msg_pNextStatus = &Msg_StatusQueue[0];
   \                     ??MessagingInitialize_3: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable8
   \   0000005E   0x....             LDR.N    R1,??DataTable8_7
   \   00000060   0x6008             STR      R0,[R1, #+0]
    349          
    350            G_u32MessagingFlags = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x....             LDR.N    R1,??DataTable8_3
   \   00000066   0x6008             STR      R0,[R1, #+0]
    351            Messaging_pfnStateMachine = MessagingIdle;
   \   00000068   0x.... 0x....      ADR.W    R0,MessagingIdle
   \   0000006C   0x....             LDR.N    R1,??DataTable8_8
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    352          
    353          } /* end MessagingInitialize() */
   \   00000070   0x4770             BX       LR               ;; return
    354          
    355          
    356          /*----------------------------------------------------------------------------------------------------------------------
    357          Function MessagingRunActiveState()
    358          
    359          Description:
    360          Selects and runs one iteration of the current state in the state machine.
    361          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    362          may take 1ms / n to execute.
    363          
    364          Requires:
    365            - State machine function pointer points at current state
    366          
    367          Promises:
    368            - Calls the function to pointed by the state machine function pointer
    369          */

   \                                 In section .text, align 2, keep-with-next
    370          void MessagingRunActiveState(void)
    371          {
   \                     MessagingRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    372            Messaging_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable8_8
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    373          
    374          } /* end MessagingRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    375          
    376          
    377          /*----------------------------------------------------------------------------------------------------------------------
    378          Function: UpdateMessageStatus()
    379          
    380          Description:
    381          Changes the status of a message in the statue queue.
    382          
    383          Requires:
    384            - u32Token_ is message that should be in the status queue
    385            - eNewState_ is the desired status setting for the message
    386          
    387          Promises:
    388            - eState of the message is set to eNewState_
    389          */

   \                                 In section .text, align 2, keep-with-next
    390          void UpdateMessageStatus(u32 u32Token_, MessageStateType eNewState_)
    391          {
    392            MessageStatus* pListParser = &Msg_StatusQueue[0];
   \                     UpdateMessageStatus: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable8
    393            
    394            /* Search for the token */
    395            while( (pListParser->u32Token != u32Token_) && (pListParser != &Msg_StatusQueue[STATUS_QUEUE_SIZE]) )
   \                     ??UpdateMessageStatus_0: (+1)
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0x4283             CMP      R3,R0
   \   00000006   0xD004             BEQ.N    ??UpdateMessageStatus_1
   \   00000008   0x....             LDR.N    R3,??DataTable8_1
   \   0000000A   0x429A             CMP      R2,R3
   \   0000000C   0xD001             BEQ.N    ??UpdateMessageStatus_1
    396            {
    397              pListParser++;
   \   0000000E   0x320C             ADDS     R2,R2,#+12
   \   00000010   0xE7F7             B.N      ??UpdateMessageStatus_0
    398            }
    399          
    400            /* If the token was found, change the status */
    401            if(pListParser != &Msg_StatusQueue[STATUS_QUEUE_SIZE])
   \                     ??UpdateMessageStatus_1: (+1)
   \   00000012   0x....             LDR.N    R3,??DataTable8_1
   \   00000014   0x429A             CMP      R2,R3
   \   00000016   0xD000             BEQ.N    ??UpdateMessageStatus_2
    402            {
    403              pListParser->eState = eNewState_;
   \   00000018   0x7111             STRB     R1,[R2, #+4]
    404            }
    405            
    406          } /* end UpdateMessageStatus() */
   \                     ??UpdateMessageStatus_2: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    407          
    408          
    409          /*--------------------------------------------------------------------------------------------------------------------*/
    410          /* Private functions */
    411          /*--------------------------------------------------------------------------------------------------------------------*/
    412          
    413          /*----------------------------------------------------------------------------------------------------------------------
    414          Function: AddNewMessageStatus()
    415          
    416          Description:
    417          Adds a new mesage into the status queue.  Due to the tendancy of applications to forget that they wrote
    418          a message here, this buffer is circular and will overwite the oldest message if it needs space for a 
    419          new message.
    420          
    421          Requires:
    422            - u32Token_ is the message of interest
    423          
    424          Promises:
    425            - A new status is created indexed by u32Token_
    426          */

   \                                 In section .text, align 2, keep-with-next
    427          static void AddNewMessageStatus(u32 u32Token_)
    428          {
    429            /* Install the new message message */
    430            Msg_pNextStatus->u32Token = u32Token_;
   \                     AddNewMessageStatus: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable8_7
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x6008             STR      R0,[R1, #+0]
    431            Msg_pNextStatus->eState = WAITING;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x....             LDR.N    R2,??DataTable8_7
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x7111             STRB     R1,[R2, #+4]
    432            Msg_pNextStatus->u32Timestamp = G_u32SystemTime1ms;
   \   0000000E   0x....             LDR.N    R1,??DataTable8_9
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x....             LDR.N    R2,??DataTable8_7
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x6091             STR      R1,[R2, #+8]
    433            
    434            /* Safely advance the pointer */
    435            Msg_pNextStatus++;
   \   00000018   0x....             LDR.N    R1,??DataTable8_7
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x310C             ADDS     R1,R1,#+12
   \   0000001E   0x....             LDR.N    R2,??DataTable8_7
   \   00000020   0x6011             STR      R1,[R2, #+0]
    436            if(Msg_pNextStatus == &Msg_StatusQueue[STATUS_QUEUE_SIZE])
   \   00000022   0x....             LDR.N    R1,??DataTable8_7
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   \   00000026   0x....             LDR.N    R2,??DataTable8_1
   \   00000028   0x4291             CMP      R1,R2
   \   0000002A   0xD102             BNE.N    ??AddNewMessageStatus_0
    437            {
    438              Msg_pNextStatus = &Msg_StatusQueue[0];
   \   0000002C   0x....             LDR.N    R1,??DataTable8
   \   0000002E   0x....             LDR.N    R2,??DataTable8_7
   \   00000030   0x6011             STR      R1,[R2, #+0]
    439            }
    440            
    441          } /* end AddNewMessageStatus() */
   \                     ??AddNewMessageStatus_0: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    442          
    443          
    444          /**********************************************************************************************************************
    445          State Machine Function Definitions
    446          **********************************************************************************************************************/
    447          
    448          /*-------------------------------------------------------------------------------------------------------------------*/
    449          /* Do nothing for now */

   \                                 In section .text, align 4, keep-with-next
    450          void MessagingIdle(void)
    451          {
    452            static u32 u32CleaningTime = MSG_STATUS_CLEANING_TIME;
    453            
    454            /* Periodically check for stale messages */
    455            if(--u32CleaningTime == 0)
   \                     MessagingIdle: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable8_10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1E40             SUBS     R0,R0,#+1
   \   00000006   0x....             LDR.N    R1,??DataTable8_10
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable8_10
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE.N    ??MessagingIdle_0
    456            {
    457              u32CleaningTime = MSG_STATUS_CLEANING_TIME;
   \   00000012   0xF44F 0x707A      MOV      R0,#+1000
   \   00000016   0x....             LDR.N    R1,??DataTable8_10
   \   00000018   0x6008             STR      R0,[R1, #+0]
    458              
    459              /* ??? Probably should add clean of the main message queue to detect any messages that have become stuck */
    460            }
    461              
    462          } /* end MessagingIdle() */
   \                     ??MessagingIdle_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .data, align 4
   \                     ??u32CleaningTime:
   \   00000000   0x000003E8         DC32 1000
    463          
    464          
    465          /*-------------------------------------------------------------------------------------------------------------------*/
    466          /* Handle an error */

   \                                 In section .text, align 2, keep-with-next
    467          void MessagingError(void)          
    468          {
    469            Messaging_pfnStateMachine = MessagingIdle;
   \                     MessagingError: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable8_11
   \   00000002   0x....             LDR.N    R1,??DataTable8_8
   \   00000004   0x6008             STR      R0,[R1, #+0]
    470            
    471          } /* end MessagingError() */
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     Msg_StatusQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     Msg_StatusQueue+0x300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     Msg_u8QueuedMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     G_u32MessagingFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     Msg_Pool

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     Msg_u32Token

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     Msg_Pool+0x900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     Msg_pNextStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     Messaging_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     ??u32CleaningTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     MessagingIdle
    472          
    473          
    474          
    475          /*--------------------------------------------------------------------------------------------------------------------*/
    476          /* End of File */
    477          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AddNewMessageStatus
       0   DeQueueMessage
       0   MessagingError
       0   MessagingIdle
       0   MessagingInitialize
       8   MessagingRunActiveState
         8   -- Indirect call
       0   QueryMessageStatus
      40   QueueMessage
        40   -> AddNewMessageStatus
       0   UpdateMessageStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      52  AddNewMessageStatus
      86  DeQueueMessage
       4  G_u32MessagingFlags
       8  MessagingError
      28  MessagingIdle
     114  MessagingInitialize
      10  MessagingRunActiveState
       4  Messaging_pfnStateMachine
    2304  Msg_Pool
     768  Msg_StatusQueue
       4  Msg_pNextStatus
       4  Msg_u32Token
       1  Msg_u8QueuedMessageCount
      56  QueryMessageStatus
     226  QueueMessage
      28  UpdateMessageStatus
       4  u32CleaningTime

 
 3 089 bytes in section .bss
     4 bytes in section .data
   656 bytes in section .text
 
   656 bytes of CODE memory
 3 093 bytes of DATA memory

Errors: none
Warnings: none
