###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        14/Oct/2015  14:35:22
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\drivers\sdcard.c
#    Command line =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\drivers\sdcard.c
#        --preprocess=cl
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\bsp\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline -I "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\sdcard.lst
#    Object file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\sdcard.o
#
###############################################################################

D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\drivers\sdcard.c
      1          /**********************************************************************************************************************
      2          File: sdcard.c                                                                
      3          
      4          Description:
      5          SD card interface application.  This task looks for an SD card and initializes it so it is ready
      6          to receive data read / write commands.  
      7          
      8          API
      9          Client applications may use the following functions to access this driver:
     10          
     11          SdGetStatus() - returns a variable of type SdCardStateType which may have the following value:
     12            SD_NO_CARD: no card is inserted.
     13            SD_CARD_ERROR: an inserted card has an error.
     14            SD_IDLE: card is ready and waiting for a read or a write to be requested.
     15            SD_READING: the card is being read and is not available for anything else 
     16            SD_DATA_READY: a sector of data has been requested from the SD card is ready for the client.
     17            SD_WRITING: the card is being written and is not available for anything else
     18          
     19          bool SdReadBlock(u32 u32SectorAddress_) - initiates read of one 512 byte block of memory from the SD card.
     20          Returns TRUE if the card is available and can start reading. 
     21          User must use SdGetStatus() and wait until the card status is SD_DATA_READY which means the read is done.
     22          
     23          bool SdWriteBlock(u32 u32BlockAddress_) - not yet implemented
     24          
     25          bool SdGetReadData(u8* pu8Destination_) - transfers the read data to the client.  The card state will return to SD_IDLE.
     26          
     27          
     28          **********************************************************************************************************************/
     29          
     30          #include "configuration.h"
     31          
     32          /***********************************************************************************************************************
     33          Global variable definitions with scope across entire project.
     34          All Global variable names shall start with "G_"
     35          ***********************************************************************************************************************/
     36          /* New variables */

   \                                 In section .bss, align 4
     37          volatile u32 G_u32SdCardFlags;                         /* Global state flags */
   \                     G_u32SdCardFlags:
   \   00000000                      DS8 4
     38          
     39          
     40          /*--------------------------------------------------------------------------------------------------------------------*/
     41          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     42          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     43          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     44          
     45          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     46          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     47          
     48          
     49          /***********************************************************************************************************************
     50          Global variable definitions with scope limited to this local application.
     51          Variable names shall start with "SD_" and be declared as static.
     52          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     53          static fnCode_type SD_pfnStateMachine;             /* The Debug state machine function pointer */
   \                     SD_pfnStateMachine:
   \   00000000                      DS8 4
     54          

   \                                 In section .bss, align 4
     55          static u32 SD_u32Flags;                            /* Application flags for SD card */
   \                     SD_u32Flags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     56          static SdCardStateType SD_CardState;               /* Card state variable */
   \                     SD_CardState:
   \   00000000                      DS8 1
     57          

   \                                 In section .bss, align 1
     58          static u8  SD_u8ErrorCode;                         /* Error code */
   \                     SD_u8ErrorCode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     59          static fnCode_type SD_WaitReturnState;             /* The saved state to return after a wait period */
   \                     SD_WaitReturnState:
   \   00000000                      DS8 4
     60          static u8* SD_NextCommand;                         /* Saved command to be executed next */
     61          
     62          //static LedSetType SD_CardStatusLed;                /* LED to show card insert detected */
     63          

   \                                 In section .bss, align 4
     64          static SspConfigurationType SD_sSspConfig;        /* Configuration information for SSP peripheral */
   \                     SD_sSspConfig:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
     65          static SspPeripheralType* SD_Ssp;                  /* Pointer to SSP peripheral object */
   \                     SD_Ssp:
   \   00000000                      DS8 4
     66          

   \                                 In section .bss, align 4
     67          static u8 SD_au8RxBuffer[SDCARD_RX_BUFFER_SIZE];   /* Space for incoming bytes from the SD card */
   \                     SD_au8RxBuffer:
   \   00000000                      DS8 548

   \                                 In section .bss, align 4
     68          static u8 *SD_pu8RxBufferNextByte;                 /* Pointer to next spot in RxBuffer to write a byte */
   \                     SD_pu8RxBufferNextByte:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     69          static u8 *SD_pu8RxBufferParser;                   /* Pointer to loop through the Rx buffer to read bytes */
   \                     SD_pu8RxBufferParser:
   \   00000000                      DS8 4
     70          

   \                                 In section .bss, align 4
     71          static u32 SD_u32Timeout;                          /* Timeout counter used across states */
   \                     SD_u32Timeout:
   \   00000000                      DS8 4
     72          static u32 SD_u32CurrentMsgToken;                  /* Token of message currently being sent */

   \                                 In section .bss, align 4
     73          static u32 SD_u32Address;                          /* Current read/write sector address */
   \                     SD_u32Address:
   \   00000000                      DS8 4
     74          
     75          static u8 SD_au8SspRequestFailed[] = "SdCard denied SSP\n\r";
     76          static u8 SD_au8CardReady[]        = "SD ready\n\r";

   \                                 In section .data, align 4
     77          static u8 SD_au8CardError[]        = "SD error: ";
   \                     SD_au8CardError:
   \   00000000   0x53 0x44          DC8 "SD error: "
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .data, align 4
     78          static u8 SD_au8CardError0[]       = "UNKNOWN\n\r";
   \                     SD_au8CardError0:
   \   00000000   0x55 0x4E          DC8 "UNKNOWN\012\015"
   \              0x4B 0x4E    
   \              0x4F 0x57    
   \              0x4E 0x0A    
   \              0x0D 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     79          static u8 SD_au8CardError1[]       = "TIMEOUT\n\r";
   \                     SD_au8CardError1:
   \   00000000   0x54 0x49          DC8 "TIMEOUT\012\015"
   \              0x4D 0x45    
   \              0x4F 0x55    
   \              0x54 0x0A    
   \              0x0D 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     80          static u8 SD_au8CardError2[]       = "CARD_VOLTAGE\n\r ";
   \                     SD_au8CardError2:
   \   00000000   0x43 0x41          DC8 "CARD_VOLTAGE\012\015 "
   \              0x52 0x44    
   \              0x5F 0x56    
   \              0x4F 0x4C    
   \              0x54 0x41    
   \              0x47 0x45    
   \              0x0A 0x0D    
   \              0x20 0x00    

   \                                 In section .data, align 4
     81          static u8 SD_au8CardError3[]       = "BAD_RESPONSE\n\r ";
   \                     SD_au8CardError3:
   \   00000000   0x42 0x41          DC8 "BAD_RESPONSE\012\015 "
   \              0x44 0x5F    
   \              0x52 0x45    
   \              0x53 0x50    
   \              0x4F 0x4E    
   \              0x53 0x45    
   \              0x0A 0x0D    
   \              0x20 0x00    

   \                                 In section .data, align 4
     82          static u8 SD_au8CardError4[]       = "NO_TOKEN\n\r";
   \                     SD_au8CardError4:
   \   00000000   0x4E 0x4F          DC8 "NO_TOKEN\012\015"
   \              0x5F 0x54    
   \              0x4F 0x4B    
   \              0x45 0x4E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .data, align 4
     83          static u8 SD_au8CardError5[]       = "NO_SD_TOKEN\n\r";
   \                     SD_au8CardError5:
   \   00000000   0x4E 0x4F          DC8 "NO_SD_TOKEN\012\015"
   \              0x5F 0x53    
   \              0x44 0x5F    
   \              0x54 0x4F    
   \              0x4B 0x45    
   \              0x4E 0x0A    
   \              0x0D 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0
     84          
     85          
     86          static u8 SD_au8CMD0[]   = {SD_HOST_CMD | SD_CMD0,  0, 0, 0, 0, SD_CMD0_CRC, SSP_DUMMY_BYTE};
     87          static u8 SD_au8CMD8[]   = {SD_HOST_CMD | SD_CMD8,  0, 0, SD_VHS_VALUE, SD_CHECK_PATTERN, SD_CMD8_CRC, SSP_DUMMY_BYTE};
     88          static u8 SD_au8CMD16[]   ={SD_HOST_CMD | SD_CMD16, 0, 0, 0x02, 0x00, SD_NO_CRC, SSP_DUMMY_BYTE};
     89          static u8 SD_au8CMD17[]   ={SD_HOST_CMD | SD_CMD17, 0, 0, 0, 0, SD_NO_CRC, SSP_DUMMY_BYTE};
     90          static u8 SD_au8CMD55[]  = {SD_HOST_CMD | SD_CMD55, 0, 0, 0 ,0, SD_NO_CRC, SSP_DUMMY_BYTE};
     91          static u8 SD_au8CMD58[]  = {SD_HOST_CMD | SD_CMD58, 0, 0, 0 ,0, SD_NO_CRC, SSP_DUMMY_BYTE};
     92          
     93          static u8 SD_au8ACMD41[] = {SD_HOST_CMD | SD_ACMD41,0, 0, 0, 0, SD_NO_CRC, SSP_DUMMY_BYTE};
     94          
     95          
     96          /**********************************************************************************************************************
     97          Function Definitions
     98          **********************************************************************************************************************/
     99          
    100          /*--------------------------------------------------------------------------------------------------------------------*/
    101          /* Public Functions */
    102          /*--------------------------------------------------------------------------------------------------------------------*/
    103          
    104          /*----------------------------------------------------------------------------------------------------------------------
    105          Function: SdIsCardInserted
    106          
    107          Description:
    108          Indicates whether or not an SD card is currently inserted.
    109          
    110          Requires:
    111            - 
    112          
    113          Promises:
    114            - Returns TRUE if card is inserted and SD_CardStatusLed is requested; otherwise returns FALSE and
    115              SD_CardStatusLed is released
    116            - _SD_CARD_INSERTED is updated (set if card is in)
    117          */

   \                                 In section .text, align 2, keep-with-next
    118          bool SdIsCardInserted(void)
    119          {
    120            if( !SD_DETECT() )
   \                     SdIsCardInserted: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9  ;; 0x400e0c3c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0740             LSLS     R0,R0,#+29
   \   00000006   0xD40A             BMI.N    ??SdIsCardInserted_0
    121            {
    122              SD_u32Flags &= ~_SD_CARD_INSERTED;
   \   00000008   0x....             LDR.N    R0,??DataTable9_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0840             LSRS     R0,R0,#+1
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x....             LDR.N    R1,??DataTable9_1
   \   00000012   0x6008             STR      R0,[R1, #+0]
    123              SD_CardState = SD_NO_CARD;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable9_2
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    124              return FALSE;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE006             B.N      ??SdIsCardInserted_1
    125            }
    126            else
    127            {
    128              SD_u32Flags |= _SD_CARD_INSERTED;
   \                     ??SdIsCardInserted_0: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable9_1
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000026   0x....             LDR.N    R1,??DataTable9_1
   \   00000028   0x6008             STR      R0,[R1, #+0]
    129              return TRUE;
   \   0000002A   0x2001             MOVS     R0,#+1
   \                     ??SdIsCardInserted_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
    130            }
    131            
    132          } /* end SdIsCardInserted() */
    133          
    134          
    135          /*----------------------------------------------------------------------------------------------------------------------
    136          Function: SdGetStatus
    137          
    138          Description:
    139          Reports the current status of the SD card.
    140          
    141          SD_NO_CARD: no card is inserted.
    142          SD_CARD_ERROR: an inserted card has an error.
    143          SD_IDLE: card is ready and waiting for a read or a write to be requested.
    144          SD_READING: the card is being read and is not available for anything else 
    145          SD_DATA_READY: a sector of data has been requested from the SD card is ready for the client.
    146          SD_WRITING: the card is being written and is not available for anything else
    147          
    148          Requires:
    149            - SD_CardState up to date.
    150          
    151          Promises:
    152            - Returns SD_CardState
    153          */

   \                                 In section .text, align 2, keep-with-next
    154          SdCardStateType SdGetStatus(void)
    155          {
    156            return SD_CardState;
   \                     SdGetStatus: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    157            
    158          } /* end SdGetStatus() */
    159          
    160          
    161          /*----------------------------------------------------------------------------------------------------------------------
    162          Function: SdReadBlock
    163          
    164          Description:
    165          Reads a block at the sector address provided.
    166          Byte-addressable cards are automatically converted appropriately so user does not have to distinguish
    167          and can always read by 512 byte block.
    168          
    169          Requires:
    170            - _SD_TYPE_SD1, _SD_TYPE_SD2, _SD_CARD_HC are correctly set/clear to indicate card type.
    171            - u32SectorAddress_ is a valid SD card address
    172          
    173          Promises:
    174            - If the card is currently SD_IDLE, initiates the read, changes card state to "SD_READING" and returns TRUE.
    175          */

   \                                 In section .text, align 2, keep-with-next
    176          bool SdReadBlock(u32 u32SectorAddress_)
    177          {
   \                     SdReadBlock: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    178            if(SD_CardState == SD_IDLE)
   \   00000002   0x....             LDR.N    R0,??DataTable9_2
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD111             BNE.N    ??SdReadBlock_0
    179            {
    180              /* Capture the card address of interest with adjustment for byte-accessed cards as required */
    181              SD_u32Address = u32SectorAddress_;
   \   0000000A   0x....             LDR.N    R0,??DataTable9_3
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    182              if( !(SD_u32Flags & _SD_CARD_HC) )
   \   0000000E   0x....             LDR.N    R0,??DataTable9_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x0740             LSLS     R0,R0,#+29
   \   00000014   0xD406             BMI.N    ??SdReadBlock_1
    183              {
    184                SD_u32Address *= 512;
   \   00000016   0x....             LDR.N    R0,??DataTable9_3
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF44F 0x7200      MOV      R2,#+512
   \   0000001E   0x4350             MULS     R0,R2,R0
   \   00000020   0x....             LDR.N    R2,??DataTable9_3
   \   00000022   0x6010             STR      R0,[R2, #+0]
    185              }
    186              
    187              /* Update the card state which will trigger the start of the read sequence */
    188              SD_CardState = SD_READING;
   \                     ??SdReadBlock_1: (+1)
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x....             LDR.N    R2,??DataTable9_2
   \   00000028   0x7010             STRB     R0,[R2, #+0]
    189              return TRUE;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE000             B.N      ??SdReadBlock_2
    190            }
    191            
    192            return FALSE;
   \                     ??SdReadBlock_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??SdReadBlock_2: (+1)
   \   00000030   0x4770             BX       LR               ;; return
    193            
    194          } /* end SdReadBlock() */
    195          
    196          
    197          /*----------------------------------------------------------------------------------------------------------------------
    198          Function: SdWriteBlock
    199          
    200          Description:
    201          Writes a block at the address provided.
    202          
    203          Requires:
    204            - 
    205          
    206          Promises:
    207            - 
    208          */

   \                                 In section .text, align 2, keep-with-next
    209          bool SdWriteBlock(u32 u32BlockAddress_)
    210          {
   \                     SdWriteBlock: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    211            return FALSE;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    212              
    213          } /* end SdWriteBlock() */
    214          
    215          
    216          /*----------------------------------------------------------------------------------------------------------------------
    217          Function: SdGetReadData
    218          
    219          Description:
    220          Transfers the data that was just read from the card.
    221          
    222          Requires:
    223            - pu8Destination points to the start of a 512 byte buffer where the data will be read.
    224            - The 512 bytes of data that was just read is at SD_au8RxBuffer[0] thru SD_au8RxBuffer[511] -
    225              this will set SD_CardState to SD_DATA_READY.
    226          
    227          Promises:
    228            - if SD_CardState = SD_DATA_READY, loads 512 bytes to pu8Destination_ and returns TRUE
    229            - else returns FALSE
    230          */

   \                                 In section .text, align 2, keep-with-next
    231          bool SdGetReadData(u8* pu8Destination_)
    232          {
   \                     SdGetReadData: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    233            /* To ensure data integrity, card state must be SD_DATA_READY */
    234            if(SD_CardState == SD_DATA_READY)
   \   00000002   0x....             LDR.N    R0,??DataTable9_2
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2804             CMP      R0,#+4
   \   00000008   0xD110             BNE.N    ??SdGetReadData_0
    235            {
    236              SD_CardState = SD_IDLE;
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x....             LDR.N    R2,??DataTable9_2
   \   0000000E   0x7010             STRB     R0,[R2, #+0]
    237          
    238              for(u16 i = 0; i < 512; i++)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??SdGetReadData_1: (+1)
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000018   0xDA06             BGE.N    ??SdGetReadData_2
    239              {
    240                *pu8Destination_ = SD_au8RxBuffer[i];
   \   0000001A   0x....             LDR.N    R2,??DataTable9_4
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x5C82             LDRB     R2,[R0, R2]
   \   00000020   0x700A             STRB     R2,[R1, #+0]
    241                pu8Destination_++;
   \   00000022   0x1C49             ADDS     R1,R1,#+1
    242              }
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0xE7F4             B.N      ??SdGetReadData_1
    243              
    244              return TRUE;
   \                     ??SdGetReadData_2: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE000             B.N      ??SdGetReadData_3
    245            }
    246            /* Otherwise return FALSE */
    247            else
    248            {
    249              return FALSE;
   \                     ??SdGetReadData_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??SdGetReadData_3: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    250            }
    251              
    252          } /* end SdGetReadData() */
    253          
    254          
    255          /*--------------------------------------------------------------------------------------------------------------------*/
    256          /* Protected Functions */
    257          /*--------------------------------------------------------------------------------------------------------------------*/
    258          
    259          /*--------------------------------------------------------------------------------------------------------------------
    260          Function: SdCardInitialize
    261          
    262          Description:
    263          Initializes the State Machine and its variables.
    264          
    265          Requires:
    266            -
    267          
    268          Promises:
    269            - 
    270          */

   \                                 In section .text, align 2, keep-with-next
    271          void SdCardInitialize(void)
    272          {
   \                     SdCardInitialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    273            u8 au8SdCardStarted[] = "SdCard task disabled\n\r";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable9_5
   \   00000008   0x2217             MOVS     R2,#+23
   \   0000000A   0x.... 0x....      BL       __aeabi_memcpy
    274          //  u8 au8SdCardStarted[] = "SdCard task initialized\n\r";
    275          
    276            /* Clear the receive buffer */
    277            for (u16 i = 0; i < SDCARD_RX_BUFFER_SIZE; i++)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??SdCardInitialize_0: (+1)
   \   00000010   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0xF5B0 0x7F09      CMP      R0,#+548
   \   00000016   0xD205             BCS.N    ??SdCardInitialize_1
    278            {
    279              SD_au8RxBuffer[i] = 0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x....             LDR.N    R2,??DataTable9_4
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x5481             STRB     R1,[R0, R2]
    280            }
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE7F5             B.N      ??SdCardInitialize_0
    281          
    282            /* Initailze startup values and the command array */
    283            SD_pu8RxBufferNextByte = &SD_au8RxBuffer[0];
   \                     ??SdCardInitialize_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable9_4
   \   00000026   0x....             LDR.N    R1,??DataTable9_6
   \   00000028   0x6008             STR      R0,[R1, #+0]
    284            SD_pu8RxBufferParser   = &SD_au8RxBuffer[0];
   \   0000002A   0x....             LDR.N    R0,??DataTable9_4
   \   0000002C   0x....             LDR.N    R1,??DataTable9_7
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    285          
    286            /* Configure the SSP resource to be used for the SD Card application */
    287            SD_sSspConfig.SspPeripheral      = SD_SSP;
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x....             LDR.N    R1,??DataTable9_8
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    288            SD_sSspConfig.pCsGpioAddress     = SD_BASE_PORT;
   \   00000036   0x....             LDR.N    R0,??DataTable9_9  ;; 0x400e0c00
   \   00000038   0x....             LDR.N    R1,??DataTable9_8
   \   0000003A   0x6048             STR      R0,[R1, #+4]
    289            SD_sSspConfig.u32CsPin           = SD_CS_PIN;
   \   0000003C   0xF44F 0x7080      MOV      R0,#+256
   \   00000040   0x....             LDR.N    R1,??DataTable9_8
   \   00000042   0x6088             STR      R0,[R1, #+8]
    290            SD_sSspConfig.pu8RxBufferAddress = SD_au8RxBuffer;
   \   00000044   0x....             LDR.N    R0,??DataTable9_4
   \   00000046   0x....             LDR.N    R1,??DataTable9_8
   \   00000048   0x6188             STR      R0,[R1, #+24]
    291            SD_sSspConfig.ppu8RxNextByte     = &SD_pu8RxBufferNextByte;
   \   0000004A   0x....             LDR.N    R0,??DataTable9_6
   \   0000004C   0x....             LDR.N    R1,??DataTable9_8
   \   0000004E   0x61C8             STR      R0,[R1, #+28]
    292            SD_sSspConfig.u16RxBufferSize    = SDCARD_RX_BUFFER_SIZE;
   \   00000050   0xF44F 0x7009      MOV      R0,#+548
   \   00000054   0x....             LDR.N    R1,??DataTable9_8
   \   00000056   0x8408             STRH     R0,[R1, #+32]
    293            SD_sSspConfig.BitOrder           = MSB_FIRST;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x....             LDR.N    R1,??DataTable9_8
   \   0000005C   0x7308             STRB     R0,[R1, #+12]
    294            SD_sSspConfig.SpiMode            = SPI_MASTER;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x....             LDR.N    R1,??DataTable9_8
   \   00000062   0x7348             STRB     R0,[R1, #+13]
    295          
    296            SD_Ssp = SspRequest(&SD_sSspConfig);
   \   00000064   0x....             LDR.N    R0,??DataTable9_8
   \   00000066   0x.... 0x....      BL       SspRequest
   \   0000006A   0x....             LDR.N    R1,??DataTable9_10
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    297          
    298            /* Initialize the LED used by the SD card */
    299          #if 0
    300            SD_CardStatusLed.u32Led       = LED_YLW;
    301            SD_CardStatusLed.eRequesterID = LED_REQUESTER_SDCARD;
    302            SD_CardStatusLed.eBlinkRate   = LED_OFF;
    303            LedRequest(&SD_CardStatusLed);
    304          #endif
    305            
    306            /* Power on and advance to Idle */
    307          //SD_POWER_ON();
    308            SD_pfnStateMachine = SdIdleNoCard;
   \   0000006E   0x.... 0x....      ADR.W    R0,SdIdleNoCard
   \   00000072   0x....             LDR.N    R1,??DataTable9_11
   \   00000074   0x6008             STR      R0,[R1, #+0]
    309            DebugPrintf(au8SdCardStarted);
   \   00000076   0xA800             ADD      R0,SP,#+0
   \   00000078   0x.... 0x....      BL       DebugPrintf
    310            G_u32ApplicationFlags |= _APPLICATION_FLAGS_SDCARD;
   \   0000007C   0x....             LDR.N    R0,??DataTable9_12
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000084   0x....             LDR.N    R1,??DataTable9_12
   \   00000086   0x6008             STR      R0,[R1, #+0]
    311          
    312          } /* end SdCardInitialize() */
   \   00000088   0xB007             ADD      SP,SP,#+28
   \   0000008A   0xBD00             POP      {PC}             ;; return
    313          
    314          
    315          /*----------------------------------------------------------------------------------------------------------------------
    316          Function SdCardRunActiveState()
    317          
    318          Description:
    319          Selects and runs one iteration of the current state in the state machine.
    320          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    321          may take 1ms / n to execute.
    322          
    323          Requires:
    324            - State machine function pointer points at current state
    325          
    326          Promises:
    327            - Calls the function to pointed by the state machine function pointer
    328          */

   \                                 In section .text, align 2, keep-with-next
    329          void SdCardRunActiveState(void)
    330          {
   \                     SdCardRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    331            SD_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable9_11
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    332          
    333          } /* end SdCardRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    334          
    335          
    336          /*--------------------------------------------------------------------------------------------------------------------*/
    337          /* Private functions */
    338          /*--------------------------------------------------------------------------------------------------------------------*/
    339          
    340          /*--------------------------------------------------------------------------------------------------------------------
    341          Function: SdCommand
    342          
    343          Description:
    344          Queues a command and sets up the application to read the response when it arrives.
    345          
    346          Requires:
    347            - No other commands should be queued for the SSP peripheral being used.
    348            - All commands have the same size, SD_CMD_SIZE which include an extra byte which is the first
    349              read back for the response.
    350            - pau8Command_ is a pointer to the first byte of the command byte array
    351          
    352          Promises:
    353            - Requested command is queued
    354            - SD_u32CurrentMsgToken updated with the corresponding message token
    355            - SD_pu8RxBufferParser is positioned to point to where the response byte from the command will be once the
    356              commmand has been sent from by SSP task (a bit dangerous...)
    357            - SD_u32Timeout loaded to start counting the timeout period for the command
    358            - State machine set to wait command
    359          */
    360          void SdCommand(u8* pau8Command_)
    361          {
    362            /* Save the desired command */
    363            SD_NextCommand = pau8Command_;
    364          #if 0  
    365            /* DeAssert the chip select line and queue a dummy read to query the card */
    366            SspDeAssertCS(SD_Ssp);
    367            SD_u32Timeout = G_u32SystemTime1ms;
    368            SD_u32CurrentMsgToken = SspReadByte(SD_Ssp);
    369            if(SD_u32CurrentMsgToken)
    370            {
    371              SD_pfnStateMachine = SdCardWaitReady;
    372              
    373              /* Assert CS to start the command process */
    374              SspAssertCS(SD_Ssp);
    375            }
    376            else
    377            {
    378              /* We didn't get a return token, so abort */
    379              SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
    380              SD_pfnStateMachine = SdError;
    381            }
    382          #endif
    383            
    384          } /* end SdCommand() */
    385          
    386          
    387          /*--------------------------------------------------------------------------------------------------------------------
    388          Function: CheckTimeout
    389          
    390          Description:
    391          Checks on timeout and updates the state machine if required.
    392          
    393          Requires:
    394            - State machine is running through states where timeouts are frequently checked and where the result of
    395              a timeout should be a timeout error and redirection to the error state.
    396            - u32Time_ is ms count for timeout
    397            - SD_u32Timeout is the reference time
    398          
    399          Promises:
    400            - if the timeout has occured, sets the erorr code and directs the SM to SdError state
    401          */

   \                                 In section .text, align 2, keep-with-next
    402          void CheckTimeout(u32 u32Time_)
    403          {
   \                     CheckTimeout: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    404            if( IsTimeUp(&SD_u32Timeout, u32Time_) )
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0x....             LDR.N    R0,??DataTable9_13
   \   00000008   0x.... 0x....      BL       IsTimeUp
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD006             BEQ.N    ??CheckTimeout_0
    405            {
    406              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable9_14
   \   00000014   0x7008             STRB     R0,[R1, #+0]
    407              SD_pfnStateMachine = SdError;
   \   00000016   0x.... 0x....      ADR.W    R0,SdError
   \   0000001A   0x....             LDR.N    R1,??DataTable9_11
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    408            }
    409          
    410          } /* end CheckTimeout() */
   \                     ??CheckTimeout_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    411          
    412          
    413          /*--------------------------------------------------------------------------------------------------------------------
    414          Function: AdvanceSD_pu8RxBufferParser
    415          
    416          Description:
    417          Safely advances SD_pu8RxBufferParser by the number of bytes required.
    418          
    419          Requires:
    420            - u32NumBytes_ is the number of bytes that the buffer pointer will be advanced
    421          
    422          Promises:
    423            - SD_pu8RxBufferParser moved u32NumBytes_ with wrap-around protection.
    424          */
    425          void AdvanceSD_pu8RxBufferParser(u32 u32NumBytes_)
    426          {
    427            for(u32 i = 0; i < u32NumBytes_; i++)
    428            {
    429              SD_pu8RxBufferParser++;
    430              if(SD_pu8RxBufferParser == &SD_au8RxBuffer[SDCARD_RX_BUFFER_SIZE])
    431              {
    432                SD_pu8RxBufferParser = &SD_au8RxBuffer[0];
    433              }
    434            }
    435            
    436          } /* end AdvanceSD_pu8RxBufferParser() */
    437          
    438          
    439          /*--------------------------------------------------------------------------------------------------------------------
    440          Function: FlushSdRxBuffer
    441          
    442          Description:
    443          Skips all new bytes currently in the RxBuffer.
    444          
    445          Requires:
    446            - 
    447          
    448          Promises:
    449            - SD_pu8RxBufferParser set to SD_pu8RxBufferNextByte
    450          */

   \                                 In section .text, align 2, keep-with-next
    451          void FlushSdRxBuffer(void)
    452          {
    453            SD_pu8RxBufferParser = SD_pu8RxBufferNextByte;
   \                     FlushSdRxBuffer: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_6
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R1,??DataTable9_7
   \   00000006   0x6008             STR      R0,[R1, #+0]
    454            
    455          } /* end FlushSdRxBuffer() */
   \   00000008   0x4770             BX       LR               ;; return
    456          
    457          
    458          /**********************************************************************************************************************
    459          State Machine Function Definitions
    460          **********************************************************************************************************************/
    461          
    462          /*-------------------------------------------------------------------------------------------------------------------*/
    463          /* Wait for a card to be inserted */

   \                                 In section .text, align 4, keep-with-next
    464          static void SdIdleNoCard(void)
    465          {
    466          #if 0
    467            if( SdIsCardInserted() )
    468            {
    469              /* Request the SSP resource to talk to the card */
    470              SD_Ssp = SspRequest(&SD_sSspConfig);
    471              if(SD_Ssp == NULL)
    472              {
    473                /* Go to wait state if SSP is not available */
    474                DebugPrintf(sizeof(SD_au8SspRequestFailed) - 1, &SD_au8SspRequestFailed[0]);
    475                SD_u32Timeout = G_u32SystemTime1ms;
    476                SD_WaitReturnState = SdIdleNoCard;
    477                SD_pfnStateMachine = SdCardWaitSSP;
    478              }
    479              else
    480              {
    481                /* If card is in, set flag and then try to talk to card.  Note that the SSP peripheral will 
    482                be allocated to the SD card for this whole initialization process. */
    483                SD_u32Flags &= SD_CLEAR_CARD_TYPE_BITS;
    484                FlushSdRxBuffer();
    485                
    486                SD_CardStatusLed.eBlinkRate = LED_1HZ;
    487                LedRequest(&SD_CardStatusLed);
    488          
    489                /* Queue up a set of dummy transfers to make sure the card is awake; */
    490                SD_u32CurrentMsgToken = SspReadData(SD_Ssp, SD_WAKEUP_BYTES);
    491                if(SD_u32CurrentMsgToken)
    492                {
    493                  SspAssertCS(SD_Ssp);
    494                  SD_pfnStateMachine = SdCardDummies;
    495                }
    496                else
    497                {
    498                  /* We didn't get a return token, so abort */
    499                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
    500                  SD_pfnStateMachine = SdError;
    501                }
    502              }
    503            }  
    504          #endif
    505            
    506          } /* end SdIdleNoCard() */
   \                     SdIdleNoCard: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    507          
    508          
    509          /*-------------------------------------------------------------------------------------------------------------------*/
    510          /* Send dummies to wake up card */
    511          static void SdCardDummies(void)
    512          {
    513            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    514            { 
    515              /* Advance the buffer parser past the dummy read byte responses since we don't care about them */
    516              AdvanceSD_pu8RxBufferParser(SD_WAKEUP_BYTES);
    517          
    518              /* Queue CMD0 to be sent. The message token from here will be used to  */
    519              SdCommand(&SD_au8CMD0[0]);
    520              SD_WaitReturnState = SdCardResponseCMD0;
    521            }
    522          } /* end SdCardDummies() */
    523          
    524          
    525          /*-------------------------------------------------------------------------------------------------------------------*/
    526          /* Check the response to CMD0. SD_pu8RxBufferParser is pointing to the RxBuffer where a response R1 is sitting */
    527          static void SdCardResponseCMD0(void)
    528          {
    529            /* Process the received byte */
    530            if(*SD_pu8RxBufferParser == SD_STATUS_IDLE)
    531            {
    532              /* Card is in Idle state, so issue CMD8 */
    533              SdCommand(&SD_au8CMD8[0]);
    534              SD_WaitReturnState = SdCardResponseCMD8;
    535            }
    536            else
    537            {
    538              /* Unexpected response, go to error */
    539              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
    540              SD_pfnStateMachine = SdError;
    541            }
    542            
    543            /* In any case, advance the buffer pointer */
    544            AdvanceSD_pu8RxBufferParser(1);
    545                 
    546          } /* end SdCardResponseCMD0() */
    547          
    548          
    549          /*-------------------------------------------------------------------------------------------------------------------*/
    550          /* Queue a read to get the CMD8 data. */
    551          static void SdCardResponseCMD8(void)
    552          {
    553            /* Check the response byte (response R1) */
    554            if(*SD_pu8RxBufferParser == SD_STATUS_IDLE)
    555            {
    556              /* Command is good which means the card is at least SDv2 so we can read 4 more bytes of the CMD8 response */
    557              SD_u32Flags |= _SD_TYPE_SD2;
    558              SD_u32CurrentMsgToken = SspReadData(SD_Ssp, 4);
    559              if(SD_u32CurrentMsgToken)
    560              {
    561                SD_pfnStateMachine = SdCardReadCMD8;
    562              }
    563              else
    564              {
    565                /* We didn't get a return token, so abort */
    566                SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
    567                SD_pfnStateMachine = SdError;
    568              }
    569            }
    570            /* CMD8 not supported => not SDv2 */
    571            else
    572            {
    573              /* The card does not support CMD8 so go directly to ACMD41 */
    574              SdCommand(&SD_au8CMD55[0]);
    575              SD_WaitReturnState = SdCardACMD41;
    576            }
    577              
    578            /* In either case, advance the buffer pointer */
    579            AdvanceSD_pu8RxBufferParser(1);
    580             
    581          } /* end SdCardResponseCMD8() */
    582               
    583          
    584          /*-------------------------------------------------------------------------------------------------------------------*/
    585          /* Wait for a response to CMD8. */
    586          static void SdCardReadCMD8(void)
    587          {
    588            /* Check to see if the SSP peripheral has sent the data request */
    589            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    590            {
    591              /* Process the four response bytes (only the last two matter) */
    592              AdvanceSD_pu8RxBufferParser(2);
    593              if(*SD_pu8RxBufferParser == SD_VHS_VALUE)
    594              {
    595                AdvanceSD_pu8RxBufferParser(1);
    596                if(*SD_pu8RxBufferParser == SD_CHECK_PATTERN)
    597                {
    598                  /* Card supports VCC 2.7 - 3.6V so we're good to go */
    599                  SdCommand(&SD_au8CMD55[0]);
    600                  SD_WaitReturnState = SdCardACMD41;
    601                }
    602                AdvanceSD_pu8RxBufferParser(1);
    603              }
    604              else
    605              {
    606                /* The card does not support the voltage range so is not usable */
    607                SD_u8ErrorCode = SD_ERROR_CARD_VOLTAGE;
    608                SD_pfnStateMachine = SdError;
    609              }
    610            }
    611            
    612            /* Watch for SSP timeout */
    613            CheckTimeout(SD_SPI_WAIT_TIME_MS);
    614               
    615          } /* end SdCardReadCMD8() */
    616          
    617               
    618          /*-------------------------------------------------------------------------------------------------------------------*/
    619          /* Check the response to CMD55. SD_pu8RxBufferParser is pointing to the RxBuffer where a response R1 is sitting */
    620          static void SdCardACMD41(void)
    621          {
    622            /* Process the received byte from CMD55*/
    623            if(*SD_pu8RxBufferParser == SD_STATUS_IDLE)
    624            {
    625              /* Card is ready for ACMD */
    626              if(SD_u32Flags & _SD_TYPE_SD2)
    627              {
    628                SD_au8ACMD41[1] |= BIT6;
    629              }
    630              SdCommand(&SD_au8ACMD41[0]);
    631              SD_WaitReturnState = SdCardResponseACMD41;
    632            }
    633            else
    634            {
    635              /* Unexpected response, go to error */
    636              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
    637              SD_pfnStateMachine = SdError;
    638            }
    639            
    640            /* In any case, advance the buffer pointer */
    641            AdvanceSD_pu8RxBufferParser(1);
    642                 
    643          } /* end SdCardACMD41() */
    644               
    645               
    646          /*-------------------------------------------------------------------------------------------------------------------*/
    647          /* Check the response to ACMD41 which is waiting for the card to NOT be in idle (repeat CMD55 + ACMD41 sequence.
    648          Once the card is ready, can send CMD58.  The next step is different for version 1 and version 2 cards.  MMC will not be supported. */
    649          static void SdCardResponseACMD41(void)
    650          {
    651            /* Process the received byte based on card type */
    652            if(*SD_pu8RxBufferParser == SD_STATUS_READY)
    653            {
    654              /* Card is ready for next command */
    655              if(SD_u32Flags & _SD_TYPE_SD2)
    656              {
    657                /* SDv2 cards use CMD58 */
    658                SdCommand(&SD_au8CMD58[0]);
    659                SD_WaitReturnState = SdCardResponseCMD58;
    660              }
    661              else
    662              {
    663                /* SDv1 card: set flag and block access size */
    664                SD_u32Flags |= _SD_TYPE_SD1;
    665                
    666                /* SDv1 cards are always low capacity, but can have variable block access.   Set to 512 to match SDv2. */
    667                SdCommand(&SD_au8CMD16[0]);
    668                SD_WaitReturnState = SdCardResponseCMD16;
    669              }
    670            }
    671            else 
    672            {
    673              /* Card is not idle yet, so repeat */
    674              SdCommand(&SD_au8CMD55[0]);
    675              SD_WaitReturnState = SdCardACMD41;
    676            }
    677            
    678            /* In any case, advance the buffer pointer */
    679            AdvanceSD_pu8RxBufferParser(1);
    680                 
    681          } /* end SdCardACMD41() */     
    682          
    683          
    684          /*-------------------------------------------------------------------------------------------------------------------*/
    685          /* Queue a read to get the CMD58 data. RxBuffer pointer is on R1 response byte. */
    686          static void SdCardResponseCMD58(void)
    687          {
    688            /* Check the response byte (response R1) */
    689            if(*SD_pu8RxBufferParser == SD_STATUS_READY)
    690            {
    691              /* Command is good so we can read 4 more bytes of the CMD58 response */
    692              SD_u32CurrentMsgToken = SspReadData(SD_Ssp, 4);
    693              if(SD_u32CurrentMsgToken)
    694              {
    695                SD_pfnStateMachine = SdCardReadCMD58;
    696              }
    697              else
    698              {
    699                /* We didn't get a return token, so abort */
    700                SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
    701                SD_pfnStateMachine = SdError;
    702              }
    703            }
    704            else
    705            {
    706              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
    707              SD_pfnStateMachine = SdError;
    708            }
    709              
    710            /* In either case, advance the buffer pointer */
    711            AdvanceSD_pu8RxBufferParser(1);
    712                 
    713          } /* end SdCardResponseCMD8() */
    714               
    715          
    716          /*-------------------------------------------------------------------------------------------------------------------*/
    717          /* Process response to CMD16. */
    718          static void SdCardResponseCMD16(void)
    719          {
    720            /* Check the response byte (response R1) */
    721            if(*SD_pu8RxBufferParser == SD_STATUS_READY)
    722            {
    723              /* Success! Card is ready for read/write operations */
    724              SspDeAssertCS(SD_Ssp);
    725              SspRelease(SD_Ssp);
    726          
    727              SD_CardState = SD_IDLE;
    728              //SD_CardStatusLed.eBlinkRate = LED_ON;
    729              //LedRequest(&SD_CardStatusLed);
    730              DebugPrintf(SD_au8CardReady);
    731          
    732              SD_pfnStateMachine = SdCardReadyIdle;
    733            }
    734            else
    735            {
    736              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
    737              SD_pfnStateMachine = SdError;
    738            }
    739              
    740            /* In either case, advance the buffer pointer */
    741            AdvanceSD_pu8RxBufferParser(1);
    742                 
    743          } /* end SdCardResponseCMD8() */
    744               
    745          
    746          /*-------------------------------------------------------------------------------------------------------------------*/
    747          /* Wait for a data for CMD58. RxBuffer pointer is at first of four response bytes when SSP is complete. */
    748          static void SdCardReadCMD58(void)
    749          {
    750            /* Check to see if the SSP peripheral has sent the command */
    751            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    752            {
    753              /* Determine card capacity */
    754              SD_u32Flags &= ~_SD_CARD_HC;
    755              if(*SD_pu8RxBufferParser & _SD_OCR_CCS_BIT)
    756              {
    757                SD_u32Flags |= _SD_CARD_HC;
    758                
    759                /* Success! Card is ready for read/write operations */
    760                SspDeAssertCS(SD_Ssp);
    761                SspRelease(SD_Ssp);
    762            
    763                SD_CardState = SD_IDLE;
    764                //SD_CardStatusLed.eBlinkRate = LED_ON;
    765                //LedRequest(&SD_CardStatusLed);
    766                DebugPrintf(SD_au8CardReady);
    767              
    768                SD_pfnStateMachine = SdCardReadyIdle;
    769              }
    770              /* For standard capacity, make sure block size is 512 */
    771              else
    772              {
    773                SdCommand(&SD_au8CMD16[0]);
    774                SD_WaitReturnState = SdCardResponseCMD16;
    775              }
    776              
    777              /* Ignore the other 3 response bytes */
    778              AdvanceSD_pu8RxBufferParser(4);
    779            }
    780            
    781            /* Watch for SSP timeout */
    782            CheckTimeout(SD_SPI_WAIT_TIME_MS);
    783               
    784          } /* end SdCardReadCMD58() */
    785                     
    786               
    787          /*-------------------------------------------------------------------------------------------------------------------*/
    788          /* Kill time waiting for the SD card to indicate it is ready after CS.
    789          Each time this function is entered, the RxBufferParser pointer will be pointing to the
    790          response byte. */
    791               
    792          static void SdCardWaitReady(void)
    793          {
    794            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    795            {  
    796              if( *SD_pu8RxBufferParser != 0xFF )
    797              {
    798                SD_u32CurrentMsgToken = SspReadByte(SD_Ssp);
    799                if( !SD_u32CurrentMsgToken )
    800                {
    801                  /* We didn't get a return token, so abort */
    802                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
    803                  SD_pfnStateMachine = SdError;
    804                }
    805          
    806                AdvanceSD_pu8RxBufferParser(1);
    807              }
    808              /* The card is ready for the command */
    809              else
    810              {
    811                SD_u32CurrentMsgToken = SspWriteData(SD_Ssp, SD_CMD_SIZE, SD_NextCommand);
    812                
    813                /* Pre-emptively move RxBufferParser so it will point to command response */
    814                AdvanceSD_pu8RxBufferParser(SD_CMD_SIZE);
    815              
    816                /* Set up time-outs and next state */
    817                SD_u32Timeout = G_u32SystemTime1ms;
    818                SD_pfnStateMachine = SdCardWaitCommand;
    819              }
    820            }
    821            
    822            /* Watch for SSP timeout */
    823            CheckTimeout(SD_SPI_WAIT_TIME_MS);
    824               
    825          } /* end SdCardWaitReady() */
    826          
    827          
    828          /*-------------------------------------------------------------------------------------------------------------------*/
    829          /* Kill time waiting for a command to finish sending; the first byte from all completed commands
    830          is response R1 which has BIT7 clear.
    831               
    832          REQUIRES: RxBufferParser pre-emptively set to be pointing at the last response byte that comes in as a result of the
    833          command being sent. 
    834               
    835          PROMISES: returns with RxBuffer pointer pointing at response byte */
    836               
    837          static void SdCardWaitCommand(void)
    838          {
    839            static u8 u8Retries = SD_CMD_RETRIES;
    840            
    841            /* Check to see if the SSP peripheral has sent the command */
    842            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    843            {
    844              /* If no response but retries left, queue another read */
    845              if( (*SD_pu8RxBufferParser & BIT7) && (u8Retries != 0) )
    846              {
    847                u8Retries--;
    848                
    849                SD_u32CurrentMsgToken = SspReadByte(SD_Ssp);
    850                if( !SD_u32CurrentMsgToken )
    851                {
    852                  /* We didn't get a return token, so abort */
    853                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
    854                  SD_pfnStateMachine = SdError;
    855                }
    856          
    857                AdvanceSD_pu8RxBufferParser(1);
    858              }
    859              else
    860              {
    861                /* Otherwise return now */
    862                u8Retries = SD_CMD_RETRIES;
    863                SD_pfnStateMachine = SD_WaitReturnState;
    864              }
    865            }
    866            
    867            if( IsTimeUp(&SD_u32Timeout, SD_WAIT_TIME) )
    868            {
    869              u8Retries = SD_CMD_RETRIES;
    870              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
    871              SD_pfnStateMachine = SdError;
    872            }
    873               
    874          } /* end SdCardWaitCommand() */
    875          
    876            
    877          /*-------------------------------------------------------------------------------------------------------------------*/
    878          /* Kill time before checking SSP availability again */

   \                                 In section .text, align 2, keep-with-next
    879          static void SdCardWaitSSP(void)          
    880          {
   \                     SdCardWaitSSP: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    881            if( IsTimeUp(&SD_u32Timeout, SD_SPI_WAIT_TIME_MS) )
   \   00000002   0xF44F 0x71FA      MOV      R1,#+500
   \   00000006   0x....             LDR.N    R0,??DataTable9_13
   \   00000008   0x.... 0x....      BL       IsTimeUp
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??SdCardWaitSSP_0
    882            {
    883              /* Make sure error light is off if we exitted through here from SD_Error */
    884              //SD_CardStatusLed.eBlinkRate = LED_OFF;
    885              //LedRequest(&SD_CardStatusLed);
    886              
    887              SD_pfnStateMachine = SD_WaitReturnState;
   \   00000010   0x....             LDR.N    R0,??DataTable9_15
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x....             LDR.N    R1,??DataTable9_11
   \   00000016   0x6008             STR      R0,[R1, #+0]
    888            }
    889            
    890          } /* end SdCardWaitSSP() */
   \                     ??SdCardWaitSSP_0: (+1)
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    891               
    892               
    893          /*-------------------------------------------------------------------------------------------------------------------*/
    894          /* SD card is initialized: wait for action request. */
    895          static void SdCardReadyIdle(void)          
    896          {
    897            /* Check if the card is still in; if not return through WaitSSP to allow some debounce time */
    898            if( !SdIsCardInserted() )
    899            {
    900              /* Make sure all LEDs are off and flags are clear */
    901              //SD_CardStatusLed.eBlinkRate = LED_OFF;
    902              //LedRequest(&SD_CardStatusLed);
    903          
    904              SD_u32Flags &= SD_CLEAR_CARD_TYPE_BITS;
    905              
    906              /* Exit through a wait state for effective debouncing */
    907              SD_u32Timeout = G_u32SystemTime1ms;
    908              SD_WaitReturnState = SdIdleNoCard;
    909              SD_pfnStateMachine = SdCardWaitSSP;
    910            }
    911              
    912            /* Look for a request to read or write file data */
    913            if( (SD_CardState == SD_WRITING) || (SD_CardState == SD_READING) )
    914            {
    915              /* Request the SSP resource to talk to the card */
    916              SD_Ssp = SspRequest(&SD_sSspConfig);
    917              if(SD_Ssp == NULL)
    918              {
    919                /* Go to wait state if SSP is not available */
    920                DebugPrintf(SD_au8SspRequestFailed);
    921                SD_u32Timeout = G_u32SystemTime1ms;
    922                SD_WaitReturnState = SdCardReadyIdle;
    923                SD_pfnStateMachine = SdCardWaitSSP;
    924              }
    925              else
    926              {
    927                /* Got SSP, so start read or write */
    928                if(SD_CardState == SD_WRITING)
    929                {
    930                  /* Not yet implemented */
    931                  SD_pfnStateMachine = SdCardReadyIdle;
    932                  SD_CardState = SD_IDLE;
    933                }
    934                else
    935                {
    936                  /* Parse out the bytes of the address into the command array */
    937                  SD_au8CMD17[1] = (u8)(SD_u32Address >> 24);
    938                  SD_au8CMD17[2] = (u8)(SD_u32Address >> 16);
    939                  SD_au8CMD17[3] = (u8)(SD_u32Address >> 8);
    940                  SD_au8CMD17[4] = (u8)SD_u32Address;
    941                  
    942                  SdCommand(&SD_au8CMD17[0]);
    943                  SD_WaitReturnState = SdCardResponseCMD17;
    944                }
    945              }
    946            }
    947          } /* end SdCardReadyIdle() */
    948               
    949          
    950          /*-------------------------------------------------------------------------------------------------------------------*/
    951          /* Start read sequence */
    952          static void SdCardResponseCMD17(void)
    953          {
    954            /* Check the response byte (response R1) */
    955            if(*SD_pu8RxBufferParser == SD_STATUS_READY)
    956            {
    957              /* Queue a read looking to get TOKEN_START_BLOCK back from the card */
    958              SD_u32CurrentMsgToken = SspReadByte(SD_Ssp);
    959           
    960              SD_u32Timeout = G_u32SystemTime1ms;
    961              SD_pfnStateMachine = SdCardWaitStartToken;
    962            }
    963            else
    964            {
    965              /* Incorrect response from the SD card, so abort */
    966              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
    967              SD_pfnStateMachine = SdFailedDataTransfer;
    968            }
    969          
    970            /* Either way, advance the RxBuffer pointer */  
    971            AdvanceSD_pu8RxBufferParser(1);
    972          
    973          } /* end SdCardResponseCMD17() */
    974          
    975          
    976          /*-------------------------------------------------------------------------------------------------------------------*/
    977          /* Look for the returned token that indicates the read or write process has begun */
    978          static void SdCardWaitStartToken(void)          
    979          {
    980            /* Check if the SSP peripheral has sent the data request */
    981            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    982            {
    983              /* Check the response byte */
    984              if(*SD_pu8RxBufferParser == TOKEN_START_BLOCK)
    985              {
    986                /* Set the RxBuffer pointers to the start of the RxBuffer so the sector data occupies the beginning */
    987                SD_pu8RxBufferNextByte = &SD_au8RxBuffer[0];
    988                SD_pu8RxBufferParser   = &SD_au8RxBuffer[0];
    989                
    990                /* Queue a read for the entire sector plus two checksum bytes */
    991                SD_u32CurrentMsgToken = SspReadData(SD_Ssp, 514);    
    992                SD_pfnStateMachine = SdCardDataTransfer;
    993              }
    994              else
    995              {
    996                /* Queue a read looking to get TOKEN_START_BLOCK back from the card */
    997                SD_u32CurrentMsgToken = SspReadByte(SD_Ssp);    
    998                AdvanceSD_pu8RxBufferParser(1);
    999              }
   1000            }
   1001            
   1002            /* Monitor time */
   1003            if(IsTimeUp(&SD_u32Timeout, SD_READ_TOKEN_MS))
   1004            {
   1005              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   1006              SD_pfnStateMachine = SdFailedDataTransfer;
   1007            }
   1008            
   1009          } /* end SdCardWaitStartToken() */
   1010          
   1011          
   1012          /*-------------------------------------------------------------------------------------------------------------------*/
   1013          /* Read the sector */
   1014          static void SdCardDataTransfer(void)
   1015          {
   1016            /* Check if the SSP peripheral is finished with the data request */
   1017            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
   1018            {
   1019              SD_CardState = SD_DATA_READY;
   1020          
   1021              SspDeAssertCS(SD_Ssp);
   1022              SspRelease(SD_Ssp);
   1023          
   1024              /* Reset the RxBuffer pointers to the start of the RxBuffer */
   1025              SD_pu8RxBufferNextByte = &SD_au8RxBuffer[0];
   1026              SD_pu8RxBufferParser   = &SD_au8RxBuffer[0];
   1027          
   1028              SD_pfnStateMachine = SdCardReadyIdle;
   1029            }
   1030          
   1031            /* Monitor time */
   1032            if(IsTimeUp(&SD_u32Timeout, SD_SECTOR_READ_TIMEOUT_MS))
   1033            {
   1034              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   1035              SD_pfnStateMachine = SdError;
   1036            }
   1037          
   1038          } /* end SdCardDataTransfer() */
   1039          
   1040          
   1041          /*-------------------------------------------------------------------------------------------------------------------*/
   1042          /* Handle a failed data transfer */
   1043          static void SdFailedDataTransfer(void)
   1044          {
   1045            /* Reset the system variables */
   1046            SspDeAssertCS(SD_Ssp);
   1047            SspRelease(SD_Ssp);
   1048            FlushSdRxBuffer();
   1049            SD_CardState = SD_CARD_ERROR;
   1050            
   1051            SD_u32Timeout = G_u32SystemTime1ms;
   1052            SD_pfnStateMachine = SdCardWaitSSP;
   1053            
   1054          } /* end SdFailedDataTransfer() */
   1055          
   1056          
   1057          /*-------------------------------------------------------------------------------------------------------------------*/
   1058          /* Handle an error */

   \                                 In section .text, align 4, keep-with-next
   1059          static void SdError(void)          
   1060          {
   \                     SdError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1061            u8* pu8ErrorMessage;
   1062            u8 u8MessageSize;
                      ^
Warning[Pe550]: variable "u8MessageSize" was set but never used

  static void SdCardDummies(void)
              ^
"D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\drivers\sdcard.c",511  Warning[Pe177]: 
          function "SdCardDummies" was declared but never referenced

  static void SdCardWaitReady(void)
              ^
"D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\drivers\sdcard.c",792  Warning[Pe177]: 
          function "SdCardWaitReady" was declared but never referenced
   1063            
   1064            /* Reset the system variables */
   1065            SspDeAssertCS(SD_Ssp);
   \   00000002   0x....             LDR.N    R0,??DataTable9_10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       SspDeAssertCS
   1066            SspRelease(SD_Ssp);
   \   0000000A   0x....             LDR.N    R0,??DataTable9_10
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       SspRelease
   1067            FlushSdRxBuffer();
   \   00000012   0x.... 0x....      BL       FlushSdRxBuffer
   1068          
   1069            /* Indicate error and return through the SSP delay state to give the system some recovery time */
   1070            //SD_CardStatusLed.eBlinkRate = LED_8HZ;
   1071            //LedRequest(&SD_CardStatusLed);
   1072              
   1073            DebugPrintf(SD_au8CardError);
   \   00000016   0x....             LDR.N    R0,??DataTable9_16
   \   00000018   0x.... 0x....      BL       DebugPrintf
   1074            switch (SD_u8ErrorCode)
   \   0000001C   0x....             LDR.N    R0,??DataTable9_14
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD007             BEQ.N    ??SdError_0
   \   00000024   0xD31F             BCC.N    ??SdError_1
   \   00000026   0x2803             CMP      R0,#+3
   \   00000028   0xD00E             BEQ.N    ??SdError_2
   \   0000002A   0xD308             BCC.N    ??SdError_3
   \   0000002C   0x2805             CMP      R0,#+5
   \   0000002E   0xD015             BEQ.N    ??SdError_4
   \   00000030   0xD30F             BCC.N    ??SdError_5
   \   00000032   0xE018             B.N      ??SdError_1
   1075            {
   1076              case SD_ERROR_TIMEOUT:
   1077              {
   1078                u8MessageSize = sizeof(SD_au8CardError1) - 1;
   \                     ??SdError_0: (+1)
   \   00000034   0x2009             MOVS     R0,#+9
   \   00000036   0x0005             MOVS     R5,R0
   1079                pu8ErrorMessage = SD_au8CardError1;
   \   00000038   0x....             LDR.N    R0,??DataTable9_17
   \   0000003A   0x0004             MOVS     R4,R0
   1080                break;
   \   0000003C   0xE017             B.N      ??SdError_6
   1081              }
   1082              
   1083              case SD_ERROR_CARD_VOLTAGE:
   1084              {
   1085                u8MessageSize = sizeof(SD_au8CardError2) - 1;
   \                     ??SdError_3: (+1)
   \   0000003E   0x200F             MOVS     R0,#+15
   \   00000040   0x0005             MOVS     R5,R0
   1086                pu8ErrorMessage = SD_au8CardError2;
   \   00000042   0x....             LDR.N    R0,??DataTable9_18
   \   00000044   0x0004             MOVS     R4,R0
   1087                break;
   \   00000046   0xE012             B.N      ??SdError_6
   1088              }
   1089          
   1090              case SD_ERROR_BAD_RESPONSE:
   1091              {
   1092                u8MessageSize = sizeof(SD_au8CardError3) - 1;
   \                     ??SdError_2: (+1)
   \   00000048   0x200F             MOVS     R0,#+15
   \   0000004A   0x0005             MOVS     R5,R0
   1093                pu8ErrorMessage = SD_au8CardError3;
   \   0000004C   0x....             LDR.N    R0,??DataTable9_19
   \   0000004E   0x0004             MOVS     R4,R0
   1094                break;
   \   00000050   0xE00D             B.N      ??SdError_6
   1095              }
   1096          
   1097              case SD_ERROR_NO_TOKEN:
   1098              {
   1099                u8MessageSize = sizeof(SD_au8CardError4) - 1;
   \                     ??SdError_5: (+1)
   \   00000052   0x200A             MOVS     R0,#+10
   \   00000054   0x0005             MOVS     R5,R0
   1100                pu8ErrorMessage = SD_au8CardError4;
   \   00000056   0x....             LDR.N    R0,??DataTable9_20
   \   00000058   0x0004             MOVS     R4,R0
   1101                break;
   \   0000005A   0xE008             B.N      ??SdError_6
   1102              }
   1103          
   1104              case SD_ERROR_NO_SD_TOKEN:
   1105              {
   1106                u8MessageSize = sizeof(SD_au8CardError5) - 1;
   \                     ??SdError_4: (+1)
   \   0000005C   0x200D             MOVS     R0,#+13
   \   0000005E   0x0005             MOVS     R5,R0
   1107                pu8ErrorMessage = SD_au8CardError5;
   \   00000060   0x....             LDR.N    R0,??DataTable9_21
   \   00000062   0x0004             MOVS     R4,R0
   1108                break;
   \   00000064   0xE003             B.N      ??SdError_6
   1109              }
   1110              
   1111             default:
   1112             {
   1113              u8MessageSize = sizeof(SD_au8CardError0) - 1;
   \                     ??SdError_1: (+1)
   \   00000066   0x2009             MOVS     R0,#+9
   \   00000068   0x0005             MOVS     R5,R0
   1114              pu8ErrorMessage = SD_au8CardError0;
   \   0000006A   0x....             LDR.N    R0,??DataTable9_22
   \   0000006C   0x0004             MOVS     R4,R0
   1115              break;
   1116            }
   1117             
   1118            } /* end switch */
   1119            
   1120            DebugPrintf(pu8ErrorMessage);
   \                     ??SdError_6: (+1)
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       DebugPrintf
   1121            
   1122            SD_CardState = SD_NO_CARD;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x....             LDR.N    R1,??DataTable9_2
   \   00000078   0x7008             STRB     R0,[R1, #+0]
   1123            SD_u32Timeout = G_u32SystemTime1ms;
   \   0000007A   0x....             LDR.N    R0,??DataTable9_23
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x....             LDR.N    R1,??DataTable9_13
   \   00000080   0x6008             STR      R0,[R1, #+0]
   1124            SD_WaitReturnState = SdIdleNoCard;
   \   00000082   0x....             LDR.N    R0,??DataTable9_24
   \   00000084   0x....             LDR.N    R1,??DataTable9_15
   \   00000086   0x6008             STR      R0,[R1, #+0]
   1125            SD_pfnStateMachine = SdCardWaitSSP;
   \   00000088   0x....             LDR.N    R0,??DataTable9_25
   \   0000008A   0x....             LDR.N    R1,??DataTable9_11
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   1126            
   1127          } /* end SdError() */
   \   0000008E   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x400E0C3C         DC32     0x400e0c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     SD_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     SD_CardState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     SD_u32Address

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     SD_au8RxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     SD_pu8RxBufferNextByte

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     SD_pu8RxBufferParser

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     SD_sSspConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x400E0C00         DC32     0x400e0c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     SD_Ssp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     SD_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     SD_u32Timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     SD_u8ErrorCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     SD_WaitReturnState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x........         DC32     SD_au8CardError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x........         DC32     SD_au8CardError1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x........         DC32     SD_au8CardError2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x........         DC32     SD_au8CardError3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   0x........         DC32     SD_au8CardError4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   0x........         DC32     SD_au8CardError5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   0x........         DC32     SD_au8CardError0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_23:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_24:
   \   00000000   0x........         DC32     SdIdleNoCard

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_25:
   \   00000000   0x........         DC32     SdCardWaitSSP

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x53 0x64          DC8 "SdCard task disabled\012\015"
   \              0x43 0x61    
   \              0x72 0x64    
   \              0x20 0x74    
   \              0x61 0x73    
   \              0x6B 0x20    
   \              0x64 0x69    
   \              0x73 0x61    
   \              0x62 0x6C    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000017   0x00               DC8 0
   1128          
   1129          
   1130          
   1131          /*--------------------------------------------------------------------------------------------------------------------*/
   1132          /* End of File */
   1133          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CheckTimeout
         8   -> IsTimeUp
       0   FlushSdRxBuffer
      32   SdCardInitialize
        32   -> DebugPrintf
        32   -> SspRequest
        32   -> __aeabi_memcpy
       8   SdCardRunActiveState
         8   -- Indirect call
       8   SdCardWaitSSP
         8   -> IsTimeUp
      16   SdError
        16   -> DebugPrintf
        16   -> FlushSdRxBuffer
        16   -> SspDeAssertCS
        16   -> SspRelease
       0   SdGetReadData
       0   SdGetStatus
       0   SdIdleNoCard
       0   SdIsCardInserted
       0   SdReadBlock
       0   SdWriteBlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_24
       4  ??DataTable9_25
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      24  ?_0
      32  CheckTimeout
      10  FlushSdRxBuffer
       4  G_u32SdCardFlags
       1  SD_CardState
       4  SD_Ssp
       4  SD_WaitReturnState
      12  SD_au8CardError
      12  SD_au8CardError0
      12  SD_au8CardError1
      16  SD_au8CardError2
      16  SD_au8CardError3
      12  SD_au8CardError4
      16  SD_au8CardError5
     548  SD_au8RxBuffer
       4  SD_pfnStateMachine
       4  SD_pu8RxBufferNextByte
       4  SD_pu8RxBufferParser
      36  SD_sSspConfig
       4  SD_u32Address
       4  SD_u32Flags
       4  SD_u32Timeout
       1  SD_u8ErrorCode
     140  SdCardInitialize
      10  SdCardRunActiveState
      26  SdCardWaitSSP
     144  SdError
      48  SdGetReadData
       6  SdGetStatus
       2  SdIdleNoCard
      46  SdIsCardInserted
      50  SdReadBlock
       6  SdWriteBlock

 
 622 bytes in section .bss
  96 bytes in section .data
  24 bytes in section .rodata
 624 bytes in section .text
 
 624 bytes of CODE  memory
  24 bytes of CONST memory
 718 bytes of DATA  memory

Errors: none
Warnings: 3
