###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        14/Oct/2015  14:35:18
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\ant.c
#    Command line =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\ant.c
#        --preprocess=cl
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\bsp\ -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline -I "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\ant.lst
#    Object file  =  
#        D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\ant.o
#
###############################################################################

D:\MPG\mpg_source\Git\Razor_Atmel\firmware_mpg_common\drivers\ant.c
      1          /***********************************************************************************************************************
      2          File: ant.c                                                               
      3          
      4          Description:
      5          ANT implementation for Atmel SAM3U2 Cortex-M3 / Ant slave SPI.  This driver requires synchronous
      6          SPI slave connection to an AP2 or AP2-emulated ANT device (the ANT device is the Master).  
      7          All interface layer code is maintained here.  
      8          Transmitted messages use the Message task; received messages use an SSP peripheral
      9          with SPI_SLAVE_FLOW_CONTROL.
     10          
     11          ------------------------------------------------------------------------------------------------------------------------
     12          
     13          Protected System functions:
     14          void AntInitialize(void)
     15          void AntRunActiveState(void)
     16          
     17          ***********************************************************************************************************************/
     18          
     19          #include "configuration.h"
     20          
     21          /***********************************************************************************************************************
     22          * Bookmarks
     23          ************************************************************************************************************************
     24          !!!!! ANT Serial-layer Functions
     25          @@@@@ ANT Interface-layer Functions
     26          ##### ANT State Machine Definition                                             
     27          ***********************************************************************************************************************/
     28          
     29          /***********************************************************************************************************************
     30          Global variable definitions with scope across entire project.
     31          All Global variable names shall start with "G_<type>Ant"
     32          ***********************************************************************************************************************/
     33          
     34          /* New variables */

   \                                 In section .bss, align 4
     35          u32 G_u32AntFlags;                                    /* Flag bits for ANT-related information */
   \                     G_u32AntFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     36          AntSetupDataType G_stAntSetupData;                    /* ANT channel configuration data */
   \                     G_stAntSetupData:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     37          AntApplicationMsgListType *G_sAntApplicationMsgList;  /* Public linked list of messages from ANT to the application */
   \                     G_sAntApplicationMsgList:
   \   00000000                      DS8 4
     38          

   \                                 In section .data, align 4
     39          u8 G_au8AntMessageOk[]   = "OK\n\r";
   \                     G_au8AntMessageOk:
   \   00000000   0x4F 0x4B          DC8 "OK\012\015"
   \              0x0A 0x0D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     40          u8 G_au8AntMessageFail[] = "FAIL\n\r";
   \                     G_au8AntMessageFail:
   \   00000000   0x46 0x41          DC8 "FAIL\012\015"
   \              0x49 0x4C    
   \              0x0A 0x0D    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .data, align 4
     41          u8 G_au8AntMessageAssign[] = "ANT channel assign ";
   \                     G_au8AntMessageAssign:
   \   00000000   0x41 0x4E          DC8 "ANT channel assign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    

   \                                 In section .data, align 4
     42          u8 G_au8AntMessageUnassign[] = "ANT channel unassign ";
   \                     G_au8AntMessageUnassign:
   \   00000000   0x41 0x4E          DC8 "ANT channel unassign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x75 0x6E    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     43          u8 G_au8AntMessageUnhandled[] = "Default Channel Response ";
   \                     G_au8AntMessageUnhandled:
   \   00000000   0x44 0x65          DC8 "Default Channel Response "
   \              0x66 0x61    
   \              0x75 0x6C    
   \              0x74 0x20    
   \              0x43 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x52 0x65    
   \              0x73 0x70    
   \              0x6F 0x6E    
   \              0x73 0x65    
   \              0x20 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     44          u8 G_au8AntMessageSetup[] = "ANT channel setup ";
   \                     G_au8AntMessageSetup:
   \   00000000   0x41 0x4E          DC8 "ANT channel setup "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x73 0x65    
   \              0x74 0x75    
   \              0x70 0x20    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .data, align 4
     45          u8 G_au8AntMessageClose[] = "ANT channel close ";
   \                     G_au8AntMessageClose:
   \   00000000   0x41 0x4E          DC8 "ANT channel close "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x63 0x6C    
   \              0x6F 0x73    
   \              0x65 0x20    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .data, align 4
     46          u8 G_au8AntMessageOpen[]  = "ANT channel open ";
   \                     G_au8AntMessageOpen:
   \   00000000   0x41 0x4E          DC8 "ANT channel open "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x6F 0x70    
   \              0x65 0x6E    
   \              0x20 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     47          u8 G_au8AntMessageInit[] = "Initializing ANT... ";
   \                     G_au8AntMessageInit:
   \   00000000   0x49 0x6E          DC8 "Initializing ANT... "
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x69    
   \              0x6E 0x67    
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x2E 0x2E    
   \              0x2E 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     48          u8 G_au8AntMessageInitFail[] = "failed. Host IOs set to HiZ.\r\n";
   \                     G_au8AntMessageInitFail:
   \   00000000   0x66 0x61          DC8 "failed. Host IOs set to HiZ.\015\012"
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x20 0x49    
   \              0x4F 0x73    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x48 0x69    
   \              0x5A 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .data, align 4
     49          u8 G_au8AntMessageNoAnt[] = "\n\r### nRF51422 Programming Mode: no ANT functionality ####\n\r";
   \                     G_au8AntMessageNoAnt:
   \   00000000   0x0A 0x0D          DC8 0AH, 0DH, 23H, 23H, 23H, 20H, 6EH, 52H
   \              0x23 0x23    
   \              0x23 0x20    
   \              0x6E 0x52    
   \   00000008   0x46 0x35          DC8 46H, 35H, 31H, 34H, 32H, 32H, 20H, 50H
   \              0x31 0x34    
   \              0x32 0x32    
   \              0x20 0x50    
   \   00000010   0x72 0x6F          DC8 72H, 6FH, 67H, 72H, 61H, 6DH, 6DH, 69H
   \              0x67 0x72    
   \              0x61 0x6D    
   \              0x6D 0x69    
   \   00000018   0x6E 0x67          DC8 6EH, 67H, 20H, 4DH, 6FH, 64H, 65H, 3AH
   \              0x20 0x4D    
   \              0x6F 0x64    
   \              0x65 0x3A    
   \   00000020   0x20 0x6E          DC8 20H, 6EH, 6FH, 20H, 41H, 4EH, 54H, 20H
   \              0x6F 0x20    
   \              0x41 0x4E    
   \              0x54 0x20    
   \   00000028   0x66 0x75          DC8 66H, 75H, 6EH, 63H, 74H, 69H, 6FH, 6EH
   \              0x6E 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \   00000030   0x61 0x6C          DC8 61H, 6CH, 69H, 74H, 79H, 20H, 23H, 23H
   \              0x69 0x74    
   \              0x79 0x20    
   \              0x23 0x23    
   \   00000038   0x23 0x23          DC8 23H, 23H, 0AH, 0DH, 0
   \              0x0A 0x0D    
   \              0x00         
   \   0000003D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     50          
     51          
     52          /*----------------------------------------------------------------------------*/
     53          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
     54          and indicate what file the variable is defined in. */
     55          extern u32 G_u32SystemFlags;                            /* From main.c */
     56          extern u32 G_u32ApplicationFlags;                       /* From main.c */
     57          
     58          extern volatile u32 G_u32SystemTime1ms;                 /* From board-specific source file */
     59          extern volatile u32 G_u32SystemTime1s;                  /* From board-specific source file */
     60          
     61          extern volatile u32 ANT_SSP_FLAGS;                      /* From configuration.h */
     62          
     63          
     64          /***********************************************************************************************************************
     65          Global variable definitions with scope limited to this local application.
     66          Variable names shall start with "Ant_<type>Name" and be declared as static.
     67          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     68          static fnCode_type Ant_pfnStateMachine;                 /* The ANT state machine function pointer */
   \                     Ant_pfnStateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     69          static u32 Ant_u32RxTimer;                              /* Dedicated timer for receiving bytes */
   \                     Ant_u32RxTimer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     70          static u32 Ant_u32TxTimer;                              /* Dedicated timer for transmitting bytes */
   \                     Ant_u32TxTimer:
   \   00000000                      DS8 4
     71          

   \                                 In section .bss, align 4
     72          static u32 Ant_u32TxByteCounter = 0;                    /* Counter counts callbacks on sent bytes */
   \                     Ant_u32TxByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     73          static u32 Ant_u32RxByteCounter = 0;                    /* Counter counts callbacks on received bytes */
   \                     Ant_u32RxByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     74          static u32 Ant_u32RxTimeoutCounter = 0;                 /* Increments any time an ANT reception times out */
   \                     Ant_u32RxTimeoutCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     75          static u32 Ant_u32UnexpectedByteCounter = 0;            /* Increments any time a byte is received that was not expected value */
   \                     Ant_u32UnexpectedByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     76          static u32 Ant_u32CurrentTxMessageToken = 0;            /* Token for message currently being sent to ANT */
   \                     Ant_u32CurrentTxMessageToken:
   \   00000000                      DS8 4
     77          

   \                                 In section .bss, align 4
     78          static SspConfigurationType Ant_sSspConfig;             /* Configuration information for SSP peripheral */
   \                     Ant_sSspConfig:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
     79          static SspPeripheralType* Ant_Ssp;                      /* Pointer to Ant's SSP peripheral object */
   \                     Ant_Ssp:
   \   00000000                      DS8 4
     80          

   \                                 In section .bss, align 4
     81          static u8 Ant_u8AntVersion[MESG_VERSION_SIZE];          /* ANT device version string */
   \                     Ant_u8AntVersion:
   \   00000000                      DS8 12
     82          

   \                                 In section .bss, align 4
     83          static u8 Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE];       /* Space for verified received ANT messages */
   \                     Ant_au8AntRxBuffer:
   \   00000000                      DS8 256

   \                                 In section .bss, align 4
     84          static u8 *Ant_pu8AntRxBufferNextChar;                  /* Pointer to next char to be written in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     85          static u8 *Ant_pu8AntRxBufferCurrentChar;               /* Pointer to the current char in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferCurrentChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     86          static u8 *Ant_pu8AntRxBufferUnreadMsg;                 /* Pointer to unread chars in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferUnreadMsg:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     87          static u8 Ant_u8AntNewRxMessages;                       /* Counter for number of new messages in AntRxBuffer */
   \                     Ant_u8AntNewRxMessages:
   \   00000000                      DS8 1
     88          

   \                                 In section .bss, align 4
     89          static u32 Ant_u32ApplicationMessageCount = 0;          /* Counts messages queued on G_sAntApplicationMsgList */
   \                     Ant_u32ApplicationMessageCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     90          static AntOutgoingMessageListType *Ant_psDataOutgoingMsgList; /* Linked list of outgoing ANT-formatted messages */
   \                     Ant_psDataOutgoingMsgList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     91          static u32 Ant_u32OutgoingMessageCount = 0;             /* Counts messages queued on Ant_psDataOutgoingMsgList */
   \                     Ant_u32OutgoingMessageCount:
   \   00000000                      DS8 4
     92          

   \                                 In section .bss, align 1
     93          static u8 Ant_u8SlaveMissedMessageHigh = 0;             /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageHigh:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     94          static u8 Ant_u8SlaveMissedMessageMid = 0;              /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageMid:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     95          static u8 Ant_u8SlaveMissedMessageLow = 0;              /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageLow:
   \   00000000                      DS8 1
     96          
     97          
     98          /* Debug variables */

   \                                 In section .bss, align 4
     99          static u32 Ant_DebugRxMessageCounter = 0;
   \                     Ant_DebugRxMessageCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    100          static u32 Ant_DebugTotalRxMessages = 0;
   \                     Ant_DebugTotalRxMessages:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    101          static u32 Ant_DebugProcessRxMessages = 0;
   \                     Ant_DebugProcessRxMessages:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    102          static u32 Ant_DebugQueuedDataMessages = 0;
   \                     Ant_DebugQueuedDataMessages:
   \   00000000                      DS8 4
    103          
    104          
    105          /***********************************************************************************************************************
    106          !!!!! ANT Serial-layer Functions
    107          ***********************************************************************************************************************/
    108          
    109          /* ANT Private Serial-layer Functions */
    110          
    111          /*------------------------------------------------------------------------------
    112          Function: AntSyncSerialInitialize
    113          
    114          Description:
    115          Properly sets up the ANT SPI interface and tests Host <-> ANT communications.
    116          
    117          Requires:
    118            - ANT_SPI is configured
    119            - !CS (SEN) interrupt should be enabled
    120          // - GPIO interrupts are configured and enabled
    121          
    122          Promises:
    123            - Ant_pu8AntRxBufferNextChar is initialized to start of AntRxBuffer
    124            - Ant_pu8AntRxBufferUnreadMsg is initialized to start of AntRxBuffer
    125            - Ant_u8AntNewRxMessages = 0;
    126            - ANT SSP CS and RX interrupts are enabled
    127            - If ANT starts up correctly and responds to version request, then 
    128              G_u32SystemFlags _APPLICATION_FLAGS_ANT is set and Ant_u8AntVersion is populated
    129              with the returned version information from the ANT IC.  
    130          */

   \                                 In section .text, align 2, keep-with-next
    131          static void AntSyncSerialInitialize(void)
    132          {
   \                     AntSyncSerialInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    133            u8 au8ANTGetVersion[] = {MESG_REQUEST_SIZE, MESG_REQUEST_ID, G_stAntSetupData.AntChannel, MESG_VERSION_ID, 0};    
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000000A   0xC90C             LDM      R1!,{R2,R3}
   \   0000000C   0xC00C             STM      R0!,{R2,R3}
   \   0000000E   0x3908             SUBS     R1,R1,#+8
   \   00000010   0x3808             SUBS     R0,R0,#+8
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xF88D 0x0006      STRB     R0,[SP, #+6]
    134            u32 u32EventTimer;
    135            bool bErrorStatus = FALSE;
   \   0000001C   0x2400             MOVS     R4,#+0
    136            
    137            /* Initialize buffer pointers */  
    138            Ant_pu8AntRxBufferNextChar    = Ant_au8AntRxBuffer;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000026   0x6008             STR      R0,[R1, #+0]
    139            Ant_pu8AntRxBufferCurrentChar = Ant_au8AntRxBuffer;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   00000030   0x6008             STR      R0,[R1, #+0]
    140            Ant_pu8AntRxBufferUnreadMsg   = Ant_au8AntRxBuffer;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    141            Ant_u8AntNewRxMessages = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000042   0x7008             STRB     R0,[R1, #+0]
    142           
    143            /* Reset the 51422 and initialize SRDY and MRDY */
    144            u32EventTimer = G_u32SystemTime1ms;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x9000             STR      R0,[SP, #+0]
    145            ANT_RESET_ASSERT();
   \   0000004C   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x400e0e34
   \   00000054   0x6008             STR      R0,[R1, #+0]
    146            SYNC_MRDY_DEASSERT();
   \   00000056   0xF45F 0x0000      MOVS     R0,#+8388608
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x400e0e30
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    147            SYNC_SRDY_DEASSERT();
   \   00000060   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x400e0e30
   \   00000068   0x6008             STR      R0,[R1, #+0]
    148            while( !IsTimeUp(&u32EventTimer, ANT_RESET_WAIT_MS) );
   \                     ??AntSyncSerialInitialize_0: (+1)
   \   0000006A   0x2164             MOVS     R1,#+100
   \   0000006C   0xA800             ADD      R0,SP,#+0
   \   0000006E   0x.... 0x....      BL       IsTimeUp
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD0F9             BEQ.N    ??AntSyncSerialInitialize_0
    149            ANT_RESET_DEASSERT();
   \   00000076   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x400e0e30
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    150            u32EventTimer = G_u32SystemTime1ms;
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x9000             STR      R0,[SP, #+0]
    151            while( !IsTimeUp(&u32EventTimer, ANT_RESTART_DELAY_MS) );
   \                     ??AntSyncSerialInitialize_1: (+1)
   \   00000088   0xF44F 0x717A      MOV      R1,#+1000
   \   0000008C   0xA800             ADD      R0,SP,#+0
   \   0000008E   0x.... 0x....      BL       IsTimeUp
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD0F8             BEQ.N    ??AntSyncSerialInitialize_1
    152          
    153            
    154            /* ANT should want to send message 0x6F now to indicate it has reset */
    155            u32EventTimer = G_u32SystemTime1ms;
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x9000             STR      R0,[SP, #+0]
    156            while( !IS_SEN_ASSERTED() && !bErrorStatus )
   \                     ??AntSyncSerialInitialize_2: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x07C0             LSLS     R0,R0,#+31
   \   000000A6   0xD409             BMI.N    ??AntSyncSerialInitialize_3
   \   000000A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AA   0x2C00             CMP      R4,#+0
   \   000000AC   0xD106             BNE.N    ??AntSyncSerialInitialize_3
    157            {
    158              bErrorStatus = IsTimeUp(&u32EventTimer, ANT_MSG_TIMEOUT_MS);
   \   000000AE   0xF44F 0x717A      MOV      R1,#+1000
   \   000000B2   0xA800             ADD      R0,SP,#+0
   \   000000B4   0x.... 0x....      BL       IsTimeUp
   \   000000B8   0x0004             MOVS     R4,R0
   \   000000BA   0xE7F0             B.N      ??AntSyncSerialInitialize_2
    159            }
    160          
    161            if (!bErrorStatus)
   \                     ??AntSyncSerialInitialize_3: (+1)
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x2C00             CMP      R4,#+0
   \   000000C0   0xD110             BNE.N    ??AntSyncSerialInitialize_4
    162            {
    163              /* Receive and process the restart message */
    164              AntRxMessage();
   \   000000C2   0x.... 0x....      BL       AntRxMessage
    165              AntProcessMessage();   
   \   000000C6   0x.... 0x....      BL       AntProcessMessage
    166          
    167            /* Send out version request message and expect response */
    168              au8ANTGetVersion[4] = AntCalculateTxChecksum(&au8ANTGetVersion[0]);
   \   000000CA   0xA801             ADD      R0,SP,#+4
   \   000000CC   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000D0   0xF88D 0x0008      STRB     R0,[SP, #+8]
    169              AntTxMessage(&au8ANTGetVersion[0]);    
   \   000000D4   0xA801             ADD      R0,SP,#+4
   \   000000D6   0x.... 0x....      BL       AntTxMessage
    170              AntExpectResponse(MESG_VERSION_ID, ANT_MSG_TIMEOUT_MS);
   \   000000DA   0xF44F 0x717A      MOV      R1,#+1000
   \   000000DE   0x203E             MOVS     R0,#+62
   \   000000E0   0x.... 0x....      BL       AntExpectResponse
    171            }
    172           
    173          } /* end AntSyncSerialInitialize */
   \                     ??AntSyncSerialInitialize_4: (+1)
   \   000000E4   0xBD1F             POP      {R0-R4,PC}       ;; return
    174          
    175          
    176          /*-----------------------------------------------------------------------------
    177          Function: AntSrdyPulse
    178          
    179          Description:
    180          Pulses Srdy with added delays on the front and middle. 
    181          
    182          Requires:
    183            - 
    184          
    185          Promises:
    186            - A delay controlled by ANT_SRDY_DELAY is passed
    187            - SRDY is asserted
    188            - A delay of ANT_SRDY_PERIOD is passed
    189            - SRDY is deasserted
    190          */

   \                                 In section .text, align 2, keep-with-next
    191          static void AntSrdyPulse(void)
    192          {
    193            for(u32 i = 0; i < ANT_SRDY_DELAY; i++);
   \                     AntSrdyPulse: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \                     ??AntSrdyPulse_0: (+1)
   \   00000002   0x28C8             CMP      R0,#+200
   \   00000004   0xD201             BCS.N    ??AntSrdyPulse_1
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0xE7FB             B.N      ??AntSrdyPulse_0
    194            SYNC_SRDY_ASSERT();
   \                     ??AntSrdyPulse_1: (+1)
   \   0000000A   0xF05F 0x7080      MOVS     R0,#+16777216
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x400e0e34
   \   00000012   0x6008             STR      R0,[R1, #+0]
    195            
    196            for(u32 i = 0; i < ANT_SRDY_PERIOD; i++);
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??AntSrdyPulse_2: (+1)
   \   00000016   0x2814             CMP      R0,#+20
   \   00000018   0xD201             BCS.N    ??AntSrdyPulse_3
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xE7FB             B.N      ??AntSrdyPulse_2
    197            SYNC_SRDY_DEASSERT();
   \                     ??AntSrdyPulse_3: (+1)
   \   0000001E   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x400e0e30
   \   00000026   0x6008             STR      R0,[R1, #+0]
    198          
    199          } /* end AntSrdyPulse() */
   \   00000028   0x4770             BX       LR               ;; return
    200          
    201          
    202          /*-----------------------------------------------------------------------------
    203          Function: AntRxMessage
    204          
    205          Description:
    206          Receive a message from ANT to the Host.  Incoming bytes are deposited directly into the receive
    207          buffer from the SSP ISR which should be extremely fast.  
    208          
    209          Requires:
    210            - _SSP_CS_ASSERTED is set indicating a message is ready to come in 
    211            - G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set if the system wanted to transmit
    212              but ANT wanted to send a message at the same time (so MESG_TX_SYNC has already 
    213              been received); _SSP_RX_COMPLETE must still be set from this.
    214            - Ant_pu8AntRxBufferCurrentChar points to the first byte of the message
    215          
    216          Promises:
    217            - If a good new message has been received, then Ant_u8AntNewMessages is incremented
    218              and the message is at Ant_pu8AntRxBufferUnreadMsg in Ant_au8AntRxBuffer
    219            - If a good message is not received, then Ant_u8AntNewMessages is unchanged.
    220            - In both cases, Ant_pu8AntRxBufferNextChar points at the next empty buffer location
    221          */

   \                                 In section .text, align 2, keep-with-next
    222          static void AntRxMessage(void)
    223          {
   \                     AntRxMessage: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    224            u8 u8Checksum;
    225            u8 u8Length;
    226            u32 u32CurrentRxByteCount;
    227            u8 au8RxTimeoutMsg[] = "AntRx: timeout\n\r";
   \   00000004   0xA806             ADD      R0,SP,#+24
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15
   \   0000000A   0x2211             MOVS     R2,#+17
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    228            u8 au8RxFailMsg[] = "AntRx: message failed\n\r";
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   00000016   0x2218             MOVS     R2,#+24
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy4
    229            bool bReceptionError = FALSE;
   \   0000001C   0x2700             MOVS     R7,#+0
    230            
    231            /* Ensure we have CS flag */
    232            if( !( IS_SEN_ASSERTED() ) )
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xF140 0x810B      BPL.W    ??AntRxMessage_0
    233            {
    234              return;
    235            }
    236            
    237            /* Initialize the receive timer and get a snapshot of current byte count */
    238            u32CurrentRxByteCount = Ant_u32RxByteCounter;
   \                     ??AntRxMessage_1: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0006             MOVS     R6,R0
    239            Ant_u32RxTimer = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000038   0x6008             STR      R0,[R1, #+0]
    240            
    241            /* If the Global _ANT_FLAGS_TX_INTERRUPTED flag has been set, then we have already read the TX_SYNC byte */
    242            if(G_u32AntFlags & _ANT_FLAGS_TX_INTERRUPTED)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x00C0             LSLS     R0,R0,#+3
   \   00000042   0xD509             BPL.N    ??AntRxMessage_2
    243            {
    244              /* Clear flag and load the value we know was already received to allow the function to proceed*/
    245              G_u32AntFlags &= ~_ANT_FLAGS_TX_INTERRUPTED;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000052   0x6008             STR      R0,[R1, #+0]
    246              
    247              /* Adjust the starting byte counter since it came in during AntTxMessage */
    248              u32CurrentRxByteCount--;
   \   00000054   0x1E76             SUBS     R6,R6,#+1
   \   00000056   0xE015             B.N      ??AntRxMessage_3
    249              
    250            }
    251            /* Otherwise we need to first read the sync byte  */
    252            else
    253            {
    254              /* Do short delay then cycle SRDY to get the first byte */
    255              AntSrdyPulse();
   \                     ??AntRxMessage_2: (+1)
   \   00000058   0x.... 0x....      BL       AntSrdyPulse
    256          
    257              /* Begin the receive cycle that takes place using interrupts and callbacks and is monitored by a timeout of about 500us - this should be plenty of time
    258              to receive even the longest ANT message but still only half the allowed 1ms loop time for the system. */
    259              
    260              /* Read the first byte when it comes in */
    261              while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) &&
    262                     (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_4: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x0740             LSLS     R0,R0,#+29
   \   00000064   0xD40E             BMI.N    ??AntRxMessage_3
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF242 0x7110      MOVW     R1,#+10000
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD207             BCS.N    ??AntRxMessage_3
    263              {
    264                Ant_u32RxTimer++;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000080   0x6008             STR      R0,[R1, #+0]
   \   00000082   0xE7EB             B.N      ??AntRxMessage_4
    265              }
    266            }
    267            
    268            if( Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT) 
   \                     ??AntRxMessage_3: (+1)
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xF242 0x7111      MOVW     R1,#+10001
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD305             BCC.N    ??AntRxMessage_5
    269            {
    270              AntAbortMessage();
   \   00000092   0x.... 0x....      BL       AntAbortMessage
    271              DebugPrintf(au8RxTimeoutMsg);
   \   00000096   0xA806             ADD      R0,SP,#+24
   \   00000098   0x.... 0x....      BL       DebugPrintf
    272              return;
   \   0000009C   0xE0D0             B.N      ??AntRxMessage_0
    273            }
    274          
    275            /* _SSP_RX_COMPLETE flag will be set and the Rx callback will have run.  
    276            The callback does NOT toggle SRDY yet.  _SSP_RX_COMPLETE should still
    277            be set from AntTxMessage if that's what got us here. */
    278            ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \                     ??AntRxMessage_5: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    279             
    280            /* One way or the other, we now have a potential SYNC byte at Ant_pu8AntRxBufferCurrentChar.  
    281            Proceed to test it and receive the rest of the message */
    282            if (*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC)                     
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x7800             LDRB     R0,[R0, #+0]
   \   000000B6   0x28A4             CMP      R0,#+164
   \   000000B8   0xF040 0x8086      BNE.W    ??AntRxMessage_6
    283            {
    284              /* Flag that a reception is in progress */
    285              G_u32AntFlags |= _ANT_FLAGS_RX_IN_PROGRESS;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    286              
    287              /* Delay and then cycle SRDY to get the next byte (length) */
    288              AntSrdyPulse();
   \   000000CC   0x.... 0x....      BL       AntSrdyPulse
    289              
    290              /* The SSP interrupts and Rx callback handle the rest of the reception until a full message is received. 
    291              We know it is received when SEN is deasserted. */
    292              while( IS_SEN_ASSERTED() && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_7: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x07C0             LSLS     R0,R0,#+31
   \   000000D8   0xD50E             BPL.N    ??AntRxMessage_8
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0xF242 0x7110      MOVW     R1,#+10000
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xD207             BCS.N    ??AntRxMessage_8
    293              {
    294                Ant_u32RxTimer++;
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x1C40             ADDS     R0,R0,#+1
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000F4   0x6008             STR      R0,[R1, #+0]
   \   000000F6   0xE7EB             B.N      ??AntRxMessage_7
    295              }
    296            
    297              /* One way or another, this Rx is done! */
    298              G_u32AntFlags &= ~_ANT_FLAGS_RX_IN_PROGRESS;
   \                     ??AntRxMessage_8: (+1)
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000106   0x6008             STR      R0,[R1, #+0]
    299              ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000116   0x6008             STR      R0,[R1, #+0]
    300          
    301              /* Check that the above loop ended as expected and didn't time out */
    302              if(Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT)
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xD246             BCS.N    ??AntRxMessage_9
    303              {  
    304                /* Update counter to see how many bytes we should have */
    305                u32CurrentRxByteCount = Ant_u32RxByteCounter - u32CurrentRxByteCount;
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0x1B86             SUBS     R6,R0,R6
    306              
    307                /* RxBufferCurrentChar is still pointing to the SYNC byte. Validate what should be a complete message now. */
    308                u8Checksum = *Ant_pu8AntRxBufferCurrentChar;
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x7800             LDRB     R0,[R0, #+0]
   \   00000136   0x0004             MOVS     R4,R0
    309                AdvanceAntRxBufferCurrentChar();
   \   00000138   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    310                
    311                /* Read the length byte and add two to count the length byte and message ID but not checksum as length will be our checksum counter */
    312                u8Length = *Ant_pu8AntRxBufferCurrentChar + 2;  
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x7800             LDRB     R0,[R0, #+0]
   \   00000144   0x1C80             ADDS     R0,R0,#+2
   \   00000146   0x0005             MOVS     R5,R0
    313                
    314                /* Optional check (u8Length does not include the SYNC byte or Checksum byte so add 2) */
    315                if(u32CurrentRxByteCount != (u8Length + 2) )
   \   00000148   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000014A   0x1CA8             ADDS     R0,R5,#+2
   \   0000014C   0x4286             CMP      R6,R0
   \   0000014E   0xD007             BEQ.N    ??AntRxMessage_10
    316                {
    317                  /* Could throw out the message right away - this could save some potential weird memory accesses
    318                  if there was any corruption or a wild u8Length value */
    319                  G_u32AntFlags |= _ANT_FLAGS_LENGTH_MISMATCH;
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   00000154   0x6800             LDR      R0,[R0, #+0]
   \   00000156   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   0000015E   0x6008             STR      R0,[R1, #+0]
    320                }
    321           
    322                /* Validate the remaining bytes based on u8Length*/
    323                do
    324                {
    325                  u8Checksum ^= *Ant_pu8AntRxBufferCurrentChar;                     
   \                     ??AntRxMessage_10: (+1)
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000164   0x6800             LDR      R0,[R0, #+0]
   \   00000166   0x7800             LDRB     R0,[R0, #+0]
   \   00000168   0x4044             EORS     R4,R0,R4
    326                  AdvanceAntRxBufferCurrentChar();
   \   0000016A   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    327                } while (--u8Length);
   \   0000016E   0x1E6D             SUBS     R5,R5,#+1
   \   00000170   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000172   0x2D00             CMP      R5,#+0
   \   00000174   0xD1F4             BNE.N    ??AntRxMessage_10
    328                
    329                /* AntRxBufferCurrentChar is pointing to the last received byte that should be the checksum. */
    330                if (u8Checksum == *Ant_pu8AntRxBufferCurrentChar)      
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x7800             LDRB     R0,[R0, #+0]
   \   0000017E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000180   0x4284             CMP      R4,R0
   \   00000182   0xD10E             BNE.N    ??AntRxMessage_11
    331                {
    332                  Ant_u8AntNewRxMessages++;
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000188   0x7800             LDRB     R0,[R0, #+0]
   \   0000018A   0x1C40             ADDS     R0,R0,#+1
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000190   0x7008             STRB     R0,[R1, #+0]
    333                  Ant_DebugTotalRxMessages++;
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \   00000196   0x6800             LDR      R0,[R0, #+0]
   \   00000198   0x1C40             ADDS     R0,R0,#+1
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   0000019E   0x6008             STR      R0,[R1, #+0]
   \   000001A0   0xE01B             B.N      ??AntRxMessage_12
    334                }
    335                /* If the message was not good, then move Ant_pu8AntRxBufferUnreadMsg passed the garbage data */
    336                else
    337                {
    338                  Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferCurrentChar;
   \                     ??AntRxMessage_11: (+1)
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   000001AC   0x6008             STR      R0,[R1, #+0]
    339                  AdvanceAntRxBufferUnreadMsgPointer();
   \   000001AE   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   \   000001B2   0xE012             B.N      ??AntRxMessage_12
    340                }
    341              } 
    342              else
    343              {
    344                Ant_u32RxTimeoutCounter++;
   \                     ??AntRxMessage_9: (+1)
   \   000001B4   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   000001B8   0x6800             LDR      R0,[R0, #+0]
   \   000001BA   0x1C40             ADDS     R0,R0,#+1
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   000001C0   0x6008             STR      R0,[R1, #+0]
    345                bReceptionError = TRUE;
   \   000001C2   0x2001             MOVS     R0,#+1
   \   000001C4   0x0007             MOVS     R7,R0
   \   000001C6   0xE008             B.N      ??AntRxMessage_12
    346              }
    347            } /* end if(*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC) */
    348            else
    349            {
    350              /* Otherwise we have received an unexpected byte -- flag it, clear Ssp flags and abandon the byte */
    351              Ant_u32UnexpectedByteCounter++;
   \                     ??AntRxMessage_6: (+1)
   \   000001C8   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000001CC   0x6800             LDR      R0,[R0, #+0]
   \   000001CE   0x1C40             ADDS     R0,R0,#+1
   \   000001D0   0x.... 0x....      LDR.W    R1,??DataTable18_2
   \   000001D4   0x6008             STR      R0,[R1, #+0]
    352              bReceptionError = TRUE;
   \   000001D6   0x2001             MOVS     R0,#+1
   \   000001D8   0x0007             MOVS     R7,R0
    353            }
    354          
    355            /* If a reception error has occured, */
    356            if(bReceptionError)
   \                     ??AntRxMessage_12: (+1)
   \   000001DA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001DC   0x2F00             CMP      R7,#+0
   \   000001DE   0xD02D             BEQ.N    ??AntRxMessage_13
    357            {
    358              /* Toggle SRDY until CS deasserts and throw out the message */
    359              DebugPrintf(au8RxFailMsg);
   \   000001E0   0xA800             ADD      R0,SP,#+0
   \   000001E2   0x.... 0x....      BL       DebugPrintf
    360              while( IS_SEN_ASSERTED()  && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_14: (+1)
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000001EA   0x6800             LDR      R0,[R0, #+0]
   \   000001EC   0x07C0             LSLS     R0,R0,#+31
   \   000001EE   0xD510             BPL.N    ??AntRxMessage_15
   \   000001F0   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   000001F4   0x6800             LDR      R0,[R0, #+0]
   \   000001F6   0xF242 0x7110      MOVW     R1,#+10000
   \   000001FA   0x4288             CMP      R0,R1
   \   000001FC   0xD209             BCS.N    ??AntRxMessage_15
    361              {
    362                Ant_u32RxTimer++;
   \   000001FE   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000202   0x6800             LDR      R0,[R0, #+0]
   \   00000204   0x1C40             ADDS     R0,R0,#+1
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000020A   0x6008             STR      R0,[R1, #+0]
    363                AntSrdyPulse();
   \   0000020C   0x.... 0x....      BL       AntSrdyPulse
   \   00000210   0xE7E9             B.N      ??AntRxMessage_14
    364              }
    365             
    366              /* Since we have flow control, we can safely assume that no other messages
    367              have come in and Ant_pu8AntRxBufferNextChar is pointing to where the next 
    368              valid message WILL come in - so push all the pointers there. */
    369              Ant_pu8AntRxBufferCurrentChar = Ant_pu8AntRxBufferNextChar;
   \                     ??AntRxMessage_15: (+1)
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000216   0x6800             LDR      R0,[R0, #+0]
   \   00000218   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   0000021C   0x6008             STR      R0,[R1, #+0]
    370              Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferNextChar;
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000222   0x6800             LDR      R0,[R0, #+0]
   \   00000224   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000228   0x6008             STR      R0,[R1, #+0]
    371              ANT_SSP_FLAGS &= ~(_SSP_TX_COMPLETE | _SSP_RX_COMPLETE);
   \   0000022A   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000022E   0x6800             LDR      R0,[R0, #+0]
   \   00000230   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000234   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000238   0x6008             STR      R0,[R1, #+0]
   \   0000023A   0xE001             B.N      ??AntRxMessage_16
    372          
    373            }
    374            else
    375            {
    376              /* In all other cases, finish by advancing the current byte pointer */
    377              AdvanceAntRxBufferCurrentChar();
   \                     ??AntRxMessage_13: (+1)
   \   0000023C   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    378            }
    379            
    380          } /* end AntRxMessage() */
   \                     ??AntRxMessage_16: (+1)
   \                     ??AntRxMessage_0: (+1)
   \   00000240   0xB00B             ADD      SP,SP,#+44
   \   00000242   0xBDF0             POP      {R4-R7,PC}       ;; return
    381          
    382          
    383          /*-----------------------------------------------------------------------------
    384          Function: AntAbortMessage
    385          
    386          Description:
    387          Kills the current message in progress with ANT and resets all of the pointers.
    388          Any existing received buffer data is lost.
    389          
    390          *** Warning: all interrupts are disabled, so this could impact system tick time ***
    391          
    392          Requires:
    393            - 
    394          
    395          Promises:
    396            - Ant_pu8AntRxBufferNextChar, Ant_pu8AntRxBufferCurrentChar, Ant_pu8AntRxBufferUnreadMsg,
    397              and Ant_u8AntNewRxMessages reset.
    398          */

   \                                 In section .text, align 2, keep-with-next
    399          static void AntAbortMessage(void)
    400          {
    401            __disable_interrupt();
   \                     AntAbortMessage: (+1)
   \   00000000   0xB672             CPSID    I
    402            Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    403            Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   00000014   0x6008             STR      R0,[R1, #+0]
    404            Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    405            Ant_u8AntNewRxMessages = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    406            __enable_interrupt();
   \   00000028   0xB662             CPSIE    I
    407            
    408          } /* end AntAbortMessage() */
   \   0000002A   0x4770             BX       LR               ;; return
    409          
    410          
    411          /*-----------------------------------------------------------------------------
    412          Function: AdvanceAntRxBufferCurrentChar
    413          
    414          Description:
    415          Safely advances the Ant_pu8AntRxBufferCurrentChar within the circular buffer
    416          
    417          Requires:
    418            - No interrupt functions using Ant_pu8AntRxBufferCurrentChar are allowed to run
    419          
    420          Promises:
    421            - Ant_pu8AntRxBufferCurrentChar points to the next char to write in Ant_au8AntRxBuffer
    422          */

   \                                 In section .text, align 2, keep-with-next
    423          static void AdvanceAntRxBufferCurrentChar(void)
    424          {
    425            Ant_pu8AntRxBufferCurrentChar++;
   \                     AdvanceAntRxBufferCurrentChar: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    426            if(Ant_pu8AntRxBufferCurrentChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??AdvanceAntRxBufferCurrentChar_0
    427            {
    428              Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   00000024   0x6008             STR      R0,[R1, #+0]
    429            }
    430            
    431          } /* end AdvanceAntRxBufferCurrentChar() */
   \                     ??AdvanceAntRxBufferCurrentChar_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    432          
    433          
    434          /*-----------------------------------------------------------------------------/
    435          Function: AdvanceAntRxBufferUnreadMsgPointer
    436          
    437          Description:
    438          Increments the Rx buffer pointer and handles the wrap-around.
    439          
    440          Requires:
    441            - Ant_pu8AntRxBufferUnreadMsg cannot be moved in an ISR
    442          
    443          Promises:
    444            - Ant_pu8AntRxBufferUnreadMsg is pointing to the next char in the circular buffer
    445          */

   \                                 In section .text, align 2, keep-with-next
    446          static void AdvanceAntRxBufferUnreadMsgPointer()
    447          {
    448            Ant_pu8AntRxBufferUnreadMsg++;
   \                     AdvanceAntRxBufferUnreadMsgPointer: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    449            if (Ant_pu8AntRxBufferUnreadMsg == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??AdvanceAntRxBufferUnreadMsgPointer_0
    450            {
    451              Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000024   0x6008             STR      R0,[R1, #+0]
    452            }
    453            
    454          } /* end AdvanceAntRxBufferUnreadMsgPointer() */
   \                     ??AdvanceAntRxBufferUnreadMsgPointer_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    455          
    456          
    457          /***********************************************************************************************************************
    458          @@@@@ ANT Interface-layer Functions
    459          ***********************************************************************************************************************/
    460            
    461          /*------------------------------------------------------------------------------
    462          Function: AntInitialize
    463          
    464          Description:
    465          Intialize the ANT system.  ANT device is reset and communication checked through
    466          a version request.  The main channel parameters are then set up to default values.
    467            
    468          Requires:
    469            - ANT_SPI peripheral is correctly configured
    470            - Debug system is initialized so debug messages can be sent to UART
    471          
    472          Promises:
    473            - G_stAntSetupData set to default ANT values
    474            - If all successful, G_u32SystemFlags.AntGood bit is set and ANT system is ready
    475            - Ant_pfnStateMachine = AntSM_Idle
    476          */

   \                                 In section .text, align 2, keep-with-next
    477          void AntInitialize(void)
    478          {
   \                     AntInitialize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    479            u32 u32AntPortAPins, u32AntPortBPins;
    480          
    481            if(G_u32SystemFlags & _SYSTEM_STARTUP_NO_ANT)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x01C0             LSLS     R0,R0,#+7
   \   0000000A   0xD509             BPL.N    ??AntInitialize_0
    482            {
    483              DebugPrintf(G_au8AntMessageNoAnt);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000010   0x.... 0x....      BL       DebugPrintf
    484              Ant_pfnStateMachine = AntSM_NoResponse;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xE0B6             B.N      ??AntInitialize_1
    485            }
    486            else
    487            {
    488              /* Give PIO control of ANT_RESET line */
    489              AT91C_BASE_PIOB->PIO_OER = PB_21_ANT_RESET;
   \                     ??AntInitialize_0: (+1)
   \   00000020   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x400e0e10
   \   00000028   0x6008             STR      R0,[R1, #+0]
    490              
    491              /* Announce on the debug port that ANT setup is starting and intialize pointers */
    492              DebugPrintf(G_au8AntMessageInit);
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000002E   0x.... 0x....      BL       DebugPrintf
    493              G_sAntApplicationMsgList = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable20_6
   \   00000038   0x6008             STR      R0,[R1, #+0]
    494              Ant_psDataOutgoingMsgList = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   00000040   0x6008             STR      R0,[R1, #+0]
    495              
    496              /* Set default setup values in the AntSetupData struct */
    497              G_stAntSetupData.AntChannel          = ANT_CHANNEL_DEFAULT;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000048   0x7008             STRB     R0,[R1, #+0]
    498              G_stAntSetupData.AntChannelType      = ANT_CHANNEL_TYPE_DEFAULT;
   \   0000004A   0x2010             MOVS     R0,#+16
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000050   0x7048             STRB     R0,[R1, #+1]
    499              G_stAntSetupData.AntNetwork          = ANT_NETWORK_DEFAULT;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000058   0x7088             STRB     R0,[R1, #+2]
    500              G_stAntSetupData.AntSerialLo         = ANT_SERIAL_LO_DEFAULT;
   \   0000005A   0x20FF             MOVS     R0,#+255
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000060   0x70C8             STRB     R0,[R1, #+3]
    501              G_stAntSetupData.AntSerialHi         = ANT_SERIAL_HI_DEFAULT;
   \   00000062   0x20FF             MOVS     R0,#+255
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000068   0x7108             STRB     R0,[R1, #+4]
    502              G_stAntSetupData.AntDeviceType       = ANT_DEVICE_TYPE_DEFAULT;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000070   0x7148             STRB     R0,[R1, #+5]
    503              G_stAntSetupData.AntTransmissionType = ANT_TRANSMISSION_TYPE_DEFAULT;
   \   00000072   0x2010             MOVS     R0,#+16
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000078   0x7188             STRB     R0,[R1, #+6]
    504              G_stAntSetupData.AntChannelPeriodLo  = ANT_CHANNEL_PERIOD_LO_DEFAULT;
   \   0000007A   0x20CD             MOVS     R0,#+205
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000080   0x71C8             STRB     R0,[R1, #+7]
    505              G_stAntSetupData.AntChannelPeriodHi  = ANT_CHANNEL_PERIOD_HI_DEFAULT;
   \   00000082   0x200C             MOVS     R0,#+12
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000088   0x7208             STRB     R0,[R1, #+8]
    506              G_stAntSetupData.AntFrequency        = ANT_FREQUENCY_DEFAULT;
   \   0000008A   0x2037             MOVS     R0,#+55
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000090   0x7248             STRB     R0,[R1, #+9]
    507              G_stAntSetupData.AntTxPower          = ANT_TX_POWER_DEFAULT;
   \   00000092   0x2003             MOVS     R0,#+3
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000098   0x7288             STRB     R0,[R1, #+10]
    508              
    509              /* Configure the SSP resource to be used for the application */
    510              Ant_sSspConfig.SspPeripheral      = ANT_SPI;
   \   0000009A   0x2004             MOVS     R0,#+4
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
    511              Ant_sSspConfig.pCsGpioAddress     = ANT_SPI_CS_GPIO;
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x400e0e00
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   000000AA   0x6048             STR      R0,[R1, #+4]
    512              Ant_sSspConfig.u32CsPin           = ANT_SPI_CS_PIN;
   \   000000AC   0xF45F 0x0080      MOVS     R0,#+4194304
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   000000B4   0x6088             STR      R0,[R1, #+8]
    513              Ant_sSspConfig.BitOrder           = LSB_FIRST;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   000000BC   0x7308             STRB     R0,[R1, #+12]
    514              Ant_sSspConfig.SpiMode            = SPI_SLAVE_FLOW_CONTROL;
   \   000000BE   0x2002             MOVS     R0,#+2
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   000000C4   0x7348             STRB     R0,[R1, #+13]
    515              Ant_sSspConfig.fnSlaveTxFlowCallback = AntTxFlowControlCallback;
   \   000000C6   0x.... 0x....      ADR.W    R0,AntTxFlowControlCallback
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   000000CE   0x6108             STR      R0,[R1, #+16]
    516              Ant_sSspConfig.fnSlaveRxFlowCallback = AntRxFlowControlCallback;
   \   000000D0   0x.... 0x....      ADR.W    R0,AntRxFlowControlCallback
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   000000D8   0x6148             STR      R0,[R1, #+20]
    517              Ant_sSspConfig.pu8RxBufferAddress = Ant_au8AntRxBuffer;
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   000000E2   0x6188             STR      R0,[R1, #+24]
    518              Ant_sSspConfig.ppu8RxNextByte     = &Ant_pu8AntRxBufferNextChar;
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   000000EC   0x61C8             STR      R0,[R1, #+28]
    519              Ant_sSspConfig.u16RxBufferSize    = ANT_RX_BUFFER_SIZE;
   \   000000EE   0xF44F 0x7080      MOV      R0,#+256
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   000000F6   0x8408             STRH     R0,[R1, #+32]
    520          
    521              Ant_Ssp = SspRequest(&Ant_sSspConfig);
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   000000FC   0x.... 0x....      BL       SspRequest
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   00000104   0x6008             STR      R0,[R1, #+0]
    522              ANT_SSP_FLAGS = 0;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000010C   0x6008             STR      R0,[R1, #+0]
    523              
    524              /* Reset ANT, activate SPI interface and get a test message */
    525              AntSyncSerialInitialize();
   \   0000010E   0x.... 0x....      BL       AntSyncSerialInitialize
    526              
    527              /* Report status out the debug port */
    528              if(G_u32ApplicationFlags & _APPLICATION_FLAGS_ANT)  
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable20_11
   \   00000116   0x7800             LDRB     R0,[R0, #+0]
   \   00000118   0x06C0             LSLS     R0,R0,#+27
   \   0000011A   0xD517             BPL.N    ??AntInitialize_2
    529              {
    530                DebugPrintf(G_au8AntMessageOk);
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   00000120   0x.... 0x....      BL       DebugPrintf
    531                DebugPrintf(Ant_u8AntVersion);
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable20_13
   \   00000128   0x.... 0x....      BL       DebugPrintf
    532                DebugLineFeed();
   \   0000012C   0x.... 0x....      BL       DebugLineFeed
    533                
    534                G_u32AntFlags &= ~_ANT_FLAGS_RESTART;
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   0000013E   0x6008             STR      R0,[R1, #+0]
    535                Ant_pfnStateMachine = AntSM_Idle;
   \   00000140   0x.... 0x....      ADR.W    R0,AntSM_Idle
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000148   0x6008             STR      R0,[R1, #+0]
   \   0000014A   0xE020             B.N      ??AntInitialize_1
    536              }
    537              else
    538              {
    539                /* The ANT device is not responding -- it may be dead, or it may not yet
    540                be loaded with any firmware.  Regardless, float all of the interface lines so 
    541                that any programmer or other firmware will not be impacted by the Host MCU */
    542                DebugPrintf(G_au8AntMessageInitFail);
   \                     ??AntInitialize_2: (+1)
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable20_15
   \   00000150   0x.... 0x....      BL       DebugPrintf
    543          
    544                /* Make sure all ANT pins are on the PIO controller */
    545                u32AntPortAPins = ANT_PIOA_PINS;
   \   00000154   0xF05F 0x7030      MOVS     R0,#+46137344
   \   00000158   0x0004             MOVS     R4,R0
    546                u32AntPortBPins = ANT_PIOB_PINS;
   \   0000015A   0xF05F 0x70F0      MOVS     R0,#+31457280
   \   0000015E   0x0005             MOVS     R5,R0
    547                
    548                AT91C_BASE_PIOA->PIO_PDR = u32AntPortAPins;
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable20_16  ;; 0x400e0c04
   \   00000164   0x6004             STR      R4,[R0, #+0]
    549                AT91C_BASE_PIOA->PIO_PER = u32AntPortAPins;
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable20_17  ;; 0x400e0c00
   \   0000016A   0x6004             STR      R4,[R0, #+0]
    550                AT91C_BASE_PIOB->PIO_PDR = u32AntPortBPins;
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable20_18  ;; 0x400e0e04
   \   00000170   0x6005             STR      R5,[R0, #+0]
    551                AT91C_BASE_PIOB->PIO_PER = u32AntPortBPins;
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x400e0e00
   \   00000176   0x6005             STR      R5,[R0, #+0]
    552          
    553                /* Disable all outputs (set to HiZ input) */
    554                AT91C_BASE_PIOA->PIO_ODR = u32AntPortAPins;
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable20_19  ;; 0x400e0c14
   \   0000017C   0x6004             STR      R4,[R0, #+0]
    555                AT91C_BASE_PIOB->PIO_ODR = u32AntPortBPins;
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable20_20  ;; 0x400e0e14
   \   00000182   0x6005             STR      R5,[R0, #+0]
    556                
    557                Ant_pfnStateMachine = AntSM_NoResponse;
   \   00000184   0x.... 0x....      ADR.W    R0,AntSM_NoResponse
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000018C   0x6008             STR      R0,[R1, #+0]
    558              }
    559            }
    560          } /* end AntInitialize() */
   \                     ??AntInitialize_1: (+1)
   \   0000018E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    561          
    562          
    563          /*----------------------------------------------------------------------------------------------------------------------
    564          Function AntRunActiveState()
    565          
    566          Description:
    567          Selects and runs one iteration of the current state in the state machine.
    568          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    569          may take 1ms / n to execute.
    570          
    571          Requires:
    572            - State machine function pointer points at current state
    573          
    574          Promises:
    575            - Calls the function to pointed by the state machine function pointer
    576          */

   \                                 In section .text, align 2, keep-with-next
    577          void AntRunActiveState(void)
    578          {
   \                     AntRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    579            Ant_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    580          
    581          } /* end AntRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    582          
    583          
    584          /*-----------------------------------------------------------------------------
    585          Function: AntTxMessage
    586          
    587          Description:
    588          Send a message from the Host to the ANT device.  To do this, we must tell ANT that we have
    589          a message to send by asserting MRDY, wait for ANT to acknowlege with SEN, then read a byte from
    590          ANT to confirm the transmission can proceed.  If ANT happens to wants to send a message at the
    591          same time, the byte it sends will be an Rx byte so the AntTxMessage must suspend and go read the 
    592          incoming message first.  The process would restart after that.
    593          
    594          Once ANT confirms that the Host may transmit, the message to transmit is queued data is sent byte-by-byte with SRDY used for flow
    595          control after each byte.  Due to the speed of the chip-to-chip communications, even the longest ANT message
    596          should be able to send in less than 500us, so it is safe to run this function completely in one main loop
    597          iteration (and retry or additional messages should wait until the following cycle).  
    598          
    599          Adapted from Dynastream Innovations Inc reference design, BitSyncSerial.c.
    600          
    601          Requires:
    602            - pu8AntTxMessage_ points to an Ant formatted message where the first data byte
    603              is the length byte (since ANT sends the SYNC byte) and the last byte is
    604              the checksum.
    605          
    606          Promises:
    607            - Returns TRUE if the transmit message is queued successfully; Ant_u32CurrentTxMessageToken holds the message token
    608            - Returns FALSE if the transfer couldn't start or if receive message interrupted
    609              (G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set;  AntRxBufferCurrentChar pointing to the received byte).
    610            - MRDY is deasserted
    611          */

   \                                 In section .text, align 2, keep-with-next
    612          bool AntTxMessage(u8 *pu8AntTxMessage_)
    613          {
   \                     AntTxMessage: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB099             SUB      SP,SP,#+100
   \   00000004   0x0004             MOVS     R4,R0
    614            u8 u8Byte;
    615            u32 u32Length;
    616            u32 u32TimeOut = G_u32SystemTime1s;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20_21
   \   0000000A   0x6807             LDR      R7,[R0, #+0]
    617            u8 au8TxErrorMsg[] = "AntTx: msg already in progress\n\r";
   \   0000000C   0xA810             ADD      R0,SP,#+64
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable20_22
   \   00000012   0x2221             MOVS     R2,#+33
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy
    618            u8 au8TxTimeoutMsg[] = "AntTx: SEN timeout\n\r";
   \   00000018   0xA80A             ADD      R0,SP,#+40
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable20_23
   \   0000001E   0x2215             MOVS     R2,#+21
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
    619            u8 au8TxNoTokenMsg[] = "AntTx: No token\n\r";
   \   00000024   0xA805             ADD      R0,SP,#+20
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable20_24
   \   0000002A   0x2212             MOVS     R2,#+18
   \   0000002C   0x.... 0x....      BL       __aeabi_memcpy
    620            u8 au8TxNoSyncMsg[] = "AntTx: No SYNC\n\r";
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable20_25
   \   00000036   0x2211             MOVS     R2,#+17
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
    621          
    622            /* Check G_u32AntFlags first */
    623            if(G_u32AntFlags & (_ANT_FLAGS_TX_IN_PROGRESS | _ANT_FLAGS_RX_IN_PROGRESS) )
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF010 0x6F40      TST      R0,#0xC000000
   \   00000046   0xD004             BEQ.N    ??AntTxMessage_0
    624            {
    625              DebugPrintf(au8TxErrorMsg);
   \   00000048   0xA810             ADD      R0,SP,#+64
   \   0000004A   0x.... 0x....      BL       DebugPrintf
    626              return FALSE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE09A             B.N      ??AntTxMessage_1
    627            }
    628            
    629            /* Initialize the timeout timer and notify ANT that the Host wishes to send a message */
    630            Ant_u32RxTimer = 0;
   \                     ??AntTxMessage_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000058   0x6008             STR      R0,[R1, #+0]
    631            SYNC_MRDY_ASSERT();                          
   \   0000005A   0xF45F 0x0000      MOVS     R0,#+8388608
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x400e0e34
   \   00000062   0x6008             STR      R0,[R1, #+0]
    632          
    633            /* Wait for SEN to be asserted indicating ANT is ready for a message */
    634            while ( !IS_SEN_ASSERTED() && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_2: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x07C0             LSLS     R0,R0,#+31
   \   0000006C   0xD40E             BMI.N    ??AntTxMessage_3
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF242 0x7110      MOVW     R1,#+10000
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD207             BCS.N    ??AntTxMessage_3
    635            {
    636              Ant_u32RxTimer++;
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000088   0x6008             STR      R0,[R1, #+0]
   \   0000008A   0xE7EB             B.N      ??AntTxMessage_2
    637            }
    638            
    639            /* If we timed out, then clear MRDY and exit */
    640            if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntTxMessage_3: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0xF242 0x7111      MOVW     R1,#+10001
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD309             BCC.N    ??AntTxMessage_4
    641            {
    642              SYNC_MRDY_DEASSERT();                          
   \   0000009A   0xF45F 0x0000      MOVS     R0,#+8388608
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x400e0e30
   \   000000A2   0x6008             STR      R0,[R1, #+0]
    643              DebugPrintf(au8TxTimeoutMsg);
   \   000000A4   0xA80A             ADD      R0,SP,#+40
   \   000000A6   0x.... 0x....      BL       DebugPrintf
    644              return(FALSE);
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xE06C             B.N      ??AntTxMessage_1
    645            }
    646            
    647            /* Else we have SEN flag; queue to read 1 byte after a short delay before toggling SRDY */
    648            AntSrdyPulse();
   \                     ??AntTxMessage_4: (+1)
   \   000000AE   0x.... 0x....      BL       AntSrdyPulse
    649          
    650            /* Wait for the first byte to come in via the ISR / Rx Callback*/
    651            while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_5: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x0740             LSLS     R0,R0,#+29
   \   000000BA   0xD40E             BMI.N    ??AntTxMessage_6
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF242 0x7110      MOVW     R1,#+10000
   \   000000C6   0x4288             CMP      R0,R1
   \   000000C8   0xD207             BCS.N    ??AntTxMessage_6
    652            {
    653              Ant_u32RxTimer++;
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x1C40             ADDS     R0,R0,#+1
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000D6   0x6008             STR      R0,[R1, #+0]
   \   000000D8   0xE7EB             B.N      ??AntTxMessage_5
    654            }
    655          
    656            /* Ok to deassert MRDY now */
    657            SYNC_MRDY_DEASSERT();                     
   \                     ??AntTxMessage_6: (+1)
   \   000000DA   0xF45F 0x0000      MOVS     R0,#+8388608
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x400e0e30
   \   000000E2   0x6008             STR      R0,[R1, #+0]
    658          
    659            /* If we timed out now, then clear MRDY and exit.  Because CS is still asserted, the task
    660            will attempt to read a message but fail and eventually abort. */
    661            if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0xF242 0x7111      MOVW     R1,#+10001
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xD304             BCC.N    ??AntTxMessage_7
    662            {
    663             DebugPrintf(au8TxTimeoutMsg);
   \   000000F2   0xA80A             ADD      R0,SP,#+40
   \   000000F4   0x.... 0x....      BL       DebugPrintf
    664             return(FALSE);
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xE045             B.N      ??AntTxMessage_1
    665            }
    666                    
    667            /* When the byte comes in, the SSP module will set the _SSP_RX_COMPLETE flag and also call the 
    668            Rx callback but does not toggle SRDY at this time.  We must look at this byte to determine if ANT 
    669            initiated this particular communication and is telling us that a message is coming in, or if we 
    670            initiated the communication and ANT is allowing us to transmit. */
    671          
    672            /* Read the byte - don't advance the pointer yet */
    673            u8Byte = *Ant_pu8AntRxBufferCurrentChar;                       
   \                     ??AntTxMessage_7: (+1)
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0x7800             LDRB     R0,[R0, #+0]
   \   00000104   0x0005             MOVS     R5,R0
    674          
    675            /* If the byte is TX_SYNC, then ANT wants to send a message which must be done first */
    676            if (u8Byte == MESG_TX_SYNC)                     
   \   00000106   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000108   0x2DA4             CMP      R5,#+164
   \   0000010A   0xD109             BNE.N    ??AntTxMessage_8
    677            {
    678              G_u32AntFlags |= _ANT_FLAGS_TX_INTERRUPTED;
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   0000011A   0x6008             STR      R0,[R1, #+0]
    679              return(FALSE);
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0xE033             B.N      ??AntTxMessage_1
    680            }
    681          
    682            /* Since the Rx byte is in our Rx buffer, advance both pointers since it's not an incoming message */
    683            AdvanceAntRxBufferCurrentChar();
   \                     ??AntTxMessage_8: (+1)
   \   00000120   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    684            AdvanceAntRxBufferUnreadMsgPointer();
   \   00000124   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
    685          
    686            /* Clear the status flag and process the byte */
    687            ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE; /* !!!!! Odd for this to be here, but maybe it needs to be */
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000136   0x6008             STR      R0,[R1, #+0]
    688            
    689            /* If the byte is RX_SYNC, then proceed to send the message */
    690            if (u8Byte == MESG_RX_SYNC)                     
   \   00000138   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000013A   0x2DA5             CMP      R5,#+165
   \   0000013C   0xD120             BNE.N    ??AntTxMessage_9
    691            {
    692              /* Flag that a transmit is in progress */
    693              G_u32AntFlags |= _ANT_FLAGS_TX_IN_PROGRESS;
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   00000142   0x6800             LDR      R0,[R0, #+0]
   \   00000144   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   0000014C   0x6008             STR      R0,[R1, #+0]
    694              
    695              /* Read the message length and add three for the length, message ID and checksum */
    696              u32Length = (u32)(pu8AntTxMessage_[0] + 3); 
   \   0000014E   0x7820             LDRB     R0,[R4, #+0]
   \   00000150   0x1CC0             ADDS     R0,R0,#+3
   \   00000152   0x0006             MOVS     R6,R0
    697              
    698              /* Queue the message to the peripheral and capture the token */ 
    699              Ant_u32CurrentTxMessageToken = SspWriteData(Ant_Ssp, u32Length, pu8AntTxMessage_);
   \   00000154   0x0022             MOVS     R2,R4
   \   00000156   0x0031             MOVS     R1,R6
   \   00000158   0x.... 0x....      LDR.W    R0,??DataTable20_10
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0x.... 0x....      BL       SspWriteData
   \   00000162   0x.... 0x....      LDR.W    R1,??DataTable20_26
   \   00000166   0x6008             STR      R0,[R1, #+0]
    700          
    701              /* Return TRUE only if we received a message token indicating the message has been queued */
    702              if(Ant_u32CurrentTxMessageToken != 0)
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable20_26
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0x2800             CMP      R0,#+0
   \   00000170   0xD001             BEQ.N    ??AntTxMessage_10
    703              {
    704                return(TRUE);
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0xE008             B.N      ??AntTxMessage_1
    705              }
    706              else
    707              {
    708                DebugPrintf(au8TxNoTokenMsg);
   \                     ??AntTxMessage_10: (+1)
   \   00000176   0xA805             ADD      R0,SP,#+20
   \   00000178   0x.... 0x....      BL       DebugPrintf
    709                return(FALSE);
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0xE003             B.N      ??AntTxMessage_1
    710              }
    711            }
    712          
    713            /* If we get here, not a sync byte, so return */
    714            DebugPrintf(au8TxNoSyncMsg);
   \                     ??AntTxMessage_9: (+1)
   \   00000180   0xA800             ADD      R0,SP,#+0
   \   00000182   0x.... 0x....      BL       DebugPrintf
    715            return(FALSE);
   \   00000186   0x2000             MOVS     R0,#+0
   \                     ??AntTxMessage_1: (+1)
   \   00000188   0xB019             ADD      SP,SP,#+100
   \   0000018A   0xBDF0             POP      {R4-R7,PC}       ;; return
    716          
    717          } /* end AntTxMessage() */
    718          
    719          
    720          /*------------------------------------------------------------------------------
    721          Function: AntExpectResponse
    722          
    723          Description:
    724          Waits a specified amount of time for a particular message to arrive from ANT in 
    725          response to a message sent to ANT.  
    726          
    727          *** This function violates the 1ms system rule, so should only be used during initialization. ***
    728            
    729          Requires:
    730            - u8ExpectedMessageID_ is the ID of a message to which a response is expected
    731            - u32TimeoutMS_ is the maximum value in ms to wait for the response 
    732            - A message had been sent to ANT to which a response should be coming in
    733            - Ant_u8AntNewRxMessages == 0 as this function is meant to run one-to-one with
    734              transmitted messages.
    735            - SSP task should be in manual mode so it is busy sending the Tx message to which
    736              this function will wait for the ANT response.
    737          
    738          Promises:
    739            - Returns 0 if the message is received and was successful
    740            - Returns 1 if a response is never received or if the response indicates the
    741              message was not successful.
    742          */

   \                                 In section .text, align 2, keep-with-next
    743          u8 AntExpectResponse(u8 u8ExpectedMessageID_, u32 u32TimeoutMS_) 
    744          {
   \                     AntExpectResponse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    745            bool bTimeout = FALSE;
   \   00000008   0x2600             MOVS     R6,#+0
    746            u8 u8ReturnValue = 1;
   \   0000000A   0x2701             MOVS     R7,#+1
    747            u32 u32StartTime = G_u32SystemTime1s;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable20_21
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x9000             STR      R0,[SP, #+0]
    748            u8 au8AntExpectMsgFail[] = "\r\nANT expected msg fail\n\r";
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable20_27
   \   0000001A   0x221A             MOVS     R2,#+26
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy
    749          
    750            /* Wait for current message to send */
    751            u32StartTime = G_u32SystemTime1ms;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x9000             STR      R0,[SP, #+0]
    752            while( IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_0: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x07C0             LSLS     R0,R0,#+31
   \   00000030   0xD509             BPL.N    ??AntExpectResponse_1
   \   00000032   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD106             BNE.N    ??AntExpectResponse_1
    753            {
    754              bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \   00000038   0xF44F 0x717A      MOV      R1,#+1000
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       IsTimeUp
   \   00000042   0x0006             MOVS     R6,R0
   \   00000044   0xE7F0             B.N      ??AntExpectResponse_0
    755            }
    756          
    757            if( !bTimeout )
   \                     ??AntExpectResponse_1: (+1)
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD120             BNE.N    ??AntExpectResponse_2
    758            {
    759              /* Done with this message token, so it can be cleared */
    760              G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF030 0x6000      BICS     R0,R0,#0x8000000
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    761              AntDeQueueOutgoingMessage();
   \   0000005C   0x.... 0x....      BL       AntDeQueueOutgoingMessage
    762              Ant_u32CurrentTxMessageToken = 0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable20_26
   \   00000066   0x6008             STR      R0,[R1, #+0]
    763              
    764              /* Wait for SEN */
    765              u32StartTime = G_u32SystemTime1ms;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x9000             STR      R0,[SP, #+0]
    766              while( !IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_3: (+1)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x07C0             LSLS     R0,R0,#+31
   \   00000078   0xD409             BMI.N    ??AntExpectResponse_2
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD106             BNE.N    ??AntExpectResponse_2
    767              {
    768                bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \   00000080   0xF44F 0x717A      MOV      R1,#+1000
   \   00000084   0xA800             ADD      R0,SP,#+0
   \   00000086   0x.... 0x....      BL       IsTimeUp
   \   0000008A   0x0006             MOVS     R6,R0
   \   0000008C   0xE7F0             B.N      ??AntExpectResponse_3
    769              }
    770            }
    771            
    772            /* If no timeout then read the incoming message */
    773            if( !bTimeout )
   \                     ??AntExpectResponse_2: (+1)
   \   0000008E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000090   0x2E00             CMP      R6,#+0
   \   00000092   0xD11B             BNE.N    ??AntExpectResponse_4
    774            {
    775              AntRxMessage();
   \   00000094   0x.... 0x....      BL       AntRxMessage
    776          
    777              /* If there is a new message in the receive buffer, then check that it is a response to the expected
    778              message and that the response is no error */
    779              if(Ant_u8AntNewRxMessages)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD014             BEQ.N    ??AntExpectResponse_4
    780              {
    781                /* Check if the response is an Event, the event is a reply to the expected message, and the reply is good.
    782                Since Ant_pu8AntRxBufferUnreadMsg is pointing to the SYNC byte, add 1 when using BUFFER_INDEX values. */
    783                if( (*(Ant_pu8AntRxBufferUnreadMsg + MESG_ID_OFFSET) == MESG_RESPONSE_EVENT_ID) &&    
    784                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_MESG_ID_OFFSET) == u8ExpectedMessageID_) &&
    785                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_CODE_OFFSET) == RESPONSE_NO_ERROR) )
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0x7880             LDRB     R0,[R0, #+2]
   \   000000AA   0x2840             CMP      R0,#+64
   \   000000AC   0xD10E             BNE.N    ??AntExpectResponse_4
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x7900             LDRB     R0,[R0, #+4]
   \   000000B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B8   0x42A0             CMP      R0,R4
   \   000000BA   0xD107             BNE.N    ??AntExpectResponse_4
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0x7940             LDRB     R0,[R0, #+5]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD101             BNE.N    ??AntExpectResponse_4
    786                {
    787                  u8ReturnValue = 0;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x0007             MOVS     R7,R0
    788                }
    789              }
    790            }
    791            
    792            /* Process any message in the RxBuffer and return the result value */
    793            AntProcessMessage();
   \                     ??AntExpectResponse_4: (+1)
   \   000000CC   0x.... 0x....      BL       AntProcessMessage
    794            
    795            if( bTimeout )
   \   000000D0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D2   0x2E00             CMP      R6,#+0
   \   000000D4   0xD002             BEQ.N    ??AntExpectResponse_5
    796            {
    797              DebugPrintf(au8AntExpectMsgFail);
   \   000000D6   0xA801             ADD      R0,SP,#+4
   \   000000D8   0x.... 0x....      BL       DebugPrintf
    798              /* !!!! What clean-up should be done here?  Reset ANT and restart init? */
    799            }
    800          
    801            return(u8ReturnValue);
   \                     ??AntExpectResponse_5: (+1)
   \   000000DC   0x0038             MOVS     R0,R7
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0xB009             ADD      SP,SP,#+36
   \   000000E2   0xBDF0             POP      {R4-R7,PC}       ;; return
    802          
    803          } /* end AntExpectResponse */
    804          
    805          
    806          /*-----------------------------------------------------------------------------
    807          Function: AntTxFlowControlCallback
    808          
    809          Description:
    810          Callback function to toggle flow control during transmission.  The peripheral task
    811          sending the message must invoke this function after each byte.  
    812          
    813          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    814          
    815          Requires:
    816            - 
    817          
    818          Promises:
    819            - SRDY is toggled
    820            - Ant_u32TxByteCounter incremented
    821          */
    822          

   \                                 In section .text, align 4, keep-with-next
    823          void AntTxFlowControlCallback(void)
    824          {
   \                     AntTxFlowControlCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    825            /* Count the byte and toggle flow control lines */
    826            Ant_u32TxByteCounter++; 
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_28
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable20_28
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    827            AntSrdyPulse();
   \   00000010   0x.... 0x....      BL       AntSrdyPulse
    828          
    829          } /* end AntTxFlowControlCallback() */
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    830          
    831          
    832          /*-----------------------------------------------------------------------------
    833          Function: AntRxFlowControlCallback
    834          
    835          Description:
    836          Callback function to toggle flow control during reception.  The peripheral task
    837          receiving the message must invoke this function after each byte.  
    838          
    839          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    840          Unfortunately, AntSrdyPulse() takes some time but the duty cycle of this interrupt
    841          is low enough that we can survive (this interrupt priority could be dropped below everything
    842          else to mitigate any issues).
    843          
    844          Requires:
    845            - ISRs are off already since this is totally not re-entrant
    846            - A received byte was just written to the Rx buffer
    847            - _SSP_CS_ASSERTED in correct state: should be set on first byte, but application should 
    848              clear it for all subsequent bytes so flow control is handled entirely by this function
    849          
    850          Promises:
    851            - Ant_pu8AntRxBufferNextChar is advanced safely so it is ready to receive the next byte
    852            - Ant_u32RxByteCounter incremented
    853            - SRDY is toggled if _ANT_FLAGS_RX_IN_PROGRESS is set
    854          */

   \                                 In section .text, align 4, keep-with-next
    855          void AntRxFlowControlCallback(void)
    856          {
   \                     AntRxFlowControlCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    857            /* Count the byte and safely advance the receive buffer pointer; this is called from the
    858            RX ISR, so it won't be interrupted and break Ant_pu8AntRxBufferNextChar */
    859            Ant_u32RxByteCounter++;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    860            Ant_pu8AntRxBufferNextChar++;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    861            if(Ant_pu8AntRxBufferNextChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD104             BNE.N    ??AntRxFlowControlCallback_0
    862            {
    863              Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   00000034   0x6008             STR      R0,[R1, #+0]
    864            }
    865            
    866            /* Only toggle SRDY if a reception is flagged in progress */
    867            if( G_u32AntFlags & _ANT_FLAGS_RX_IN_PROGRESS )
   \                     ??AntRxFlowControlCallback_0: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0140             LSLS     R0,R0,#+5
   \   0000003E   0xD501             BPL.N    ??AntRxFlowControlCallback_1
    868            {
    869              AntSrdyPulse();
   \   00000040   0x.... 0x....      BL       AntSrdyPulse
    870            }
    871            
    872          } /* end AntRxFlowControlCallback() */
   \                     ??AntRxFlowControlCallback_1: (+1)
   \   00000044   0xBD01             POP      {R0,PC}          ;; return
    873          
    874          
    875          /*------------------------------------------------------------------------------
    876          Function: AntCalculateTxChecksum
    877          
    878          Description:
    879          Calculates and returns the checksum for a Host > ANT message.
    880          
    881          Requires:
    882            - pu8Message_ points to the message to transmit
    883            - the message to transmit is a complete ANT message except the SYNC byte (starts with length byte)
    884          
    885          Promises:
    886            - Finds ANT checksum for the message and returns it
    887          */

   \                                 In section .text, align 2, keep-with-next
    888          u8 AntCalculateTxChecksum(u8* pu8Message_)
    889          {
   \                     AntCalculateTxChecksum: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    890            u8 u8Size = *pu8Message_ + 2;
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0x1C82             ADDS     R2,R0,#+2
    891            u8 u8Checksum = MESG_RX_SYNC;
   \   00000008   0x20A5             MOVS     R0,#+165
    892            
    893            for(u8 i = 0; i < u8Size; i++)
   \   0000000A   0x2300             MOVS     R3,#+0
   \                     ??AntCalculateTxChecksum_0: (+1)
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x4293             CMP      R3,R2
   \   00000012   0xD204             BCS.N    ??AntCalculateTxChecksum_1
    894            {
    895              u8Checksum ^= *pu8Message_;
   \   00000014   0x780C             LDRB     R4,[R1, #+0]
   \   00000016   0x4060             EORS     R0,R4,R0
    896              pu8Message_++;
   \   00000018   0x1C49             ADDS     R1,R1,#+1
    897            }
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
   \   0000001C   0xE7F6             B.N      ??AntCalculateTxChecksum_0
    898            
    899            return(u8Checksum);
   \                     ??AntCalculateTxChecksum_1: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    900            
    901          } /* end AntCalculateTxChecksum() */
    902          
    903          
    904          /*-----------------------------------------------------------------------------/
    905          Function: AntQueueOutgoingMessage
    906          
    907          Description:
    908          Creates a new ANT message structure and adds it into Ant_psDataOutgoingMsgList.
    909          If the list is full, the message is not added.
    910          
    911          Requires:
    912            - pu8Message_ is an ANT-formatted message starting with LENGTH and ending with CHECKSUM
    913            - Enough space is available on the heap
    914          
    915          Promises:
    916            - A new list item in the outgoing message linked list is created and inserted at the end
    917              of the list as long as there is enough room.
    918            - Returns TRUE if the entry is added successfully.
    919            - Returns FALSE on error.
    920          */

   \                                 In section .text, align 2, keep-with-next
    921          bool AntQueueOutgoingMessage(u8 *pu8Message_)
    922          {
   \                     AntQueueOutgoingMessage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0004             MOVS     R4,R0
    923            u8 u8Length;
    924            u8 u8MessageCount = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    925            AntOutgoingMessageListType *psNewDataMessage;
    926            AntOutgoingMessageListType *psListParser;
    927            u8 au8AddMessageFailMsg[] = "\n\rNo space in AntQueueOutgoingMessage\n\r";
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable20_29
   \   00000010   0x2228             MOVS     R2,#+40
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy4
    928            
    929            Ant_DebugQueuedDataMessages++;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable20_30
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable20_30
   \   00000022   0x6008             STR      R0,[R1, #+0]
    930          
    931            /* Allocate space for the new message - always do maximum message size */
    932            psNewDataMessage = malloc( sizeof(AntOutgoingMessageListType) );
   \   00000024   0x201C             MOVS     R0,#+28
   \   00000026   0x.... 0x....      BL       malloc
   \   0000002A   0x0007             MOVS     R7,R0
    933            if (psNewDataMessage == NULL)
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD104             BNE.N    ??AntQueueOutgoingMessage_0
    934            {
    935              DebugPrintf(au8AddMessageFailMsg);
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      BL       DebugPrintf
    936              return(FALSE);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE043             B.N      ??AntQueueOutgoingMessage_1
    937            }
    938            
    939            /* Fill in all the fields of the newly allocated message structure */
    940            u8Length = *pu8Message_ + 3;
   \                     ??AntQueueOutgoingMessage_0: (+1)
   \   0000003A   0x7820             LDRB     R0,[R4, #+0]
   \   0000003C   0x1CC0             ADDS     R0,R0,#+3
   \   0000003E   0x0005             MOVS     R5,R0
    941            for(u8 i = 0; i < u8Length; i++)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??AntQueueOutgoingMessage_2: (+1)
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x42A8             CMP      R0,R5
   \   00000048   0xD206             BCS.N    ??AntQueueOutgoingMessage_3
    942            {
    943              psNewDataMessage->au8MessageData[i] = *(pu8Message_ + i);
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x5D01             LDRB     R1,[R0, R4]
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x19C2             ADDS     R2,R0,R7
   \   00000052   0x7111             STRB     R1,[R2, #+4]
    944            }
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0xE7F4             B.N      ??AntQueueOutgoingMessage_2
    945            
    946            psNewDataMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueOutgoingMessage_3: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x6038             STR      R0,[R7, #+0]
    947            psNewDataMessage->psNextMessage = NULL;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x61B8             STR      R0,[R7, #+24]
    948          
    949            /* Insert into an empty list */
    950            if(Ant_psDataOutgoingMsgList == NULL)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD10A             BNE.N    ??AntQueueOutgoingMessage_4
    951            {
    952              Ant_psDataOutgoingMsgList = psNewDataMessage;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000072   0x6007             STR      R7,[R0, #+0]
    953              Ant_u32OutgoingMessageCount++;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable20_31
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable20_31
   \   00000080   0x6008             STR      R0,[R1, #+0]
   \   00000082   0xE01D             B.N      ??AntQueueOutgoingMessage_5
    954            }
    955          
    956            /* Otherwise traverse the list to find the end where the new message will be inserted */
    957            else
    958            {
    959              psListParser = Ant_psDataOutgoingMsgList;
   \                     ??AntQueueOutgoingMessage_4: (+1)
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x4680             MOV      R8,R0
    960              while(psListParser->psNextMessage != NULL)  
   \                     ??AntQueueOutgoingMessage_6: (+1)
   \   0000008C   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD003             BEQ.N    ??AntQueueOutgoingMessage_7
    961              {
    962                psListParser = psListParser->psNextMessage;
   \   00000094   0xF8D8 0x8018      LDR      R8,[R8, #+24]
    963                u8MessageCount++;
   \   00000098   0x1C76             ADDS     R6,R6,#+1
   \   0000009A   0xE7F7             B.N      ??AntQueueOutgoingMessage_6
    964              }
    965              
    966              /* Check for a full list */
    967              if(u8MessageCount < ANT_OUTGOING_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueOutgoingMessage_7: (+1)
   \   0000009C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009E   0x2E20             CMP      R6,#+32
   \   000000A0   0xD209             BCS.N    ??AntQueueOutgoingMessage_8
    968              {
    969                /* Insert the new message at the end of the list */
    970                psListParser->psNextMessage = psNewDataMessage;
   \   000000A2   0xF8C8 0x7018      STR      R7,[R8, #+24]
    971                Ant_u32OutgoingMessageCount++;
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable20_31
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable20_31
   \   000000B2   0x6008             STR      R0,[R1, #+0]
   \   000000B4   0xE004             B.N      ??AntQueueOutgoingMessage_5
    972              }
    973              else
    974              {
    975                DebugPrintf(au8AddMessageFailMsg);
   \                     ??AntQueueOutgoingMessage_8: (+1)
   \   000000B6   0xA800             ADD      R0,SP,#+0
   \   000000B8   0x.... 0x....      BL       DebugPrintf
    976                return(FALSE);
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xE000             B.N      ??AntQueueOutgoingMessage_1
    977              }
    978            }
    979              
    980            return(TRUE);
   \                     ??AntQueueOutgoingMessage_5: (+1)
   \   000000C0   0x2001             MOVS     R0,#+1
   \                     ??AntQueueOutgoingMessage_1: (+1)
   \   000000C2   0xB00A             ADD      SP,SP,#+40
   \   000000C4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    981            
    982          } /* end AntQueueOutgoingMessage() */
    983          
    984          
    985          /*-----------------------------------------------------------------------------/
    986          Function: AntDeQueueApplicationMessage
    987          
    988          Description:
    989          Releases the first message in G_sAntApplicationMsgList 
    990          
    991          Requires:
    992            - G_sAntApplicationMsgList points to the start of the list which is the entry to remove
    993          
    994          Promises:
    995            - G_sAntApplicationMsgList = G_sAntApplicationMsgList.
    996          */

   \                                 In section .text, align 2, keep-with-next
    997          void AntDeQueueApplicationMessage(void)
    998          {
   \                     AntDeQueueApplicationMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    999            AntApplicationMsgListType *psMessageToKill;
   1000            
   1001            if(G_sAntApplicationMsgList != NULL)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD014             BEQ.N    ??AntDeQueueApplicationMessage_0
   1002            {
   1003              psMessageToKill = G_sAntApplicationMsgList;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x0004             MOVS     R4,R0
   1004              G_sAntApplicationMsgList = G_sAntApplicationMsgList->psNextMessage;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x6900             LDR      R0,[R0, #+16]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable20_6
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1005          
   1006              /* The doomed message is properly disconnected, so kill it */
   1007              free(psMessageToKill);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       free
   1008              Ant_u32ApplicationMessageCount--;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable20_32
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable20_32
   \   00000034   0x6008             STR      R0,[R1, #+0]
   1009            }
   1010            
   1011          } /* end AntDeQueueApplicationMessage() */
   \                     ??AntDeQueueApplicationMessage_0: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1012          
   1013          
   1014          /* ANT private Interface-layer Functions */
   1015          
   1016                                              
   1017          /*------------------------------------------------------------------------------
   1018          Function: AntProcessMessage
   1019          
   1020          Description:
   1021          Reads the lastest received Ant message and updates system information accordingly. 
   1022            
   1023          Requires:
   1024            - Ant_u8AntNewRxMessages holds the number of unprocessed messages in the message queue
   1025            - GGpu8AntRxBufferUnreadMsg points to the first byte of an unread verified ANT message
   1026          
   1027          Promises:
   1028            - Returns 1 if Ant_u8AntNewRxMessages == 0
   1029            - Otherwise, returns 0 and:
   1030              - Ant_u8AntNewRxMessages--
   1031              - GGpu8AntRxBufferUnreadMsg points to the first byte of the next unread verified ANT message
   1032              - System flags are updated
   1033          */

   \                                 In section .text, align 2, keep-with-next
   1034          static u8 AntProcessMessage(void)
   1035          {
   \                     AntProcessMessage: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1036            u8 u8MessageLength;
   1037            u8 au8MessageCopy[MESG_MAX_SIZE];
   1038            
   1039             /* Exit immediately if there are no messages in the RxBuffer */
   1040          	if (!Ant_u8AntNewRxMessages)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??AntProcessMessage_0
   1041              return(1);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE136             B.N      ??AntProcessMessage_1
   1042            
   1043            Ant_DebugProcessRxMessages++;
   \                     ??AntProcessMessage_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable20_33
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable20_33
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1044            
   1045            /* Otherwise decrement counter, and get a copy of the message (necessary since the rx buffer is circular)
   1046            and we want to index the various bytes using the ANT byte definitions. */  
   1047            Ant_u8AntNewRxMessages--;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   1048            AdvanceAntRxBufferUnreadMsgPointer();
   \   0000002E   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1049            u8MessageLength = *Ant_pu8AntRxBufferUnreadMsg;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x0004             MOVS     R4,R0
   1050            
   1051            /* Check to ensure the message size is legit.  !!!!! Clean up pointers if not */
   1052            if(u8MessageLength > MESG_MAX_SIZE)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C12             CMP      R4,#+18
   \   00000040   0xDB01             BLT.N    ??AntProcessMessage_2
   1053            {
   1054              return(1);
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE11C             B.N      ??AntProcessMessage_1
   1055            }
   1056            
   1057            /* Copy the message so it can be indexed easily */ 
   1058            for(u8 i = 0; i < (u8MessageLength + MESG_FRAME_SIZE - MESG_SYNC_SIZE); i++)
   \                     ??AntProcessMessage_2: (+1)
   \   00000046   0x2500             MOVS     R5,#+0
   \                     ??AntProcessMessage_3: (+1)
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0x1CE0             ADDS     R0,R4,#+3
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xDA0A             BGE.N    ??AntProcessMessage_4
   1059            {
   1060              au8MessageCopy[i] = *Ant_pu8AntRxBufferUnreadMsg;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0xA900             ADD      R1,SP,#+0
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x5468             STRB     R0,[R5, R1]
   1061              AdvanceAntRxBufferUnreadMsgPointer();
   \   00000060   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1062            }
   \   00000064   0x1C6D             ADDS     R5,R5,#+1
   \   00000066   0xE7EF             B.N      ??AntProcessMessage_3
   1063            /* Note: Ant_pu8AntRxBufferUnreadMsg is now pointing at the next unread message */
   1064            
   1065            /* Decide what to do based on the Message ID */
   1066            switch( au8MessageCopy[BUFFER_INDEX_MESG_ID] )
   \                     ??AntProcessMessage_4: (+1)
   \   00000068   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000006C   0x283E             CMP      R0,#+62
   \   0000006E   0xF000 0x80E5      BEQ.W    ??AntProcessMessage_5
   \   00000072   0x2840             CMP      R0,#+64
   \   00000074   0xD00C             BEQ.N    ??AntProcessMessage_6
   \   00000076   0x284E             CMP      R0,#+78
   \   00000078   0xF000 0x80D2      BEQ.W    ??AntProcessMessage_7
   \   0000007C   0x284F             CMP      R0,#+79
   \   0000007E   0xF000 0x80C2      BEQ.W    ??AntProcessMessage_8
   \   00000082   0x2852             CMP      R0,#+82
   \   00000084   0xF000 0x80D9      BEQ.W    ??AntProcessMessage_9
   \   00000088   0x286F             CMP      R0,#+111
   \   0000008A   0xF000 0x80EB      BEQ.W    ??AntProcessMessage_10
   \   0000008E   0xE0F0             B.N      ??AntProcessMessage_11
   1067            {
   1068              case MESG_RESPONSE_EVENT_ID:
   1069              { 
   1070                /* Channel Message received: it is a Channel Response or Channel Event */
   1071                if( au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] != MESG_EVENT_ID )
   \                     ??AntProcessMessage_6: (+1)
   \   00000090   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD059             BEQ.N    ??AntProcessMessage_12
   1072                {
   1073                  /* We have a Channel Response: parse it out based on the message ID to which the response applies */
   1074                  switch(au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID])
   \   00000098   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000009C   0x2841             CMP      R0,#+65
   \   0000009E   0xD02D             BEQ.N    ??AntProcessMessage_13
   \   000000A0   0x2842             CMP      R0,#+66
   \   000000A2   0xD026             BEQ.N    ??AntProcessMessage_14
   \   000000A4   0x284B             CMP      R0,#+75
   \   000000A6   0xD002             BEQ.N    ??AntProcessMessage_15
   \   000000A8   0x284C             CMP      R0,#+76
   \   000000AA   0xD015             BEQ.N    ??AntProcessMessage_16
   \   000000AC   0xE034             B.N      ??AntProcessMessage_17
   1075                  {
   1076                    case MESG_OPEN_CHANNEL_ID:
   1077                      DebugPrintf(G_au8AntMessageOpen);
   \                     ??AntProcessMessage_15: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable20_34
   \   000000B2   0x.... 0x....      BL       DebugPrintf
   1078                      G_u32AntFlags |= _ANT_FLAGS_CHANNEL_OPEN;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   000000C4   0x6008             STR      R0,[R1, #+0]
   1079                      G_u32AntFlags &= ~_ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   000000D4   0x6008             STR      R0,[R1, #+0]
   1080                      break;
   \   000000D6   0xE023             B.N      ??AntProcessMessage_18
   1081          
   1082                    case MESG_CLOSE_CHANNEL_ID:
   1083                      DebugPrintf(G_au8AntMessageClose);
   \                     ??AntProcessMessage_16: (+1)
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable20_35
   \   000000DC   0x.... 0x....      BL       DebugPrintf
   1084                      G_u32AntFlags &= ~(_ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN);
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF430 0x10C0      BICS     R0,R0,#0x180000
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   000000EE   0x6008             STR      R0,[R1, #+0]
   1085                      break;
   \   000000F0   0xE016             B.N      ??AntProcessMessage_18
   1086          
   1087                    case MESG_ASSIGN_CHANNEL_ID:
   1088                      DebugPrintf(G_au8AntMessageAssign);
   \                     ??AntProcessMessage_14: (+1)
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable20_36
   \   000000F6   0x.... 0x....      BL       DebugPrintf
   1089                      break;
   \   000000FA   0xE011             B.N      ??AntProcessMessage_18
   1090          
   1091                    case MESG_UNASSIGN_CHANNEL_ID:
   1092                      DebugPrintf(G_au8AntMessageUnassign);
   \                     ??AntProcessMessage_13: (+1)
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable20_37
   \   00000100   0x.... 0x....      BL       DebugPrintf
   1093                      G_u32AntFlags &= ~(ANT_CONFIGURED | _ANT_FLAGS_CHANNEL_OPEN_PENDING | _ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN);
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable20_38  ;; 0xffe3fffe
   \   0000010E   0x4008             ANDS     R0,R1,R0
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   00000114   0x6008             STR      R0,[R1, #+0]
   1094                      break;
   \   00000116   0xE003             B.N      ??AntProcessMessage_18
   1095           
   1096                    default:
   1097                      DebugPrintf(G_au8AntMessageUnhandled);
   \                     ??AntProcessMessage_17: (+1)
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable20_39
   \   0000011C   0x.... 0x....      BL       DebugPrintf
   1098                      break;
   1099                  } /* end switch */
   1100                  
   1101                  /* All messages print an "ok" or "fail" */
   1102                  if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR ) 
   \                     ??AntProcessMessage_18: (+1)
   \   00000120   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD104             BNE.N    ??AntProcessMessage_19
   1103                  {
   1104                    DebugPrintf(G_au8AntMessageOk);
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   0000012C   0x.... 0x....      BL       DebugPrintf
   \   00000130   0xE068             B.N      ??AntProcessMessage_20
   1105                  }
   1106                  else
   1107                  {
   1108                    DebugPrintf(G_au8AntMessageFail);
   \                     ??AntProcessMessage_19: (+1)
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable20_40
   \   00000136   0x.... 0x....      BL       DebugPrintf
   1109                    G_u32AntFlags |= _ANT_FLAGS_CMD_ERROR;
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   00000148   0x6008             STR      R0,[R1, #+0]
   \   0000014A   0xE05B             B.N      ??AntProcessMessage_20
   1110                  }
   1111          
   1112                }
   1113                else /* The message is a Channel Event, so the Event Code must be parsed out */
   1114                { 
   1115                  switch ( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] )
   \                     ??AntProcessMessage_12: (+1)
   \   0000014C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD00A             BEQ.N    ??AntProcessMessage_21
   \   00000154   0x2802             CMP      R0,#+2
   \   00000156   0xD009             BEQ.N    ??AntProcessMessage_22
   \   00000158   0x2803             CMP      R0,#+3
   \   0000015A   0xD02A             BEQ.N    ??AntProcessMessage_23
   \   0000015C   0x2805             CMP      R0,#+5
   \   0000015E   0xD030             BEQ.N    ??AntProcessMessage_24
   \   00000160   0x2806             CMP      R0,#+6
   \   00000162   0xD03A             BEQ.N    ??AntProcessMessage_25
   \   00000164   0x2807             CMP      R0,#+7
   \   00000166   0xD03C             BEQ.N    ??AntProcessMessage_26
   \   00000168   0xE044             B.N      ??AntProcessMessage_27
   1116                  {
   1117                    case RESPONSE_NO_ERROR: 
   1118                    {
   1119                      break;
   \                     ??AntProcessMessage_21: (+1)
   \   0000016A   0xE04B             B.N      ??AntProcessMessage_20
   1120                    }
   1121          
   1122                    case EVENT_RX_FAIL: /* slave did not receive a message when expected */
   1123                    {
   1124                      /* The slave missed a message it was expecting: communicate this to the
   1125                      application in case it matters. Could also queue a debug message here. */
   1126                      if(++Ant_u8SlaveMissedMessageLow == 0)
   \                     ??AntProcessMessage_22: (+1)
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable20_41
   \   00000170   0x7800             LDRB     R0,[R0, #+0]
   \   00000172   0x1C40             ADDS     R0,R0,#+1
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable20_41
   \   00000178   0x7008             STRB     R0,[R1, #+0]
   \   0000017A   0x.... 0x....      LDR.W    R0,??DataTable20_41
   \   0000017E   0x7800             LDRB     R0,[R0, #+0]
   \   00000180   0x2800             CMP      R0,#+0
   \   00000182   0xD112             BNE.N    ??AntProcessMessage_28
   1127                      {
   1128                        if(++Ant_u8SlaveMissedMessageMid == 0)
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable20_42
   \   00000188   0x7800             LDRB     R0,[R0, #+0]
   \   0000018A   0x1C40             ADDS     R0,R0,#+1
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable20_42
   \   00000190   0x7008             STRB     R0,[R1, #+0]
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable20_42
   \   00000196   0x7800             LDRB     R0,[R0, #+0]
   \   00000198   0x2800             CMP      R0,#+0
   \   0000019A   0xD106             BNE.N    ??AntProcessMessage_28
   1129                        {
   1130                          ++Ant_u8SlaveMissedMessageHigh;
   \   0000019C   0x.... 0x....      LDR.W    R0,??DataTable20_43
   \   000001A0   0x7800             LDRB     R0,[R0, #+0]
   \   000001A2   0x1C40             ADDS     R0,R0,#+1
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable20_43
   \   000001A8   0x7008             STRB     R0,[R1, #+0]
   1131                        }
   1132                      }
   1133                      
   1134                      /* Indication of this event still occurs at the ANT message period, so 
   1135                      an ANT_TICK message should be queued to the application message list.
   1136                      Overwrite au8MessageCopy with the ANT_TICK message data. */
   1137                      AntTick(EVENT_RX_FAIL);
   \                     ??AntProcessMessage_28: (+1)
   \   000001AA   0x2002             MOVS     R0,#+2
   \   000001AC   0x.... 0x....      BL       AntTick
   1138                      break;
   \   000001B0   0xE028             B.N      ??AntProcessMessage_20
   1139                    }
   1140          
   1141                    case EVENT_TX: /* ANT has sent a data message */
   1142                    {
   1143                      /* If this is a master device, then EVENT_TX means it's time to queue the 
   1144                      next message */
   1145                      if(G_stAntSetupData.AntChannelType == CHANNEL_TYPE_MASTER)
   \                     ??AntProcessMessage_23: (+1)
   \   000001B2   0x....             LDR.N    R0,??DataTable17
   \   000001B4   0x7840             LDRB     R0,[R0, #+1]
   \   000001B6   0x2810             CMP      R0,#+16
   \   000001B8   0xD102             BNE.N    ??AntProcessMessage_29
   1146                      {
   1147                        AntTick(EVENT_TX);
   \   000001BA   0x2003             MOVS     R0,#+3
   \   000001BC   0x.... 0x....      BL       AntTick
   1148                      }
   1149                      break;
   \                     ??AntProcessMessage_29: (+1)
   \   000001C0   0xE020             B.N      ??AntProcessMessage_20
   1150                    } 
   1151          
   1152                    case EVENT_TRANSFER_TX_COMPLETED: /* ACK received from an acknowledged data message */
   1153                    { 
   1154                      G_u32AntFlags |= _ANT_FLAGS_GOT_ACK;
   \                     ??AntProcessMessage_24: (+1)
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   000001C6   0x6800             LDR      R0,[R0, #+0]
   \   000001C8   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   000001CC   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   000001D0   0x6008             STR      R0,[R1, #+0]
   1155          
   1156                      AntTick(EVENT_TRANSFER_TX_COMPLETED);
   \   000001D2   0x2005             MOVS     R0,#+5
   \   000001D4   0x.... 0x....      BL       AntTick
   1157                      break;
   \   000001D8   0xE014             B.N      ??AntProcessMessage_20
   1158                    } 
   1159          
   1160                    case EVENT_TRANSFER_TX_FAILED: /* ACK was not received from an acknowledged data message */
   1161                    { 
   1162          
   1163                      /* Regardless of complete or fail, it is time to send the next message */
   1164                      AntTick(EVENT_TRANSFER_TX_FAILED);
   \                     ??AntProcessMessage_25: (+1)
   \   000001DA   0x2006             MOVS     R0,#+6
   \   000001DC   0x.... 0x....      BL       AntTick
   1165                      break;
   \   000001E0   0xE010             B.N      ??AntProcessMessage_20
   1166                    } 
   1167          
   1168                    case EVENT_CHANNEL_CLOSED: /* The ANT channel is now closed */
   1169                    {
   1170                      G_u32AntFlags &= ~_ANT_FLAGS_CHANNEL_OPEN;
   \                     ??AntProcessMessage_26: (+1)
   \   000001E2   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   000001E6   0x6800             LDR      R0,[R0, #+0]
   \   000001E8   0xF430 0x2000      BICS     R0,R0,#0x80000
   \   000001EC   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   000001F0   0x6008             STR      R0,[R1, #+0]
   1171                      break;
   \   000001F2   0xE007             B.N      ??AntProcessMessage_20
   1172                    }
   1173                    
   1174                    /* All other messages are unexpected for now */
   1175                    default:
   1176                      G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_EVENT;
   \                     ??AntProcessMessage_27: (+1)
   \   000001F4   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   000001F8   0x6800             LDR      R0,[R0, #+0]
   \   000001FA   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000001FE   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   00000202   0x6008             STR      R0,[R1, #+0]
   1177                      break;
   1178                  } /* end Ant_pu8AntRxBufferUnreadMsg[EVENT_CODE_INDEX] */
   1179                } /* end else RF event */
   1180                
   1181                break; 
   \                     ??AntProcessMessage_20: (+1)
   \   00000204   0xE03B             B.N      ??AntProcessMessage_30
   1182              } /* end case MESG_RESPONSE_EVENT_ID */
   1183          
   1184              case MESG_ACKNOWLEDGED_DATA_ID: /* An acknowledged data message was received */
   1185              { 
   1186                AntQueueApplicationMessage(ANT_DATA, &au8MessageCopy[BUFFER_INDEX_MESG_DATA]);
   \                     ??AntProcessMessage_8: (+1)
   \   00000206   0xF10D 0x0103      ADD      R1,SP,#+3
   \   0000020A   0x2001             MOVS     R0,#+1
   \   0000020C   0x.... 0x....      BL       AntQueueApplicationMessage
   1187          
   1188                /* If this is a slave device, then a data message received means it's time to send */
   1189                if(G_stAntSetupData.AntChannelType == CHANNEL_TYPE_SLAVE)
   \   00000210   0x....             LDR.N    R0,??DataTable17
   \   00000212   0x7840             LDRB     R0,[R0, #+1]
   \   00000214   0x2800             CMP      R0,#+0
   \   00000216   0xD102             BNE.N    ??AntProcessMessage_31
   1190                {
   1191                  AntTick(RESPONSE_NO_ERROR);
   \   00000218   0x2000             MOVS     R0,#+0
   \   0000021A   0x.... 0x....      BL       AntTick
   1192                }
   1193                
   1194                break;
   \                     ??AntProcessMessage_31: (+1)
   \   0000021E   0xE02E             B.N      ??AntProcessMessage_30
   1195              } /* end case MESG_ACKNOWLEDGED_DATA_ID */
   1196          
   1197              case MESG_BROADCAST_DATA_ID: /* A broadcast data message was received */
   1198              { 
   1199                /* Put the data message into the application data buffer */ 
   1200                AntQueueApplicationMessage(ANT_DATA, &au8MessageCopy[BUFFER_INDEX_MESG_DATA]);
   \                     ??AntProcessMessage_7: (+1)
   \   00000220   0xF10D 0x0103      ADD      R1,SP,#+3
   \   00000224   0x2001             MOVS     R0,#+1
   \   00000226   0x.... 0x....      BL       AntQueueApplicationMessage
   1201          
   1202                /* If this is a slave device, then a data message received means it's time to send */
   1203                if(G_stAntSetupData.AntChannelType == CHANNEL_TYPE_SLAVE)
   \   0000022A   0x....             LDR.N    R0,??DataTable17
   \   0000022C   0x7840             LDRB     R0,[R0, #+1]
   \   0000022E   0x2800             CMP      R0,#+0
   \   00000230   0xD102             BNE.N    ??AntProcessMessage_32
   1204                {
   1205                  AntTick(RESPONSE_NO_ERROR);
   \   00000232   0x2000             MOVS     R0,#+0
   \   00000234   0x.... 0x....      BL       AntTick
   1206                }
   1207                
   1208                break;
   \                     ??AntProcessMessage_32: (+1)
   \   00000238   0xE021             B.N      ??AntProcessMessage_30
   1209              } /* end case MESG_BROADCAST_DATA_ID */
   1210              
   1211              case MESG_CHANNEL_STATUS_ID: /* Message sent in response to a channel status request */
   1212              { 
   1213                break;
   \                     ??AntProcessMessage_9: (+1)
   \   0000023A   0xE020             B.N      ??AntProcessMessage_30
   1214              } /* end case ChannelStatus_CMD */
   1215              
   1216              case MESG_VERSION_ID:
   1217              {
   1218                for(u8 i = 0; i < MESG_VERSION_SIZE; i++)
   \                     ??AntProcessMessage_5: (+1)
   \   0000023C   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_33: (+1)
   \   0000023E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000240   0x280A             CMP      R0,#+10
   \   00000242   0xDA08             BGE.N    ??AntProcessMessage_34
   1219                {
   1220                  Ant_u8AntVersion[i] = au8MessageCopy[BUFFER_INDEX_VERSION_BYTE0 + i];
   \   00000244   0xA900             ADD      R1,SP,#+0
   \   00000246   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000248   0x1841             ADDS     R1,R0,R1
   \   0000024A   0x7889             LDRB     R1,[R1, #+2]
   \   0000024C   0x....             LDR.N    R2,??DataTable20_13
   \   0000024E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000250   0x5481             STRB     R1,[R0, R2]
   1221                }
   \   00000252   0x1C40             ADDS     R0,R0,#+1
   \   00000254   0xE7F3             B.N      ??AntProcessMessage_33
   1222                
   1223                /* If we get a version message, we know that ANT comms is good */
   1224                G_u32ApplicationFlags |= _APPLICATION_FLAGS_ANT;
   \                     ??AntProcessMessage_34: (+1)
   \   00000256   0x....             LDR.N    R0,??DataTable20_11
   \   00000258   0x6800             LDR      R0,[R0, #+0]
   \   0000025A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000025E   0x....             LDR.N    R1,??DataTable20_11
   \   00000260   0x6008             STR      R0,[R1, #+0]
   1225                
   1226                break;
   \   00000262   0xE00C             B.N      ??AntProcessMessage_30
   1227              } /* end case MESG_VERSION_ID */
   1228          
   1229              case MESG_RESTART_ID:
   1230              {
   1231                G_u32AntFlags |= _ANT_FLAGS_RESTART;  
   \                     ??AntProcessMessage_10: (+1)
   \   00000264   0x....             LDR.N    R0,??DataTable20_14
   \   00000266   0x6800             LDR      R0,[R0, #+0]
   \   00000268   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000026C   0x....             LDR.N    R1,??DataTable20_14
   \   0000026E   0x6008             STR      R0,[R1, #+0]
   1232                break;
   \   00000270   0xE005             B.N      ??AntProcessMessage_30
   1233              } /* end case MESG_RESTART_ID */
   1234              
   1235              default:
   1236                G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_MSG;
   \                     ??AntProcessMessage_11: (+1)
   \   00000272   0x....             LDR.N    R0,??DataTable20_14
   \   00000274   0x6800             LDR      R0,[R0, #+0]
   \   00000276   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000027A   0x....             LDR.N    R1,??DataTable20_14
   \   0000027C   0x6008             STR      R0,[R1, #+0]
   1237                break;
   1238            } /* end switch( Ant_pu8AntRxBufferUnreadMsg[MESG_ID_OFFSET] ) */
   1239                     
   1240            return(0);
   \                     ??AntProcessMessage_30: (+1)
   \   0000027E   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_1: (+1)
   \   00000280   0xB005             ADD      SP,SP,#+20
   \   00000282   0xBD30             POP      {R4,R5,PC}       ;; return
   1241            
   1242          } /* end AntProcessMessage() */
   1243          
   1244          
   1245          /*-----------------------------------------------------------------------------/
   1246          Function: AntTick
   1247          
   1248          Description:
   1249          Queues an ANT_TICK message to the application message queue.
   1250          
   1251          Requires:
   1252            - u8Code_ is payload byte indicating system info that may be relavent to the application
   1253          
   1254          Promises:
   1255            - A MESSAGE_ANT_TICK is queued to G_sAntApplicationMsgList
   1256          */

   \                                 In section .text, align 2, keep-with-next
   1257          static void AntTick(u8 u8Code_)
   1258          {
   \                     AntTick: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1259            u8 au8Message[ANT_APPLICATION_MESSAGE_BYTES];
   1260          
   1261            /* Update data to communicate the ANT_TICK to the application */
   1262            au8Message[ANT_TICK_MSG_ID_INDEX]               = MESSAGE_ANT_TICK;
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1263            au8Message[ANT_TICK_MSG_EVENT_CODE_INDEX]       = u8Code_;
   \   0000000A   0xF88D 0x4001      STRB     R4,[SP, #+1]
   1264            au8Message[ANT_TICK_MSG_SENTINEL1_INDEX]        = MESSAGE_ANT_TICK;
   \   0000000E   0x20FF             MOVS     R0,#+255
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1265            au8Message[ANT_TICK_MSG_SENTINEL2_INDEX]        = MESSAGE_ANT_TICK;
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1266            au8Message[ANT_TICK_MSG_SENTINEL3_INDEX]        = MESSAGE_ANT_TICK;
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1267            au8Message[ANT_TICK_MSG_MISSED_HIGH_BYTE_INDEX] = Ant_u8SlaveMissedMessageHigh;
   \   00000020   0x....             LDR.N    R0,??DataTable20_43
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1268            au8Message[ANT_TICK_MSG_MISSED_MID_BYTE_INDEX]  = Ant_u8SlaveMissedMessageMid;
   \   00000028   0x....             LDR.N    R0,??DataTable20_42
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1269            au8Message[ANT_TICK_MSG_MISSED_LOW_BYTE_INDEX]  = Ant_u8SlaveMissedMessageLow;
   \   00000030   0x....             LDR.N    R0,??DataTable20_41
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1270          
   1271            AntQueueApplicationMessage(ANT_TICK, &au8Message[ANT_TICK_MSG_ID_INDEX]);
   \   00000038   0xA900             ADD      R1,SP,#+0
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0x.... 0x....      BL       AntQueueApplicationMessage
   1272          
   1273          } /* end AntTick() */
   \   00000040   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1274          
   1275          
   1276          /*-----------------------------------------------------------------------------/
   1277          Function: AntQueueApplicationMessage
   1278          
   1279          Description:
   1280          Creates a new ANT data message structure and adds it to G_sAntApplicationMsgList.
   1281          
   1282          Requires:
   1283            - eMessageType_ specifies the type of message
   1284            - pu8DataSource_ is a pointer to the first element of an array of 8 data bytes
   1285            - psTargetList_ is a pointer to the list pointer that is being updated
   1286            - Enough space is available on the heap
   1287          
   1288          Promises:
   1289            - A new list item in the target linked list is created and inserted at the end
   1290              of the list.
   1291            - Returns TRUE if the entry is added successfully.
   1292            - Returns FALSE if the malloc fails or the list is full.
   1293          */

   \                                 In section .text, align 2, keep-with-next
   1294          static bool AntQueueApplicationMessage(AntApplicationMessageType eMessageType_, u8 *pu8DataSource_)
   1295          {
   \                     AntQueueApplicationMessage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   1296            AntApplicationMsgListType *psNewMessage;
   1297            AntApplicationMsgListType *psListParser;
   1298            u8 u8MessageCount = 0;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
   1299            u8 au8AddMessageFailMsg[] = "\n\rNo space in AntQueueApplicationMessage\n\r";
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable20_44
   \   00000012   0x222B             MOVS     R2,#+43
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy
   1300            
   1301            /* Allocate space for the new message - always do maximum message size */
   1302            psNewMessage = malloc( sizeof(AntApplicationMsgListType) );
   \   00000018   0x2014             MOVS     R0,#+20
   \   0000001A   0x.... 0x....      BL       malloc
   \   0000001E   0x0006             MOVS     R6,R0
   1303            if (psNewMessage == NULL)
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD104             BNE.N    ??AntQueueApplicationMessage_0
   1304            {
   1305              DebugPrintf(au8AddMessageFailMsg);
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       DebugPrintf
   1306              return(FALSE);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE038             B.N      ??AntQueueApplicationMessage_1
   1307            }
   1308            
   1309            /* Fill in all the fields of the newly allocated message structure */
   1310            for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \                     ??AntQueueApplicationMessage_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??AntQueueApplicationMessage_2: (+1)
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2808             CMP      R0,#+8
   \   00000034   0xDA06             BGE.N    ??AntQueueApplicationMessage_3
   1311            {
   1312              psNewMessage->au8MessageData[i] = *(pu8DataSource_ + i);
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x5D41             LDRB     R1,[R0, R5]
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x1982             ADDS     R2,R0,R6
   \   0000003E   0x7151             STRB     R1,[R2, #+5]
   1313            }
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0xE7F5             B.N      ??AntQueueApplicationMessage_2
   1314            
   1315            psNewMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueApplicationMessage_3: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable17_4
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x6030             STR      R0,[R6, #+0]
   1316            psNewMessage->eMessageType  = eMessageType_;
   \   0000004A   0x7134             STRB     R4,[R6, #+4]
   1317            psNewMessage->psNextMessage = NULL;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6130             STR      R0,[R6, #+16]
   1318          
   1319            /* Insert into an empty list */
   1320            if(G_sAntApplicationMsgList == NULL)
   \   00000050   0x....             LDR.N    R0,??DataTable20_6
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD107             BNE.N    ??AntQueueApplicationMessage_4
   1321            {
   1322              G_sAntApplicationMsgList = psNewMessage;
   \   00000058   0x....             LDR.N    R0,??DataTable20_6
   \   0000005A   0x6006             STR      R6,[R0, #+0]
   1323              Ant_u32ApplicationMessageCount++;
   \   0000005C   0x....             LDR.N    R0,??DataTable20_32
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable20_32
   \   00000064   0x6008             STR      R0,[R1, #+0]
   \   00000066   0xE01A             B.N      ??AntQueueApplicationMessage_5
   1324            }
   1325          
   1326            /* Otherwise traverse the list to find the end where the new message will be inserted */
   1327            else
   1328            {
   1329              psListParser = G_sAntApplicationMsgList;
   \                     ??AntQueueApplicationMessage_4: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable20_6
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x0007             MOVS     R7,R0
   1330              while(psListParser->psNextMessage != NULL) 
   \                     ??AntQueueApplicationMessage_6: (+1)
   \   0000006E   0x6938             LDR      R0,[R7, #+16]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD003             BEQ.N    ??AntQueueApplicationMessage_7
   1331              {
   1332                psListParser = psListParser->psNextMessage;
   \   00000074   0x693F             LDR      R7,[R7, #+16]
   1333                u8MessageCount++;
   \   00000076   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000007A   0xE7F8             B.N      ??AntQueueApplicationMessage_6
   1334              }
   1335              
   1336              /* Check for full list */
   1337              if(u8MessageCount < ANT_APPLICATION_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueApplicationMessage_7: (+1)
   \   0000007C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000080   0xF1B8 0x0F20      CMP      R8,#+32
   \   00000084   0xD206             BCS.N    ??AntQueueApplicationMessage_8
   1338              {
   1339                /* Insert the new message at the end of the list */
   1340                psListParser->psNextMessage = psNewMessage;
   \   00000086   0x613E             STR      R6,[R7, #+16]
   1341                Ant_u32ApplicationMessageCount++;
   \   00000088   0x....             LDR.N    R0,??DataTable20_32
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \   0000008E   0x....             LDR.N    R1,??DataTable20_32
   \   00000090   0x6008             STR      R0,[R1, #+0]
   \   00000092   0xE004             B.N      ??AntQueueApplicationMessage_5
   1342              }
   1343              /* Handle a full list */
   1344              else
   1345              {
   1346                DebugPrintf(au8AddMessageFailMsg);
   \                     ??AntQueueApplicationMessage_8: (+1)
   \   00000094   0xA800             ADD      R0,SP,#+0
   \   00000096   0x.... 0x....      BL       DebugPrintf
   1347                return(FALSE);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE000             B.N      ??AntQueueApplicationMessage_1
   1348              }
   1349            }
   1350              
   1351            return(TRUE);
   \                     ??AntQueueApplicationMessage_5: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \                     ??AntQueueApplicationMessage_1: (+1)
   \   000000A0   0xB00C             ADD      SP,SP,#+48
   \   000000A2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1352              
   1353          } /* end AntQueueApplicationMessage() */
   1354          
   1355          
   1356          /*-----------------------------------------------------------------------------/
   1357          Function: AntDeQueueOutgoingMessage
   1358          
   1359          Description:
   1360          Removes the first entry of Ant_psDataOutgoingMsgList.
   1361          
   1362          Requires:
   1363            - 
   1364          
   1365          Promises:
   1366            - Ant_psDataOutgoingMsgList = Ant_psDataOutgoingMsgList->psNextMessage 
   1367            and the memory is freed
   1368          */

   \                                 In section .text, align 2, keep-with-next
   1369          static void AntDeQueueOutgoingMessage(void)
   1370          {
   \                     AntDeQueueOutgoingMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1371            AntOutgoingMessageListType *psMessageToKill;
   1372            
   1373            if(Ant_psDataOutgoingMsgList != NULL)
   \   00000002   0x....             LDR.N    R0,??DataTable20_7
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00A             BEQ.N    ??AntDeQueueOutgoingMessage_0
   1374            {
   1375              psMessageToKill = Ant_psDataOutgoingMsgList;
   \   0000000A   0x....             LDR.N    R0,??DataTable20_7
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0004             MOVS     R4,R0
   1376              Ant_psDataOutgoingMsgList = Ant_psDataOutgoingMsgList->psNextMessage;
   \   00000010   0x....             LDR.N    R0,??DataTable20_7
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6980             LDR      R0,[R0, #+24]
   \   00000016   0x....             LDR.N    R1,??DataTable20_7
   \   00000018   0x6008             STR      R0,[R1, #+0]
   1377            
   1378              /* The doomed message is properly disconnected, so kill it */
   1379              free(psMessageToKill);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       free
   1380            }
   1381            
   1382          } /* end AntDeQueueOutgoingMessage() */
   \                     ??AntDeQueueOutgoingMessage_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
   1383          
   1384          
   1385          /***********************************************************************************************************************
   1386          ##### ANT State Machine Definition                                             
   1387          ***********************************************************************************************************************/
   1388          
   1389          /*------------------------------------------------------------------------------
   1390          Idle state that will process new messages if any are present, monitors ANT
   1391          for incoming messages, and sends broadcast messages that are waiting to be sent.
   1392          Incoming messages from ANT always get priority.  
   1393          */

   \                                 In section .text, align 4, keep-with-next
   1394          void AntSM_Idle(void)
   1395          {
   \                     AntSM_Idle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1396            u32 u32MsgBitMask = 0x01;
   \   00000002   0x2401             MOVS     R4,#+1
   1397            u8 u8MsgIndex = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1398            static u8 au8AntFlagAlert[] = "ANT flags:\n\r"; 
   1399            
   1400            /* Error messages: must match order of G_u32AntFlags Error / event flags */
   1401            static u8 au8AntFlagMessages[][20] = 
   1402            {/* "012345678901234567\n\r" */
   1403                "Length mismatch\n\r",
   1404                "Command error\n\r",
   1405                "Unexpected event\n\r",
   1406                "Unexpected message\n\r"
   1407            };
   1408            
   1409            /* Check flags */
   1410            if(G_u32AntFlags & ANT_ERROR_FLAGS_MASK)
   \   00000006   0x....             LDR.N    R0,??DataTable20_14
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0400             LSLS     R0,R0,#+16
   \   0000000C   0xD020             BEQ.N    ??AntSM_Idle_0
   1411            {
   1412              /* At least one flag is set, so print header and parse out */
   1413              DebugPrintf(au8AntFlagAlert);
   \   0000000E   0x....             LDR.N    R0,??DataTable20_45
   \   00000010   0x.... 0x....      BL       DebugPrintf
   1414              u8MsgIndex++;
   \   00000014   0x1C6D             ADDS     R5,R5,#+1
   1415              for(u8 i = 0; i < ANT_ERROR_FLAGS_COUNT; i++)
   \   00000016   0x2600             MOVS     R6,#+0
   \                     ??AntSM_Idle_1: (+1)
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x2E04             CMP      R6,#+4
   \   0000001C   0xDA12             BGE.N    ??AntSM_Idle_2
   1416              {
   1417                /* Check if current flag is set */
   1418                if(G_u32AntFlags & u32MsgBitMask)
   \   0000001E   0x....             LDR.N    R0,??DataTable20_14
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x4220             TST      R0,R4
   \   00000024   0xD00B             BEQ.N    ??AntSM_Idle_3
   1419                {
   1420                  /* Print the error message and clear the flag */
   1421                  DebugPrintf(au8AntFlagMessages[u8MsgIndex]);
   \   00000026   0x....             LDR.N    R0,??DataTable20_46
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2114             MOVS     R1,#+20
   \   0000002C   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000030   0x.... 0x....      BL       DebugPrintf
   1422                  G_u32AntFlags &= ~u32MsgBitMask;
   \   00000034   0x....             LDR.N    R0,??DataTable20_14
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x43A0             BICS     R0,R0,R4
   \   0000003A   0x....             LDR.N    R1,??DataTable20_14
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   1423                }
   1424                u32MsgBitMask <<= 1;
   \                     ??AntSM_Idle_3: (+1)
   \   0000003E   0x0064             LSLS     R4,R4,#+1
   1425              }
   \   00000040   0x1C76             ADDS     R6,R6,#+1
   \   00000042   0xE7E9             B.N      ??AntSM_Idle_1
   1426              
   1427              /* Clear all the error flags now that they have been reported */
   1428              G_u32AntFlags &= ~ANT_ERROR_FLAGS_MASK;
   \                     ??AntSM_Idle_2: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable20_14
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x0C00             LSRS     R0,R0,#+16
   \   0000004A   0x0400             LSLS     R0,R0,#+16
   \   0000004C   0x....             LDR.N    R1,??DataTable20_14
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1429            }
   1430            
   1431            /* Process messages received from ANT */
   1432            AntProcessMessage();
   \                     ??AntSM_Idle_0: (+1)
   \   00000050   0x.... 0x....      BL       AntProcessMessage
   1433          
   1434            /* Handle messages coming in from ANT */
   1435            if( IS_SEN_ASSERTED() )
   \   00000054   0x....             LDR.N    R0,??DataTable19
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x07C0             LSLS     R0,R0,#+31
   \   0000005A   0xD504             BPL.N    ??AntSM_Idle_4
   1436            {
   1437              Ant_pfnStateMachine = AntSM_ReceiveMessage;
   \   0000005C   0x.... 0x....      ADR.W    R0,AntSM_ReceiveMessage
   \   00000060   0x....             LDR.N    R1,??DataTable20_3
   \   00000062   0x6008             STR      R0,[R1, #+0]
   \   00000064   0xE016             B.N      ??AntSM_Idle_5
   1438            }
   1439            
   1440            /* Send a message if the system is ready and there is one to send */ 
   1441            else if( (Ant_u32CurrentTxMessageToken == 0 ) && 
   1442                     (Ant_psDataOutgoingMsgList != NULL) )
   \                     ??AntSM_Idle_4: (+1)
   \   00000066   0x....             LDR.N    R0,??DataTable20_26
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD112             BNE.N    ??AntSM_Idle_5
   \   0000006E   0x....             LDR.N    R0,??DataTable20_7
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD00E             BEQ.N    ??AntSM_Idle_5
   1443            {
   1444              /* Give the message to AntTx which will set Ant_u32CurrentTxMessageToken */
   1445              if(AntTxMessage(Ant_psDataOutgoingMsgList->au8MessageData))
   \   00000076   0x....             LDR.N    R0,??DataTable20_7
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1D00             ADDS     R0,R0,#+4
   \   0000007C   0x.... 0x....      BL       AntTxMessage
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD007             BEQ.N    ??AntSM_Idle_5
   1446              {
   1447                Ant_u32TxTimer = G_u32SystemTime1ms;
   \   00000084   0x....             LDR.N    R0,??DataTable20_47
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x....             LDR.N    R1,??DataTable20_48
   \   0000008A   0x6008             STR      R0,[R1, #+0]
   1448                Ant_pfnStateMachine = AntSM_TransmitMessage;
   \   0000008C   0x.... 0x....      ADR.W    R0,AntSM_TransmitMessage
   \   00000090   0x....             LDR.N    R1,??DataTable20_3
   \   00000092   0x6008             STR      R0,[R1, #+0]
   1449              }
   1450              else
   1451              {
   1452                /* Transmit attempt failed.  !!!! Do something? */
   1453              }
   1454            }
   1455            
   1456          } /* end AntSM_Idle() */
   \                     ??AntSM_Idle_5: (+1)
   \   00000094   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8AntFlagAlert:
   \   00000000   0x41 0x4E          DC8 "ANT flags:\012\015"
   \              0x54 0x20    
   \              0x66 0x6C    
   \              0x61 0x67    
   \              0x73 0x3A    
   \              0x0A 0x0D    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     ??au8AntFlagMessages:
   \   00000000   0x4C 0x65          DC8 "Length mismatch\012\015"
   \              0x6E 0x67    
   \              0x74 0x68    
   \              0x20 0x6D    
   \              0x69 0x73    
   \              0x6D 0x61    
   \              0x74 0x63    
   \              0x68 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x43 0x6F          DC8 "Command error\012\015"
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x0A    
   \              0x0D 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000028   0x55 0x6E          DC8 "Unexpected event\012\015"
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000003B   0x00               DC8 0
   \   0000003C   0x55 0x6E          DC8 55H, 6EH, 65H, 78H, 70H, 65H, 63H, 74H
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \   00000044   0x65 0x64          DC8 65H, 64H, 20H, 6DH, 65H, 73H, 73H, 61H
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \   0000004C   0x67 0x65          DC8 67H, 65H, 0AH, 0DH
   \              0x0A 0x0D    
   1457          
   1458          
   1459          /*------------------------------------------------------------------------------
   1460          Completely receive an ANT message.  Reception is very fast and should complete
   1461          in less than 600us for a 15-byte message.  AntRxMessage could just be called from Idle,
   1462          but giving it its own state minimizes the total time and allows for easier future
   1463          updates should they be required.
   1464          */

   \                                 In section .text, align 4, keep-with-next
   1465          void AntSM_ReceiveMessage(void)
   1466          {
   \                     AntSM_ReceiveMessage: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1467            Ant_DebugRxMessageCounter++;
   \   00000002   0x....             LDR.N    R0,??DataTable20_49
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable20_49
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1468            AntRxMessage();
   \   0000000C   0x.... 0x....      BL       AntRxMessage
   1469            
   1470            Ant_pfnStateMachine = AntSM_Idle;
   \   00000010   0x....             LDR.N    R0,??DataTable20_50
   \   00000012   0x....             LDR.N    R1,??DataTable20_3
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1471          
   1472          } /* end AntSM_ReceiveMessage() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   1473          
   1474          
   1475          /*------------------------------------------------------------------------------
   1476          Wait for an ANT message to be transmitted.  This state only occurs once the 
   1477          handshaking transaction has been completed and transmit to ANT is verified 
   1478          and underway.
   1479          */

   \                                 In section .text, align 4, keep-with-next
   1480          void AntSM_TransmitMessage(void)
   1481          {
   \                     AntSM_TransmitMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1482            static u8 au8TxTimeoutMsg[] = "\n\rTransmit message timeout\n\r";
   1483            MessageStateType eCurrentMsgStatus;
   1484            
   1485            eCurrentMsgStatus = QueryMessageStatus(Ant_u32CurrentTxMessageToken);
   \   00000002   0x....             LDR.N    R0,??DataTable20_26
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       QueryMessageStatus
   \   0000000A   0x0004             MOVS     R4,R0
   1486            switch(eCurrentMsgStatus)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x1F00             SUBS     R0,R0,#+4
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD82E             BHI.N    ??AntSM_TransmitMessage_0
   1487            {
   1488              case TIMEOUT:
   1489                /* Fall through */
   1490                
   1491              case COMPLETE:
   1492                /* Kill the message and update flags */
   1493                AntDeQueueOutgoingMessage();
   \                     ??AntSM_TransmitMessage_1: (+1)
   \   00000016   0x.... 0x....      BL       AntDeQueueOutgoingMessage
   1494                Ant_u32CurrentTxMessageToken = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable20_26
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1495                G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \   00000020   0x....             LDR.N    R0,??DataTable20_14
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF030 0x6000      BICS     R0,R0,#0x8000000
   \   00000028   0x....             LDR.N    R1,??DataTable20_14
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1496          
   1497                /* Wait for SEN to deassert so we know ANT is totally ready for the text
   1498                transaction.  This takes about 170us, so block in this state until that's over */
   1499                while ( IS_SEN_ASSERTED() && (Ant_u32TxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntSM_TransmitMessage_2: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable20_51
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x07C0             LSLS     R0,R0,#+31
   \   00000032   0xD50B             BPL.N    ??AntSM_TransmitMessage_3
   \   00000034   0x....             LDR.N    R0,??DataTable20_48
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF242 0x7110      MOVW     R1,#+10000
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD205             BCS.N    ??AntSM_TransmitMessage_3
   1500                {
   1501                  Ant_u32TxTimer++;
   \   00000040   0x....             LDR.N    R0,??DataTable20_48
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x....             LDR.N    R1,??DataTable20_48
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE7EF             B.N      ??AntSM_TransmitMessage_2
   1502                }
   1503          
   1504                /* If we timed out, then ANT is stuck so print error and unstick ANT */
   1505                if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntSM_TransmitMessage_3: (+1)
   \   0000004C   0x....             LDR.N    R0,??DataTable20_52
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF242 0x7111      MOVW     R1,#+10001
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD309             BCC.N    ??AntSM_TransmitMessage_4
   1506                {
   1507                  DebugPrintf(au8TxTimeoutMsg);
   \   00000058   0x....             LDR.N    R0,??DataTable20_53
   \   0000005A   0x.... 0x....      BL       DebugPrintf
   1508                  while( IS_SEN_ASSERTED() )
   \                     ??AntSM_TransmitMessage_5: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable20_51
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x07C0             LSLS     R0,R0,#+31
   \   00000064   0xD502             BPL.N    ??AntSM_TransmitMessage_4
   1509                  {
   1510                    AntSrdyPulse();
   \   00000066   0x.... 0x....      BL       AntSrdyPulse
   \   0000006A   0xE7F8             B.N      ??AntSM_TransmitMessage_5
   1511                  }
   1512                }
   1513                
   1514                Ant_pfnStateMachine = AntSM_Idle;
   \                     ??AntSM_TransmitMessage_4: (+1)
   \   0000006C   0x....             LDR.N    R0,??DataTable20_50
   \   0000006E   0x....             LDR.N    R1,??DataTable20_3
   \   00000070   0x6008             STR      R0,[R1, #+0]
   1515                break;
   \   00000072   0xE7FF             B.N      ??AntSM_TransmitMessage_6
   1516                
   1517              default:
   1518                /* Do nothing for now */
   1519                break;
   1520                
   1521            } /* end switch */
   1522            
   1523          } /* end AntSM_TransmitMessage() */
   \                     ??AntSM_TransmitMessage_0: (+1)
   \                     ??AntSM_TransmitMessage_6: (+1)
   \   00000074   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .data, align 4
   \                     ??au8TxTimeoutMsg:
   \   00000000   0x0A 0x0D          DC8 "\012\015Transmit message timeout\012\015"
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6D    
   \              0x69 0x74    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1524          
   1525          
   1526          /*------------------------------------------------------------------------------
   1527          Do-nothing state if ANT is dead (requires restart to retry initialization)
   1528          */

   \                                 In section .text, align 4, keep-with-next
   1529          void AntSM_NoResponse(void)
   1530          {
   1531            
   1532          } /* end AntSM_NoResponse() */
   \                     AntSM_NoResponse: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x400E0E34         DC32     0x400e0e34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     Ant_u32RxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     Ant_u32RxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     G_stAntSetupData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferCurrentChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferUnreadMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     Ant_u8AntNewRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     Ant_DebugTotalRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x400E0E30         DC32     0x400e0e30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     Ant_u32RxTimeoutCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     Ant_u32UnexpectedByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer+0x100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     G_au8AntMessageNoAnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     AntSM_NoResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     Ant_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x400E0E10         DC32     0x400e0e10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     G_au8AntMessageInit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x........         DC32     G_sAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     Ant_psDataOutgoingMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x........         DC32     Ant_sSspConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \   00000000   0x400E0E00         DC32     0x400e0e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \   00000000   0x........         DC32     Ant_Ssp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \   00000000   0x........         DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \   00000000   0x........         DC32     Ant_u8AntVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_14:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_15:
   \   00000000   0x........         DC32     G_au8AntMessageInitFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_16:
   \   00000000   0x400E0C04         DC32     0x400e0c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_17:
   \   00000000   0x400E0C00         DC32     0x400e0c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_18:
   \   00000000   0x400E0E04         DC32     0x400e0e04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_19:
   \   00000000   0x400E0C14         DC32     0x400e0c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_20:
   \   00000000   0x400E0E14         DC32     0x400e0e14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_21:
   \   00000000   0x........         DC32     G_u32SystemTime1s

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_22:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_23:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_24:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_25:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_26:
   \   00000000   0x........         DC32     Ant_u32CurrentTxMessageToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_27:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_28:
   \   00000000   0x........         DC32     Ant_u32TxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_29:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_30:
   \   00000000   0x........         DC32     Ant_DebugQueuedDataMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_31:
   \   00000000   0x........         DC32     Ant_u32OutgoingMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_32:
   \   00000000   0x........         DC32     Ant_u32ApplicationMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_33:
   \   00000000   0x........         DC32     Ant_DebugProcessRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_34:
   \   00000000   0x........         DC32     G_au8AntMessageOpen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_35:
   \   00000000   0x........         DC32     G_au8AntMessageClose

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_36:
   \   00000000   0x........         DC32     G_au8AntMessageAssign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_37:
   \   00000000   0x........         DC32     G_au8AntMessageUnassign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_38:
   \   00000000   0xFFE3FFFE         DC32     0xffe3fffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_39:
   \   00000000   0x........         DC32     G_au8AntMessageUnhandled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_40:
   \   00000000   0x........         DC32     G_au8AntMessageFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_41:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageLow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_42:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageMid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_43:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageHigh

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_44:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_45:
   \   00000000   0x........         DC32     ??au8AntFlagAlert

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_46:
   \   00000000   0x........         DC32     ??au8AntFlagMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_47:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_48:
   \   00000000   0x........         DC32     Ant_u32TxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_49:
   \   00000000   0x........         DC32     Ant_DebugRxMessageCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_50:
   \   00000000   0x........         DC32     AntSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_51:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_52:
   \   00000000   0x........         DC32     Ant_u32RxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_53:
   \   00000000   0x........         DC32     ??au8TxTimeoutMsg

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x02 0x4D          DC8 2, 77, 0, 62, 0, 0, 0, 0
   \              0x00 0x3E    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x41 0x6E          DC8 "AntRx: timeout\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x41 0x6E          DC8 "AntRx: message failed\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x41 0x6E          DC8 "AntTx: msg already in progress\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x61    
   \              0x6C 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x6F 0x67    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x41 0x6E          DC8 "AntTx: SEN timeout\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x53    
   \              0x45 0x4E    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x41 0x6E          DC8 "AntTx: No token\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x74 0x6F    
   \              0x6B 0x65    
   \              0x6E 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x41 0x6E          DC8 "AntTx: No SYNC\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x53 0x59    
   \              0x4E 0x43    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x0D 0x0A          DC8 "\015\012ANT expected msg fail\012\015"
   \              0x41 0x4E    
   \              0x54 0x20    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x0A    
   \              0x0D 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x0A 0x0D          DC8 "\012\015No space in AntQueueOutgoingMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x4F 0x75    
   \              0x74 0x67    
   \              0x6F 0x69    
   \              0x6E 0x67    
   \              0x4D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x0A 0x0D          DC8 "\012\015No space in AntQueueApplicationMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x41 0x70    
   \              0x70 0x6C    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x4D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002B   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AdvanceAntRxBufferCurrentChar
       0   AdvanceAntRxBufferUnreadMsgPointer
       0   AntAbortMessage
       4   AntCalculateTxChecksum
       8   AntDeQueueApplicationMessage
         8   -> free
       8   AntDeQueueOutgoingMessage
         8   -> free
      56   AntExpectResponse
        56   -> AntDeQueueOutgoingMessage
        56   -> AntProcessMessage
        56   -> AntRxMessage
        56   -> DebugPrintf
        56   -> IsTimeUp
        56   -> __aeabi_memcpy
      16   AntInitialize
        16   -> AntSyncSerialInitialize
        16   -> DebugLineFeed
        16   -> DebugPrintf
        16   -> SspRequest
      32   AntProcessMessage
        32   -> AdvanceAntRxBufferUnreadMsgPointer
        32   -> AntQueueApplicationMessage
        32   -> AntTick
        32   -> DebugPrintf
      72   AntQueueApplicationMessage
        72   -> DebugPrintf
        72   -> __aeabi_memcpy
        72   -> malloc
      64   AntQueueOutgoingMessage
        64   -> DebugPrintf
        64   -> __aeabi_memcpy4
        64   -> malloc
       8   AntRunActiveState
         8   -- Indirect call
       8   AntRxFlowControlCallback
         8   -> AntSrdyPulse
      64   AntRxMessage
        64   -> AdvanceAntRxBufferCurrentChar
        64   -> AdvanceAntRxBufferUnreadMsgPointer
        64   -> AntAbortMessage
        64   -> AntSrdyPulse
        64   -> DebugPrintf
        64   -> __aeabi_memcpy
        64   -> __aeabi_memcpy4
      16   AntSM_Idle
        16   -> AntProcessMessage
        16   -> AntTxMessage
        16   -> DebugPrintf
       0   AntSM_NoResponse
       8   AntSM_ReceiveMessage
         8   -> AntRxMessage
       8   AntSM_TransmitMessage
         8   -> AntDeQueueOutgoingMessage
         8   -> AntSrdyPulse
         8   -> DebugPrintf
         8   -> QueryMessageStatus
       0   AntSrdyPulse
      24   AntSyncSerialInitialize
        24   -> AntCalculateTxChecksum
        24   -> AntExpectResponse
        24   -> AntProcessMessage
        24   -> AntRxMessage
        24   -> AntTxMessage
        24   -> IsTimeUp
      16   AntTick
        16   -> AntQueueApplicationMessage
       8   AntTxFlowControlCallback
         8   -> AntSrdyPulse
     120   AntTxMessage
       120   -> AdvanceAntRxBufferCurrentChar
       120   -> AdvanceAntRxBufferUnreadMsgPointer
       120   -> AntSrdyPulse
       120   -> DebugPrintf
       120   -> SspWriteData
       120   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_16
       4  ??DataTable20_17
       4  ??DataTable20_18
       4  ??DataTable20_19
       4  ??DataTable20_2
       4  ??DataTable20_20
       4  ??DataTable20_21
       4  ??DataTable20_22
       4  ??DataTable20_23
       4  ??DataTable20_24
       4  ??DataTable20_25
       4  ??DataTable20_26
       4  ??DataTable20_27
       4  ??DataTable20_28
       4  ??DataTable20_29
       4  ??DataTable20_3
       4  ??DataTable20_30
       4  ??DataTable20_31
       4  ??DataTable20_32
       4  ??DataTable20_33
       4  ??DataTable20_34
       4  ??DataTable20_35
       4  ??DataTable20_36
       4  ??DataTable20_37
       4  ??DataTable20_38
       4  ??DataTable20_39
       4  ??DataTable20_4
       4  ??DataTable20_40
       4  ??DataTable20_41
       4  ??DataTable20_42
       4  ??DataTable20_43
       4  ??DataTable20_44
       4  ??DataTable20_45
       4  ??DataTable20_46
       4  ??DataTable20_47
       4  ??DataTable20_48
       4  ??DataTable20_49
       4  ??DataTable20_5
       4  ??DataTable20_50
       4  ??DataTable20_51
       4  ??DataTable20_52
       4  ??DataTable20_53
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
       8  ?_0
      20  ?_1
      24  ?_2
      36  ?_3
      24  ?_4
      20  ?_5
      20  ?_6
      28  ?_7
      40  ?_8
      44  ?_9
      40  AdvanceAntRxBufferCurrentChar
      40  AdvanceAntRxBufferUnreadMsgPointer
      44  AntAbortMessage
      36  AntCalculateTxChecksum
      56  AntDeQueueApplicationMessage
      34  AntDeQueueOutgoingMessage
     228  AntExpectResponse
     400  AntInitialize
     644  AntProcessMessage
     166  AntQueueApplicationMessage
     200  AntQueueOutgoingMessage
      12  AntRunActiveState
      70  AntRxFlowControlCallback
     580  AntRxMessage
     150  AntSM_Idle
       2  AntSM_NoResponse
      24  AntSM_ReceiveMessage
     118  AntSM_TransmitMessage
      42  AntSrdyPulse
     230  AntSyncSerialInitialize
      66  AntTick
      22  AntTxFlowControlCallback
     396  AntTxMessage
       4  Ant_DebugProcessRxMessages
       4  Ant_DebugQueuedDataMessages
       4  Ant_DebugRxMessageCounter
       4  Ant_DebugTotalRxMessages
       4  Ant_Ssp
     256  Ant_au8AntRxBuffer
       4  Ant_pfnStateMachine
       4  Ant_psDataOutgoingMsgList
       4  Ant_pu8AntRxBufferCurrentChar
       4  Ant_pu8AntRxBufferNextChar
       4  Ant_pu8AntRxBufferUnreadMsg
      36  Ant_sSspConfig
       4  Ant_u32ApplicationMessageCount
       4  Ant_u32CurrentTxMessageToken
       4  Ant_u32OutgoingMessageCount
       4  Ant_u32RxByteCounter
       4  Ant_u32RxTimeoutCounter
       4  Ant_u32RxTimer
       4  Ant_u32TxByteCounter
       4  Ant_u32TxTimer
       4  Ant_u32UnexpectedByteCounter
       1  Ant_u8AntNewRxMessages
      12  Ant_u8AntVersion
       1  Ant_u8SlaveMissedMessageHigh
       1  Ant_u8SlaveMissedMessageLow
       1  Ant_u8SlaveMissedMessageMid
      20  G_au8AntMessageAssign
      20  G_au8AntMessageClose
       8  G_au8AntMessageFail
      24  G_au8AntMessageInit
      32  G_au8AntMessageInitFail
      64  G_au8AntMessageNoAnt
       8  G_au8AntMessageOk
      20  G_au8AntMessageOpen
      20  G_au8AntMessageSetup
      24  G_au8AntMessageUnassign
      28  G_au8AntMessageUnhandled
       4  G_sAntApplicationMsgList
      12  G_stAntSetupData
       4  G_u32AntFlags
      16  au8AntFlagAlert
      80  au8AntFlagMessages
      32  au8TxTimeoutMsg

 
   404 bytes in section .bss
   396 bytes in section .data
   264 bytes in section .rodata
 3 904 bytes in section .text
 
 3 904 bytes of CODE  memory
   264 bytes of CONST memory
   800 bytes of DATA  memory

Errors: none
Warnings: none
